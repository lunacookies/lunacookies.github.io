<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>A Simple Yet Useful Version of Generics · Luna’s Website</title><link rel=stylesheet href=https://arzg.github.io/scss/main.4c416d95677d182817af2141b6cb4189ca1b6ed1bf50c61f50f3812defff2c14.css integrity="sha256-TEFtlWd9GCgXryFBtstBicobbtG/UMYfUPOBLe//LBQ="><script src=https://unpkg.com/prismjs@1.25.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/plugins/autoloader/prism-autoloader.min.js></script></head><body><header><h1>A Simple Yet Useful Version of Generics</h1><p class=subtitle>Based on an old C idiom (as all my recent posts seem to be)</p></header><p>Traditionally,
containers are seen as
an area where generics with monomorphization
are essential;
who wants every key and every value
in their hash table to be boxed?
However,
I think pretty much every use-case for
generics in the context of containers
can be replaced with something far simpler.</p><p>To start,
let’s take a look at
a simple implementation of a dynamic array in C.
Everything in this post
applies to any sort of container;
I just chose a dynamic array
because it’s the easiest to implement.</p><p>First, the basics:</p><pre><code class=language-c>#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct vec {
	char *ptr;
	size_t len;
	size_t cap;
	size_t elem_size;
} vec;
</code></pre><p>We’ll need functions to create a new <code>vec</code>
and to destroy an existing one:</p><pre><code class=language-c>vec vec_init(size_t cap, size_t elem_size)
{
	return (vec){
		.ptr = calloc(cap, elem_size),
		.len = 0,
		.cap = cap,
		.elem_size = elem_size,
	};
}

void vec_deinit(vec v)
{
	free(v.ptr);
}
</code></pre><p>And we’ll need to be able to push new elements:</p><pre><code class=language-c>void vec_push(vec *v, void *elem)
{
	// grow exponentially once we’ve filled the allocation
	if (v-&gt;len &gt;= v-&gt;cap) {
		v-&gt;cap *= 2;
		size_t new_size = v-&gt;cap * v-&gt;elem_size;
		v-&gt;ptr = realloc(v-&gt;ptr, new_size);
	}

	void *dst = v-&gt;ptr + (v-&gt;elem_size * v-&gt;len);
	memcpy(dst, elem, v-&gt;elem_size);
	v-&gt;len++;
}
</code></pre><p>Finally, let’s add a function to index into the array:</p><pre><code class=language-c>void *vec_at(vec *v, size_t i)
{
	assert(i &lt; v-&gt;len);
	return v-&gt;ptr + (v-&gt;elem_size * i);
}
</code></pre><p>Now we’re ready to test it out!</p><pre><code class=language-c>typedef struct person {
	char *name;
	int age;
} person;

int main() {
	vec v = vec_init(8, sizeof(person));

	vec_push(&amp;v, &amp;(person){ &quot;luna&quot;, -1 });
	vec_push(&amp;v, &amp;(person){ &quot;someone else&quot;, 92 });
	vec_push(&amp;v, &amp;(person){ &quot;John Smith&quot;, 50 });

	for (size_t i = 0; i &lt; v.len; i++) {
		person *p = vec_at(&amp;v, i);
		printf(&quot;name: %s\nage: %d\n&quot;, p-&gt;name, p-&gt;age);
	}

	vec_deinit(v);
}
</code></pre><p>As expected, this prints the following:</p><pre><code>$ ./a.out
name: luna
age: -1
name: someone else
age: 92
name: John Smith
age: 50
</code></pre><p>However, being C,
this approach is error-prone.
In fact, while writing this post
I accidentally passed <code>sizeof(int)</code>
instead of <code>sizeof(person)</code> to <code>vec_init()</code>,
which took me a little while to figure out.
Moreover, it also isn’t type-safe,
so you could freely mix up
a <code>vec</code> of integers and a <code>vec</code> of enums.</p><p>Of course, a language with generics like Zig, C++ or Rust
wouldn’t have these problems.
If we’re willing to forgo
a tiny bit of performance, though,
we can get the same developer experience
as that of, say, Rust’s containers,
but without the long compile times
and binary bloat!</p><p>For every type of container imaginable
&ndash; except for fixed size arrays &ndash;
the data within the container
is stored behind a pointer.
This means that we can manipulate
the container’s data
without knowing its type,
<em>if we know the size of the type.</em>
We can store this size at runtime,
exactly as we did in C
with the <code>elem_size</code> field.
I imagine a language which allows
for the creation of type-safe generic APIs;
but rather than stamping out copies of container code
for each type the container is used with,
instead the generic type parameter’s size
is passed at runtime.</p><p class=signature><a href=https://arzg.github.io/>Luna Razzaghipour</a><br>17 February 2023</p><footer><p>Thoughts, comments, corrections or suggestions?
<a href=mailto:lunarazzaghipour@gmail.com>Email&nbsp;me!</a>
I’d&nbsp;like nothing more than to hear from you.</p></footer></body></html>