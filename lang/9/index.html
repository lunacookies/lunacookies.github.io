<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Part Nine: Function Calls · arzg’s website</title><link rel=stylesheet href=https://arzg.github.io/scss/main.5b8c013dd5e51a40b743f06124716408dad09d87641389dd50c9b9d63c648588.css integrity="sha256-W4wBPdXlGkC3Q/BhJHFkCNrQnYdkE4ndUMm51jxkhYg="><script src=https://unpkg.com/quicklink@2.0.0/dist/quicklink.umd.js></script>
<script src=https://unpkg.com/anchor-js@4.3.1/anchor.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/plugins/autoloader/prism-autoloader.min.js></script>
<script>window.onload=()=>{quicklink.listen()},document.addEventListener("DOMContentLoaded",function(a){anchors.add("main h1")})</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body><nav class=site-navigation><ul><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li class=current><a href=/lang/>Make A Language</a></li></ul></nav><header class=header-area><h1 class=title>Part Nine: Function Calls</h1><section class=page-info><ul><li>8 November 2020</li><li>4465 words</li><li>22 minute read</li></ul></section></header><main><p>As we did last time, we need to choose a syntax, this time for function calls.</p><pre><code class=language-rust>// Rust syntax
f(a, b, c);
no_params();
</code></pre><p>Again, as I said in the previous part, parentheses and commas are annoying. Hence, Eldiro will use a different syntax in the spirit of ML-family languages:</p><pre><code>f a b c
no_params
</code></pre><p>Much cleaner! This doesn’t syntactically distinguish between calling a function with no parameters and using a binding, though &ndash; we don’t know during parsing whether <code>no_params</code> is a binding usage, or a function call with no parameters. We can solve this by looking at all the functions and bindings in scope during interpretation of a binding usage &ndash; if there’s a function with the name of the binding usage, we evaluate that with no parameters. If there isn’t, then we fall back to our usual strategy.</p><h1 id=parsing>Parsing</h1><p>We need a new module:</p><pre><code class=language-rust>// expr.rs

mod binding_usage;
mod block;
mod func_call;
</code></pre><p>Let’s write our first test:</p><pre><code class=language-rust>// src/expr/func_call.rs

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_func_call_with_no_params() {
        assert_eq!(
            FuncCall::new(&quot;greet_user&quot;),
            Ok((
                &quot;&quot;,
                FuncCall {
                    callee: &quot;greet_user&quot;.to_string(),
                    params: Vec::new(),
                },
            )),
        );
    }
}
</code></pre><p>We need to define <code>FuncCall</code>:</p><pre><code class=language-rust>use super::Expr;

#[derive(Debug, Clone, PartialEq)]
pub(crate) struct FuncCall {
    pub(crate) callee: String,
    pub(crate) params: Vec&lt;Expr&gt;,
}
</code></pre><p>We also have to define <code>FuncCall::new</code>. Let’s do the simplest thing that could make the test pass, short of hardcoding the output:</p><pre><code class=language-rust>use crate::utils;

// snip

impl FuncCall {
    pub(super) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, callee) = utils::extract_ident(s)?;

        Ok((
            s,
            Self {
                callee: callee.to_string(),
                params: Vec::new(),
            },
        ))
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
warning: associated function is never used: `get_func`
  --&gt; crates/eldiro/src/env.rs:33:19
   |
33 |     pub(crate) fn get_func(&amp;self, name: &amp;str) -&gt; Result&lt;(Vec&lt;String&gt;, Stmt), String&gt; {
   |                   ^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: associated function is never used: `into_func`
  --&gt; crates/eldiro/src/env.rs:62:8
   |
62 |     fn into_func(self) -&gt; Option&lt;(Vec&lt;String&gt;, Stmt)&gt; {
   |        ^^^^^^^^^

warning: associated function is never used: `new`
  --&gt; crates/eldiro/src/expr/func_call.rs:11:19
   |
11 |     pub(super) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
   |                   ^^^

warning: associated function is never used: `get_func`
  --&gt; crates/eldiro/src/env.rs:33:19
   |
33 |     pub(crate) fn get_func(&amp;self, name: &amp;str) -&gt; Result&lt;(Vec&lt;String&gt;, Stmt), String&gt; {
   |                   ^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: associated function is never used: `into_func`
  --&gt; crates/eldiro/src/env.rs:62:8
   |
62 |     fn into_func(self) -&gt; Option&lt;(Vec&lt;String&gt;, Stmt)&gt; {
   |        ^^^^^^^^^

warning: 3 warnings emitted

warning: 2 warnings emitted


running 53 tests
....................F................................
failures:

---- expr::func_call::tests::parse_func_call_with_no_params stdout ----
thread 'expr::func_call::tests::parse_func_call_with_no_params' panicked at 'assertion failed: `(left == right)`
  left: `Ok((&quot;_user&quot;, FuncCall { callee: &quot;greet&quot;, params: [] }))`,
 right: `Ok((&quot;&quot;, FuncCall { callee: &quot;greet_user&quot;, params: [] }))`', crates/eldiro/src/expr/func_call.rs:30:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    expr::func_call::tests::parse_func_call_with_no_params

test result: FAILED. 52 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Whoa, that’s a lot of warnings! That must be because we haven’t used <code>FuncCall</code> anywhere. A function call is a kind of expression, so we should show that in the code:</p><pre><code class=language-rust>// expr.rs

mod binding_usage;
mod block;
mod func_call;

pub(crate) use binding_usage::BindingUsage;
pub(crate) use block::Block;
pub(crate) use func_call::FuncCall;

// snip

#[derive(Debug, Clone, PartialEq)]
pub(crate) enum Expr {
    Number(Number),
    Operation {
        lhs: Box&lt;Self&gt;,
        rhs: Box&lt;Self&gt;,
        op: Op,
    },
    FuncCall(FuncCall),
    BindingUsage(BindingUsage),
    Block(Block),
}

impl Expr {
    // snip

    fn new_non_operation(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        Self::new_number(s)
            .or_else(|_| FuncCall::new(s).map(|(s, func_call)| (s, Self::FuncCall(func_call))))
            .or_else(|_| {
                BindingUsage::new(s)
                    .map(|(s, binding_usage)| (s, Self::BindingUsage(binding_usage)))
            })
            .or_else(|_| Block::new(s).map(|(s, block)| (s, Self::Block(block))))
    }

    // snip
}
</code></pre><p>Let’s write a test to make sure that this works:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_func_call() {
        assert_eq!(
            Expr::new(&quot;add 1 2&quot;),
            Ok((
                &quot;&quot;,
                Expr::FuncCall(FuncCall {
                    callee: &quot;add&quot;.to_string(),
                    params: vec![Expr::Number(Number(1)), Expr::Number(Number(2))],
                }),
            )),
        );
    }

    // snip
}
</code></pre><p>Our project isn’t compiling, which means we can’t run our tests. We have to add a case to <code>Expr::eval</code> for <code>Expr::FuncCall</code>. For now, we can use the <code>todo!()</code> macro so we can move on:</p><pre><code class=language-rust>impl Expr {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        match self {
            Self::Number(Number(n)) =&gt; Ok(Val::Number(*n)),
            Self::Operation { lhs, rhs, op } =&gt; {
                // snip
            }
            Self::FuncCall(_) =&gt; todo!(), // here
            Self::BindingUsage(binding_usage) =&gt; binding_usage.eval(env),
            Self::Block(block) =&gt; block.eval(env),
        }
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
warning: associated function is never used: `get_func`
  --&gt; crates/eldiro/src/env.rs:33:19
   |
33 |     pub(crate) fn get_func(&amp;self, name: &amp;str) -&gt; Result&lt;(Vec&lt;String&gt;, Stmt), String&gt; {
   |                   ^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: associated function is never used: `into_func`
  --&gt; crates/eldiro/src/env.rs:62:8
   |
62 |     fn into_func(self) -&gt; Option&lt;(Vec&lt;String&gt;, Stmt)&gt; {
   |        ^^^^^^^^^

warning: associated function is never used: `get_func`
  --&gt; crates/eldiro/src/env.rs:33:19
   |
33 |     pub(crate) fn get_func(&amp;self, name: &amp;str) -&gt; Result&lt;(Vec&lt;String&gt;, Stmt), String&gt; {
   |                   ^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: associated function is never used: `into_func`
  --&gt; crates/eldiro/src/env.rs:62:8
   |
62 |     fn into_func(self) -&gt; Option&lt;(Vec&lt;String&gt;, Stmt)&gt; {
   |        ^^^^^^^^^

warning: 2 warnings emitted

warning: 2 warnings emitted


running 54 tests
......................FFF...F.....F.......F...........
failures:

---- expr::func_call::tests::parse_func_call_with_no_params stdout ----
thread 'expr::func_call::tests::parse_func_call_with_no_params' panicked at 'assertion failed: `(left == right)`
  left: `Ok((&quot;_user&quot;, FuncCall { callee: &quot;greet&quot;, params: [] }))`,
 right: `Ok((&quot;&quot;, FuncCall { callee: &quot;greet_user&quot;, params: [] }))`', crates/eldiro/src/expr/func_call.rs:30:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

---- expr::block::tests::parse_block_with_multiple_stmts stdout ----
thread 'expr::block::tests::parse_block_with_multiple_stmts' panicked at 'assertion failed: `(left == right)`
  left: `Ok((&quot;&quot;, Block { stmts: [BindingDef(BindingDef { name: &quot;a&quot;, val: Number(Number(10)) }), BindingDef(BindingDef { name: &quot;b&quot;, val: FuncCall(FuncCall { callee: &quot;a&quot;, params: [] }) }), Expr(FuncCall(FuncCall { callee: &quot;b&quot;, params: [] }))] }))`,
 right: `Ok((&quot;&quot;, Block { stmts: [BindingDef(BindingDef { name: &quot;a&quot;, val: Number(Number(10)) }), BindingDef(BindingDef { name: &quot;b&quot;, val: BindingUsage(BindingUsage { name: &quot;a&quot; }) }), Expr(BindingUsage(BindingUsage { name: &quot;b&quot; }))] }))`', crates/eldiro/src/expr/block.rs:72:9

---- expr::tests::parse_binding_usage stdout ----
thread 'expr::tests::parse_binding_usage' panicked at 'assertion failed: `(left == right)`
  left: `Ok((&quot;&quot;, FuncCall(FuncCall { callee: &quot;bar&quot;, params: [] })))`,
 right: `Ok((&quot;&quot;, BindingUsage(BindingUsage { name: &quot;bar&quot; })))`', crates/eldiro/src/expr.rs:201:9

---- expr::tests::parse_func_call stdout ----
thread 'expr::tests::parse_func_call' panicked at 'assertion failed: `(left == right)`
  left: `Ok((&quot; 1 2&quot;, FuncCall(FuncCall { callee: &quot;add&quot;, params: [] })))`,
 right: `Ok((&quot;&quot;, FuncCall(FuncCall { callee: &quot;add&quot;, params: [Number(Number(1)), Number(Number(2))] })))`', crates/eldiro/src/expr.rs:187:9

---- func_def::tests::parse_func_def_with_multiple_params stdout ----
thread 'func_def::tests::parse_func_def_with_multiple_params' panicked at 'assertion failed: `(left == right)`
  left: `Ok((&quot;&quot;, FuncDef { name: &quot;add&quot;, params: [&quot;x&quot;, &quot;y&quot;], body: Expr(Operation { lhs: FuncCall(FuncCall { callee: &quot;x&quot;, params: [] }), rhs: FuncCall(FuncCall { callee: &quot;y&quot;, params: [] }), op: Add }) }))`,
 right: `Ok((&quot;&quot;, FuncDef { name: &quot;add&quot;, params: [&quot;x&quot;, &quot;y&quot;], body: Expr(Operation { lhs: BindingUsage(BindingUsage { name: &quot;x&quot; }), rhs: BindingUsage(BindingUsage { name: &quot;y&quot; }), op: Add }) }))`', crates/eldiro/src/func_def.rs:83:9

---- stmt::tests::parse_func_def stdout ----
thread 'stmt::tests::parse_func_def' panicked at 'assertion failed: `(left == right)`
  left: `Ok((&quot;&quot;, FuncDef(FuncDef { name: &quot;identity&quot;, params: [&quot;x&quot;], body: Expr(FuncCall(FuncCall { callee: &quot;x&quot;, params: [] })) })))`,
 right: `Ok((&quot;&quot;, FuncDef(FuncDef { name: &quot;identity&quot;, params: [&quot;x&quot;], body: Expr(BindingUsage(BindingUsage { name: &quot;x&quot; })) })))`', crates/eldiro/src/stmt.rs:58:9


failures:
    expr::block::tests::parse_block_with_multiple_stmts
    expr::func_call::tests::parse_func_call_with_no_params
    expr::tests::parse_binding_usage
    expr::tests::parse_func_call
    func_def::tests::parse_func_def_with_multiple_params
    stmt::tests::parse_func_def

test result: FAILED. 48 passed; 6 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>We have even more problems than before! What’s happened here is that all the binding usages in our tests are now being parsed as function calls with no parameters. Remember how I said earlier that a binding usage and a parameter-less function call are indistinguishable during parsing? That’s what we’re running into here.</p><p>We have two choices: abolish <code>BindingUsage</code> in favour of special-casing the evaluation of function calls with one parameter, or we could alternatively only parse function calls with one or more parameters. The first results in less code but is more work to change, while the second takes more code but is an easy change. Since we’re making this project just to learn at the moment, I’ll go for the easy option: only accepting function calls with one or more parameters.</p><p>We need to update our test first:</p><pre><code class=language-rust>// func_call.rs

#[cfg(test)]
mod tests {
    use super::super::Number;
    use super::*;

    #[test]
    fn parse_func_call_with_one_parameter() {
        assert_eq!(
            FuncCall::new(&quot;factorial 10&quot;),
            Ok((
                &quot;&quot;,
                FuncCall {
                    callee: &quot;factorial&quot;.to_string(),
                    params: vec![Expr::Number(Number(10))],
                },
            )),
        );
    }
}
</code></pre><p>We should adjust <code>FuncCall::new</code> so that it extracts one parameter:</p><pre><code class=language-rust>impl FuncCall {
    pub(super) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, callee) = utils::extract_ident(s)?;
        let (s, _) = utils::extract_whitespace1(s)?;

        let (s, param) = Expr::new(s)?;

        Ok((
            s,
            Self {
                callee: callee.to_string(),
                params: vec![param],
            },
        ))
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
running 54 tests
.......................F.....F........................
failures:

---- expr::block::tests::parse_block_with_multiple_stmts stdout ----
thread 'expr::block::tests::parse_block_with_multiple_stmts' panicked at 'assertion failed: `(left == right)`
  left: `Ok((&quot;&quot;, Block { stmts: [BindingDef(BindingDef { name: &quot;a&quot;, val: Number(Number(10)) }), BindingDef(BindingDef { name: &quot;b&quot;, val: FuncCall(FuncCall { callee: &quot;a&quot;, params: [BindingUsage(BindingUsage { name: &quot;b&quot; })] }) })] }))`,
 right: `Ok((&quot;&quot;, Block { stmts: [BindingDef(BindingDef { name: &quot;a&quot;, val: Number(Number(10)) }), BindingDef(BindingDef { name: &quot;b&quot;, val: BindingUsage(BindingUsage { name: &quot;a&quot; }) }), Expr(BindingUsage(BindingUsage { name: &quot;b&quot; }))] }))`', crates/eldiro/src/expr/block.rs:72:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

---- expr::tests::parse_func_call stdout ----
thread 'expr::tests::parse_func_call' panicked at 'assertion failed: `(left == right)`
  left: `Ok((&quot; 2&quot;, FuncCall(FuncCall { callee: &quot;add&quot;, params: [Number(Number(1))] })))`,
 right: `Ok((&quot;&quot;, FuncCall(FuncCall { callee: &quot;add&quot;, params: [Number(Number(1)), Number(Number(2))] })))`', crates/eldiro/src/expr.rs:187:9


failures:
    expr::block::tests::parse_block_with_multiple_stmts
    expr::tests::parse_func_call

test result: FAILED. 52 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>We’ll worry about the first failure later; the second one is from <code>crate::expr::tests::parse_func_call</code>. This test fails because <code>FuncCall::new</code> doesn’t accept function calls with more than one parameter. Let’s use <code>utils::sequence</code> to remedy this:</p><pre><code class=language-rust>impl FuncCall {
    pub(super) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, callee) = utils::extract_ident(s)?;
        let (s, _) = utils::extract_whitespace1(s)?;

        let (s, params) = utils::sequence(Expr::new, s)?;

        Ok((
            s,
            Self {
                callee: callee.to_string(),
                params,
            },
        ))
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
running 54 tests
.......................F............F.................
failures:

---- expr::block::tests::parse_block_with_multiple_stmts stdout ----
thread 'expr::block::tests::parse_block_with_multiple_stmts' panicked at 'assertion failed: `(left == right)`
  left: `Ok((&quot;&quot;, Block { stmts: [BindingDef(BindingDef { name: &quot;a&quot;, val: Number(Number(10)) }), BindingDef(BindingDef { name: &quot;b&quot;, val: FuncCall(FuncCall { callee: &quot;a&quot;, params: [FuncCall(FuncCall { callee: &quot;b&quot;, params: [] })] }) })] }))`,
 right: `Ok((&quot;&quot;, Block { stmts: [BindingDef(BindingDef { name: &quot;a&quot;, val: Number(Number(10)) }), BindingDef(BindingDef { name: &quot;b&quot;, val: BindingUsage(BindingUsage { name: &quot;a&quot; }) }), Expr(BindingUsage(BindingUsage { name: &quot;b&quot; }))] }))`', crates/eldiro/src/expr/block.rs:72:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

---- func_def::tests::parse_func_def_with_multiple_params stdout ----
thread 'func_def::tests::parse_func_def_with_multiple_params' panicked at 'assertion failed: `(left == right)`
  left: `Ok((&quot;&quot;, FuncDef { name: &quot;add&quot;, params: [&quot;x&quot;, &quot;y&quot;], body: Expr(Operation { lhs: FuncCall(FuncCall { callee: &quot;x&quot;, params: [] }), rhs: BindingUsage(BindingUsage { name: &quot;y&quot; }), op: Add }) }))`,
 right: `Ok((&quot;&quot;, FuncDef { name: &quot;add&quot;, params: [&quot;x&quot;, &quot;y&quot;], body: Expr(Operation { lhs: BindingUsage(BindingUsage { name: &quot;x&quot; }), rhs: BindingUsage(BindingUsage { name: &quot;y&quot; }), op: Add }) }))`', crates/eldiro/src/func_def.rs:83:9


failures:
    expr::block::tests::parse_block_with_multiple_stmts
    func_def::tests::parse_func_def_with_multiple_params

test result: FAILED. 52 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>That first test from before is still failing, and we did indeed fix <code>crate::expr::tests::parse_func_call</code>. We managed to break function definition parsing, though. Here’s the test in question:</p><pre><code class=language-rust>// func_def.rs

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_func_def_with_multiple_params() {
        assert_eq!(
            FuncDef::new(&quot;fn add x y =&gt; x + y&quot;),
            Ok((
                &quot;&quot;,
                FuncDef {
                    name: &quot;add&quot;.to_string(),
                    params: vec![&quot;x&quot;.to_string(), &quot;y&quot;.to_string()],
                    body: Box::new(Stmt::Expr(Expr::Operation {
                        lhs: Box::new(Expr::BindingUsage(BindingUsage {
                            name: &quot;x&quot;.to_string(),
                        })),
                        rhs: Box::new(Expr::BindingUsage(BindingUsage {
                            name: &quot;y&quot;.to_string(),
                        })),
                        op: Op::Add,
                    })),
                },
            )),
        );
    }
}
</code></pre><p>The <code>x</code> in <code>x + y</code> is being parsed as a function call with no parameters, rather than as a binding usage. Hmm, it must be because <code>utils::sequence</code> accepts sequences of lengths zero. A nice way of solving this is to create a wrapper around <code>sequence</code> that checks if the output is length zero, and, if it is, returns an error. First, though, we should make use of this hypothetical <code>sequence1</code> in <code>FuncCall::new</code> so we know immediately if our implementation is correct:</p><pre><code class=language-rust>// func_call.rs

impl FuncCall {
    pub(super) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, callee) = utils::extract_ident(s)?;
        let (s, _) = utils::extract_whitespace1(s)?;

        let (s, params) = utils::sequence1(Expr::new, s)?;

        Ok((
            s,
            Self {
                callee: callee.to_string(),
                params,
            },
        ))
    }
}
</code></pre><p>We can now define <code>sequence1</code>:</p><pre><code class=language-rust>// utils.rs

pub(crate) fn sequence1&lt;T&gt;(
    parser: impl Fn(&amp;str) -&gt; Result&lt;(&amp;str, T), String&gt;,
    s: &amp;str,
) -&gt; Result&lt;(&amp;str, Vec&lt;T&gt;), String&gt; {
    let (s, sequence) = sequence(parser, s)?;

    if sequence.is_empty() {
        Err(&quot;expected a sequence with more than one item&quot;.to_string())
    } else {
        Ok((s, sequence))
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
running 54 tests
........................F.............................
failures:

---- expr::block::tests::parse_block_with_multiple_stmts stdout ----
thread 'expr::block::tests::parse_block_with_multiple_stmts' panicked at 'assertion failed: `(left == right)`
  left: `Ok((&quot;&quot;, Block { stmts: [BindingDef(BindingDef { name: &quot;a&quot;, val: Number(Number(10)) }), BindingDef(BindingDef { name: &quot;b&quot;, val: FuncCall(FuncCall { callee: &quot;a&quot;, params: [BindingUsage(BindingUsage { name: &quot;b&quot; })] }) })] }))`,
 right: `Ok((&quot;&quot;, Block { stmts: [BindingDef(BindingDef { name: &quot;a&quot;, val: Number(Number(10)) }), BindingDef(BindingDef { name: &quot;b&quot;, val: BindingUsage(BindingUsage { name: &quot;a&quot; }) }), Expr(BindingUsage(BindingUsage { name: &quot;b&quot; }))] }))`', crates/eldiro/src/expr/block.rs:72:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    expr::block::tests::parse_block_with_multiple_stmts

test result: FAILED. 53 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Here’s <code>parse_block_with_multiple_stmts</code>:</p><pre><code class=language-rust>// block.rs

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_block_with_multiple_stmts() {
        assert_eq!(
            Block::new(
                &quot;{
    let a = 10
    let b = a
    b
}&quot;,
            ),
            Ok((
                &quot;&quot;,
                Block {
                    stmts: vec![
                        Stmt::BindingDef(BindingDef {
                            name: &quot;a&quot;.to_string(),
                            val: Expr::Number(Number(10)),
                        }),
                        Stmt::BindingDef(BindingDef {
                            name: &quot;b&quot;.to_string(),
                            val: Expr::BindingUsage(BindingUsage {
                                name: &quot;a&quot;.to_string(),
                            }),
                        }),
                        Stmt::Expr(Expr::BindingUsage(BindingUsage {
                            name: &quot;b&quot;.to_string(),
                        })),
                    ],
                },
            )),
        );
    }

    // snip
}
</code></pre><p>The</p><pre><code>a
b
</code></pre><p>in</p><pre><code>let b = a
b
</code></pre><p>is being parsed as a function call, rather than two separate entities (the first of these is the right-hand side of the binding definition, and the other is the final return value of the block). This is happening because <code>utils::sequence</code> (and by extension <code>utils::sequence1</code>) use <code>utils::extract_whitespace</code> internally, which consumes both spaces and newlines. Let’s create a separate <code>utils::extract_non_newline_whitespace</code>, and also allow for a custom separator in <code>utils::sequence</code> and <code>utils::sequence1</code>. That function name is a bit ridiculous though, and it will likely only be used once. Because of this I think it makes more sense to just pass in the function as a one-time closure to <code>utils::sequence1</code> in <code>FuncCall::new</code>.</p><p>Let’s make <code>utils::sequence</code> and <code>utils::sequence1</code> accept a custom separator first:</p><pre><code class=language-rust>// utils.rs

pub(crate) fn sequence&lt;T&gt;(
    parser: impl Fn(&amp;str) -&gt; Result&lt;(&amp;str, T), String&gt;,
    separator_parser: impl Fn(&amp;str) -&gt; (&amp;str, &amp;str),
    mut s: &amp;str,
) -&gt; Result&lt;(&amp;str, Vec&lt;T&gt;), String&gt; {
    let mut items = Vec::new();

    while let Ok((new_s, item)) = parser(s) {
        s = new_s;
        items.push(item);

        let (new_s, _) = separator_parser(s);
        s = new_s;
    }

    Ok((s, items))
}

pub(crate) fn sequence1&lt;T&gt;(
    parser: impl Fn(&amp;str) -&gt; Result&lt;(&amp;str, T), String&gt;,
    separator_parser: impl Fn(&amp;str) -&gt; (&amp;str, &amp;str),
    s: &amp;str,
) -&gt; Result&lt;(&amp;str, Vec&lt;T&gt;), String&gt; {
    let (s, sequence) = sequence(parser, separator_parser, s)?;

    if sequence.is_empty() {
        Err(&quot;expected a sequence with more than one item&quot;.to_string())
    } else {
        Ok((s, sequence))
    }
}
</code></pre><p>We now need to update all the usages of <code>utils::sequence</code> and <code>utils::sequence1</code> to pass in the separators they use:</p><pre><code class=language-rust>// block.rs

impl Block {
    pub(super) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;{&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, stmts) = utils::sequence(Stmt::new, utils::extract_whitespace, s)?;

        let (s, _) = utils::extract_whitespace(s);
        let s = utils::tag(&quot;}&quot;, s)?;

        Ok((s, Block { stmts }))
    }

    // snip
}
</code></pre><pre><code class=language-rust>// func_def.rs

impl FuncDef {
    pub(crate) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;fn&quot;, s)?;
        let (s, _) = utils::extract_whitespace1(s)?;

        let (s, name) = utils::extract_ident(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, params) = utils::sequence(
            |s| utils::extract_ident(s).map(|(s, ident)| (s, ident.to_string())),
            utils::extract_whitespace,
            s,
        )?;

        let s = utils::tag(&quot;=&gt;&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, body) = Stmt::new(s)?;

        Ok((
            s,
            Self {
                name: name.to_string(),
                params,
                body: Box::new(body),
            },
        ))
    }

    // snip
}
</code></pre><p>And now finally <code>FuncCall::new</code>, where we pass in a closure that accepts <em>only spaces,</em> not newlines. Let’s also adjust the extraction of whitespace after parsing out the callee so that it stays consistent:</p><pre><code class=language-rust>// func_call.rs

impl FuncCall {
    pub(super) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, callee) = utils::extract_ident(s)?;
        let (s, _) = utils::take_while(|c| c == ' ', s);

        let (s, params) = utils::sequence1(Expr::new, |s| utils::take_while(|c| c == ' ', s), s)?;

        Ok((
            s,
            Self {
                callee: callee.to_string(),
                params,
            },
        ))
    }
}
</code></pre><p>We’re using the same <code>take_while</code> function we used for <code>extract_whitespace</code>. The only thing left is to make <code>take_while</code> <code>pub(crate)</code> so that the <code>crate::expr::func_call</code> module can use it:</p><pre><code class=language-rust>// utils.rs

pub(crate) fn take_while(accept: impl Fn(char) -&gt; bool, s: &amp;str) -&gt; (&amp;str, &amp;str) {
    let extracted_end = s
        .char_indices()
        .find_map(|(idx, c)| if accept(c) { None } else { Some(idx) })
        .unwrap_or_else(|| s.len());

    let extracted = &amp;s[..extracted_end];
    let remainder = &amp;s[extracted_end..];
    (remainder, extracted)
}
</code></pre><pre><code class=language-->$ cargo t -q
running 54 tests
......................................................
test result: ok. 54 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><h1 id=evaluation>Evaluation</h1><p>Let’s start with a test:</p><pre><code class=language-rust>// expr.rs

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_func_call() {
        let mut env = Env::default();

        env.store_func(
            &quot;add&quot;.to_string(),
            vec![&quot;x&quot;.to_string(), &quot;y&quot;.to_string()],
            Stmt::Expr(Expr::Operation {
                lhs: Box::new(Expr::BindingUsage(BindingUsage {
                    name: &quot;x&quot;.to_string(),
                })),
                rhs: Box::new(Expr::BindingUsage(BindingUsage {
                    name: &quot;y&quot;.to_string(),
                })),
                op: Op::Add,
            }),
        );

        assert_eq!(
            Expr::FuncCall(FuncCall {
                callee: &quot;add&quot;.to_string(),
                params: vec![Expr::Number(Number(2)), Expr::Number(Number(2))],
            })
            .eval(&amp;env),
            Ok(Val::Number(4)),
        );
    }

    // snip
}
</code></pre><p>We declare a function with the name <code>add</code> that takes two parameters, <code>x</code> and <code>y</code>, and has a body consisting of the addition of <code>x</code> and <code>y</code>. We then evaluate a call to <code>add</code> with the parameters <code>2</code> and <code>2</code>, expecting that the result will be <code>4</code>. Running this test panics due to the <code>todo!()</code> in <code>Expr::eval</code> that we added earlier. Let’s remove that, instead delegating to an as-yet unimplemented method on <code>FuncCall</code>:</p><pre><code class=language-rust>impl Expr {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        match self {
            Self::Number(Number(n)) =&gt; Ok(Val::Number(*n)),
            Self::Operation { lhs, rhs, op } =&gt; {
                // snip
            }
            Self::FuncCall(func_call) =&gt; func_call.eval(env),
            Self::BindingUsage(binding_usage) =&gt; binding_usage.eval(env),
            Self::Block(block) =&gt; block.eval(env),
        }
    }
}
</code></pre><p>How do you even evaluate a function call? The approach we’ll use is to create a new child environment from the environment being passed in, and add bindings for each of the parameters of the function call. After doing that we can evaluate the body of the function being called, knowing that the parameters used in the body are in the environment:</p><pre><code class=language-rust>// func_call.rs

impl FuncCall {
    // snip

    pub(super) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        let mut child_env = env.create_child();

        let (param_names, body) = env.get_func(&amp;self.callee).unwrap();

        for (param_name, param_expr) in param_names.into_iter().zip(&amp;self.params) {
            let param_val = param_expr.eval(&amp;child_env)?;
            child_env.store_binding(param_name, param_val);
        }

        body.eval(&amp;mut child_env)
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
running 55 tests
.......................................................
test result: ok. 55 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Great! Let’s add another test to make sure we haven’t made any mistakes:</p><pre><code class=language-rust>// still in func_call.rs

#[cfg(test)]
mod tests {
    use super::super::{BindingUsage, Number};
    use super::*;
    use crate::stmt::Stmt;

    // snip

    #[test]
    fn eval_func_call() {
        let mut env = Env::default();

        env.store_func(
            &quot;id&quot;.to_string(),
            vec![&quot;x&quot;.to_string()],
            Stmt::Expr(Expr::BindingUsage(BindingUsage {
                name: &quot;x&quot;.to_string(),
            })),
        );

        assert_eq!(
            FuncCall {
                callee: &quot;id&quot;.to_string(),
                params: vec![Expr::Number(Number(10))],
            }
            .eval(&amp;env),
            Ok(Val::Number(10)),
        );
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
running 56 tests
........................................................
test result: ok. 56 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>There’s something missing, though: error handling. There are three possible errors that can occur only when evaluating a function call:</p><ul><li>non-existent function</li><li>too few parameters</li><li>too many parameters</li></ul><p>First, we’ll add a test for the case where the function being called doesn’t exist:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_non_existent_func_call() {
        let env = Env::default();

        assert_eq!(
            FuncCall {
                callee: &quot;i_dont_exist&quot;.to_string(),
                params: vec![Expr::Number(Number(1))],
            }
            .eval(&amp;env),
            Err(&quot;function with name ‘i_dont_exist’ does not exist&quot;.to_string()),
        );
    }
}
</code></pre><p>To make this pass, we need to convert the <code>.unwrap()</code> in <code>FuncCall::eval</code> to a <code>?</code> so it forwards on the error message <code>Env</code> helpfully creates for us:</p><pre><code class=language-rust>impl FuncCall {
    // snip

    pub(super) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        let mut child_env = env.create_child();

        let (param_names, body) = env.get_func(&amp;self.callee)?;

        for (param_name, param_expr) in param_names.into_iter().zip(&amp;self.params) {
            let param_val = param_expr.eval(&amp;child_env)?;
            child_env.store_binding(param_name, param_val);
        }

        body.eval(&amp;mut child_env)
    }
}
</code></pre><p>Next up is matching the number of parameters in the function call with the function definition. Let’s write a test for each possibility:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::super::{BindingUsage, Number, Op};
    use super::*;
    use crate::stmt::Stmt;

    // snip

    #[test]
    fn eval_func_call_with_too_few_parameters() {
        let mut env = Env::default();

        env.store_func(
            &quot;mul&quot;.to_string(),
            vec![&quot;a&quot;.to_string(), &quot;b&quot;.to_string()],
            Stmt::Expr(Expr::Operation {
                lhs: Box::new(Expr::BindingUsage(BindingUsage {
                    name: &quot;a&quot;.to_string(),
                })),
                rhs: Box::new(Expr::BindingUsage(BindingUsage {
                    name: &quot;b&quot;.to_string(),
                })),
                op: Op::Mul,
            }),
        );

        assert_eq!(
            FuncCall {
                callee: &quot;mul&quot;.to_string(),
                params: vec![Expr::Number(Number(100))],
            }
            .eval(&amp;env),
            Err(&quot;expected 2 parameters, got 1&quot;.to_string()),
        );
    }

    #[test]
    fn eval_func_call_with_too_many_parameters() {
        let mut env = Env::default();

        env.store_func(
            &quot;square&quot;.to_string(),
            vec![&quot;n&quot;.to_string()],
            Stmt::Expr(Expr::Operation {
                lhs: Box::new(Expr::BindingUsage(BindingUsage {
                    name: &quot;n&quot;.to_string(),
                })),
                rhs: Box::new(Expr::BindingUsage(BindingUsage {
                    name: &quot;n&quot;.to_string(),
                })),
                op: Op::Mul,
            }),
        );

        assert_eq!(
            FuncCall {
                callee: &quot;square&quot;.to_string(),
                params: vec![Expr::Number(Number(5)), Expr::Number(Number(42))],
            }
            .eval(&amp;env),
            Err(&quot;expected 1 parameters, got 2&quot;.to_string()),
        );
    }
}
</code></pre><p>The code may not be pretty, but I guess it gets the job done. Here’s how we can make those two tests pass:</p><pre><code class=language-rust>impl FuncCall {
    // snip

    pub(super) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        let mut child_env = env.create_child();

        let (param_names, body) = env.get_func(&amp;self.callee)?;

        let num_expected_params = param_names.len();
        let num_actual_params = self.params.len();

        if num_expected_params != num_actual_params {
            return Err(format!(
                &quot;expected {} parameters, got {}&quot;,
                num_expected_params, num_actual_params,
            ));
        }

        for (param_name, param_expr) in param_names.into_iter().zip(&amp;self.params) {
            let param_val = param_expr.eval(&amp;child_env)?;
            child_env.store_binding(param_name, param_val);
        }

        body.eval(&amp;mut child_env)
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
running 59 tests
...........................................................
test result: ok. 59 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>We still haven’t implemented function calls with no parameters, though. Eldiro doesn’t currently have side effects of any kind, so we can’t test whether a parameter-less function call has taken place. Regardless, let’s implement the feature:</p><pre><code class=language-rust>// binding_usage.rs

impl BindingUsage {
    // snip

    pub(super) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        env.get_binding(&amp;self.name).or_else(|error_msg| {
            if env.get_func(&amp;self.name).is_ok() {
                FuncCall {
                    callee: self.name.clone(),
                    params: Vec::new(),
                }
                .eval(env)
            } else {
                Err(error_msg)
            }
        })
    }
}
</code></pre><p>What this is doing is first trying to obtain the binding usage just as we would do normally; however, if it cannot be found, the error message is saved, and, if the environment contains a function with the same name as the binding usage, the corresponding function call is constructed and evaluated. If this function doesn’t exist, then the error message from the binding usage is used. This prevents using a non-existent binding and getting an error message about a non-existent function instead.</p><p>Let’s run our test suite to see if we’ve broken anything in the process:</p><pre><code class=language-->$ cargo t -q
running 59 tests
...........................................................
test result: ok. 59 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>And with that, this part is done. Good job on getting this far. If you like, you can stop here, and keep adding features to your implementation of Eldiro. If you want to continue following this series, read on.</p><h1 id=problems-with-the-current-implementation>Problems with the current implementation</h1><p>The implementation of Eldiro we have been writing together has a number of problems that have either arisen due to</p><ul><li>my unwillingness to refactor throughout the series (why waste readers’ time doing menial refactoring when you could be explaining interesting topics?)</li><li>a lack of planning, or</li><li>the ‘worse’ way being easier to understand and teach</li></ul><p>Here’s a list of everything ‘wrong’ with it at the moment:</p><ul><li>Parsing something requires going through all the options until one that parses successfully is found. This is slower than looking at the input and determining which option the input is representing (this is called <em>predictive parsing</em>), since the same part of the input is examined multiple times.</li><li><code>crate::expr::Number</code> and <code>crate::expr::BindingDef</code> should be ‘inlined’ into <code>Expr</code>’s definition rather than in their own structures, since their implementations are so short that making them separate results in too much boilerplate for the separation to be worth the trouble. <code>Expr::new_number</code> could similarly be inlined into <code>Expr::new_non_operation</code>, which also makes it more consistent with how all the other non-<code>Operation</code> variants of <code>Expr</code> are parsed.</li><li>Error messages don’t have location information.</li><li>Parsing stops at the first error, rather than recovering and attempting to parse as much out of the input as possible.</li><li>Operations can’t be nested (for example, <code>6 + 2 * 3</code> doesn’t parse).</li><li>Error messages are strings, rather than proper structured data.</li></ul><p>The basic architecture that Eldiro is currently using is flawed &ndash; by working with the underlying text directly, it forces the language to re-examine the input again and again during parsing. This also makes it more difficult to recover from errors. Furthermore, if we ever want to implement static analysis (analysing code without running it; for example, a squiggly underline for an undefined binding in an editor), we need to be able to represent incomplete code. Take <code>BindingDef</code> as an example. In its current form, both a name and a value <em>have</em> to be present:</p><pre><code class=language-rust>#[derive(Debug, Clone, PartialEq)]
pub(crate) struct BindingDef {
    pub(crate) name: String,
    pub(crate) val: Expr,
}
</code></pre><p>Let’s say we’re in the middle of typing <code>let a =</code> in the editor &ndash; how is our hypothetical static analysis tooling meant to represent that code internally? It isn’t possible with our current architecture. And no, wrapping all the fields of our data structures in <code>Option</code>s isn’t feasible, either. Moreover, to display squigglies (and to have remotely helpful error messages) we need to store location information, which is tedious. Imagine having to add a field <code>span</code> to every single data structure!</p><p>The solution to some of these problems is to use <a href=https://github.com/rust-analyzer/rowan>Rowan</a>, a library that lets us represent incomplete code. In fact, it represents <em>all text</em> losslessly, which makes it well-suited to tooling that runs in a user’s editor. <a href=https://github.com/rust-analyzer/rust-analyzer>rust-analyzer</a> <a href=https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/syntax.md>uses Rowan</a> internally, which is based on <a href=https://github.com/dotnet/roslyn>Roslyn</a> and <a href=https://github.com/apple/swift/tree/main/lib/Syntax>lib/Syntax</a> from Swift.</p><p>Using Rowan mandates that we use a <em>lexer,</em> which is a program that takes a string as an input and slices it up into little pieces &ndash; here’s an example relevant to Eldiro:</p><pre><code>fn add x y =&gt; x + y
let result = add 5 5
</code></pre><p>might be <em>lexed,</em> or <em>tokenised,</em> as</p><pre><code>FnKw (&quot;fn&quot;)
Ident (&quot;add&quot;)
Ident (&quot;x&quot;)
Ident (&quot;y&quot;)
FatArrow (&quot;=&gt;&quot;)
Ident (&quot;x&quot;)
Plus (&quot;+&quot;)
Ident (&quot;y&quot;)
Eol (&quot;\n&quot;)
LetKw (&quot;let&quot;)
Ident (&quot;result&quot;)
Equals (&quot;=&quot;)
Ident (&quot;add&quot;)
Number (&quot;5&quot;)
Number (&quot;5&quot;)
</code></pre><p>Note how, unlike the structured output of a parser, the output of the lexer is flat. Note also how all whitespace (apart from the newline) has been removed from the output. This is the traditional choice, as most languages don’t have to worry about whitespace. In our case, though, we want to represent the input fully so editor features that work closely with the text (such as automatic refactoring and ‘expand selection’) is easier. As such, our lexer will include all whitespace.</p><p>The next part of this series will be the start of a rewrite: we’ll begin by <em>wiping the project clean,</em><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> and go on to write a lexer and an <a href=https://rust-analyzer.github.io/blog/2020/09/16/challeging-LR-parsing.html#error-resilience>error-resilient</a> parser for fully nested mathematical expressions, complete with good error messages. No more rewrites or sloppy code. We’re doing this <em>for real.</em></p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>I know full rewrites are inadvisable, but from what little we’ve written (by my count Eldiro contains 1,219 source lines at this point) there is barely anything salvageable. Maybe <code>Val</code>, and the basic structure of the REPL? That’s easy enough to rewrite later, though.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></main><nav class=page-navigation><div class=prev><p class=hint>Previously</p><a href=https://arzg.github.io/lang/8/>Part Eight: Function Definitions</a></div><div class=next><p class=hint>Next up</p><a href=https://arzg.github.io/lang/10/>Part Ten: Starting Again</a></div><div style=clear:both></div></nav></body></html>