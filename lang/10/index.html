<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Part Ten: Starting Again · arzg’s website</title><link rel=stylesheet href=https://arzg.github.io/scss/main.daeb6da9853d538dea987a5610fce5841be60fa0c1d0d52767dca3ed6354bb69.css integrity="sha256-2uttqYU9U43qmHpWEPzlhBvmD6DB0NUnZ9yj7WNUu2k="><script src=https://unpkg.com/quicklink@2.0.0/dist/quicklink.umd.js></script><script>window.onload=()=>{quicklink.listen();};</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body><nav class=page-nav><ul><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li class=current><a href=/lang/>Make A Language</a></li></ul></nav><header><h1>Part Ten: Starting Again</h1><subtitle><ul><li>15 November 2020</li><li>4050 words</li><li>20 minute read</li></ul></subtitle></header><main><p>In Part Nine <a href=/lang/9/#problems-with-the-current-implementation>I described</a> the reasons for switching to <a href=https://github.com/rust-analyzer/rowan>Rowan</a> and a lexer over the current lexerless parsing system we’ve developed in <code>crate::utils</code>. Read that before reading on here.</p><h1 id=wiping-the-project>Wiping the project</h1><p>Sadly, the moment has arrived. It’s time to delete what we’ve created, since almost none of it will be reusable.</p><pre><code class=language-- data-lang=->$ rm -r crates/{eldiro,eldiro-cli}/src
</code></pre><p>Let’s add in placeholder files so everything still compiles:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// crates/eldiro/src/lib.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>it_works</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=mi>2</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// crates/eldiro-cli/src/main.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Hello, world!&#34;</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h1 id=a-lexer>A lexer</h1><p>To write our lexer, we’ll use the <a href=https://github.com/maciejhirsz/logos/>Logos</a> crate. This will generate a lexer for us that’s <a href=https://github.com/maciejhirsz/logos/blob/73d518c1d248599cad82c36ff34d6c0b41850ed2/README.md#how-fast>really fast</a> (according to the project README) without much effort on our part. Let’s start by adding Logos as a dependency to <code>eldiro</code>:</p><div class=highlight><pre class=chroma><code class=language-toml data-lang=toml><span class=c># crates/eldiro/Cargo.toml</span>

<span class=c># snip</span>

<span class=p>[</span><span class=nx>dependencies</span><span class=p>]</span>
<span class=nx>logos</span> <span class=p>=</span> <span class=s2>&#34;0.11.4&#34;</span>
</code></pre></div><p>Let’s also create a module for our lexer to live in:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// crates/eldiro/src/lib.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>lexer</span><span class=p>;</span><span class=w>
</span></code></pre></div><p>We can now open <code>src/lexer.rs</code> and start writing our lexer. The first thing we need to declare is an enum that will represent the types of <em>tokens</em> our lexer can, well, <em>lex.</em> Why don’t we start with something easy &ndash; whitespace, maybe?</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>enum</span> <span class=nc>Token</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Whitespace</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>What if we encounter a piece of text that doesn’t match any token? We need a variant for that, too:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>enum</span> <span class=nc>Token</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Whitespace</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>Error</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>When I first learnt about this I thought it was incredibly perverse. Why let every single token in your implementation be an error when you could instead represent this in a much cleaner way using <code>Result</code>? Remember, though, that our parser has to be lossless, meaning that it must represent the input flawlessly and <em>always</em> return an output, no matter how malformed the input is.</p><h1 id=a-quick-aside-about-rowan>A quick aside about Rowan</h1><p>Rowan manages to represent both an arbitrary input, as well as an arbitrary parser output. How does it do this? Here’s a code sketch slightly modified from the <a href=https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/syntax.md>rust-analyzer docs</a>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(PartialEq, Eq, Clone, Copy)]</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>SyntaxKind</span><span class=p>(</span><span class=kt>u16</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(PartialEq, Eq, Clone)]</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>SyntaxNode</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>kind</span>: <span class=nc>SyntaxKind</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>children</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>Arc</span><span class=o>&lt;</span><span class=n>SyntaxElement</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(PartialEq, Eq, Clone)]</span><span class=w>
</span><span class=w></span><span class=k>enum</span> <span class=nc>SyntaxElement</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Node</span><span class=p>(</span><span class=n>SyntaxNode</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=n>Token</span><span class=p>(</span><span class=n>SyntaxToken</span><span class=p>),</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(PartialEq, Eq, Clone)]</span><span class=w>
</span><span class=w></span><span class=k>struct</span> <span class=nc>SyntaxToken</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>kind</span>: <span class=nc>SyntaxKind</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>text</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Confusingly, <code>SyntaxKind</code> here is our own <code>Token</code> cast to a <code>u16</code>, while <code>SyntaxToken</code> is unrelated. To keep ourselves from getting confused when we use Rowan later, we’ll rename our <code>Token</code> to <code>SyntaxKind</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>enum</span> <span class=nc>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Whitespace</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>Error</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>One of the key elements of the Rowan tree structure is that trees are <em>deduplicated,</em> i.e. if you construct two identical trees in your parser, only one copy is ever stored in memory, reducing memory usage.</p><p>Although it isn’t visible here, Rowan gives you access to parents and siblings if you have a <code>SyntaxNode</code>, <code>SyntaxToken</code> or <code>SyntaxElement</code>. This is especially convenient for writing, say, <a href=https://github.com/RDambrosio016/RSLint>a linter with Rowan</a>.</p><h1 id=back-to-the-lexer>Back to the lexer</h1><p>Let’s actually make the lexer lex text. This is where Logos comes into play. Here’s our first test:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>enum</span> <span class=nc>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Whitespace</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>Error</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_spaces</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>lexer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>lexer</span><span class=p>(</span><span class=s>&#34;   &#34;</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>lexer</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Whitespace</span><span class=p>));</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>lexer</span><span class=p>.</span><span class=n>slice</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;   &#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Here we’re creating our lexer from the input we want to test, and then verify that the lexer has determined that the input starts with whitespace. We make sure that the entirety of the input has been classified as whitespace by checking that the text of the current <em>lexeme</em> (you can think of a lexeme as a <code>(SyntaxKind, &str)</code>) is equal to the original input.</p><p>For now, let’s define whitespace to be a series of one or more spaces, which can be represented by the regex <code>/ +/</code>. Here’s how we tell this to Logos:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>logos</span>::<span class=n>Logos</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Debug, Copy, Clone, PartialEq, Logos)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>enum</span> <span class=nc>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=cp>#[regex(</span><span class=s>&#34; +&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>Whitespace</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[error]</span><span class=w>
</span><span class=w>    </span><span class=n>Error</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><pre><code class=language-- data-lang=->$ cargo t -q
running 1 test
.
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Let’s also lex the <code>fn</code> keyword, used in function definitions. A test first:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_fn_keyword</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>lexer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>lexer</span><span class=p>(</span><span class=s>&#34;fn&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>lexer</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>FnKw</span><span class=p>));</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>lexer</span><span class=p>.</span><span class=n>slice</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;fn&#34;</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Let’s now write the needed implementation:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(Debug, Copy, Clone, PartialEq, Logos)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>enum</span> <span class=nc>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=cp>#[regex(</span><span class=s>&#34; +&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>Whitespace</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[token(</span><span class=s>&#34;fn&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>FnKw</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[error]</span><span class=w>
</span><span class=w>    </span><span class=n>Error</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><pre><code class=language-- data-lang=->$ cargo t -q
running 2 tests
..
test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>That test code is getting repetitive though. Let’s extract the common parts into a helper function:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>check</span><span class=p>(</span><span class=n>input</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>kind</span>: <span class=nc>SyntaxKind</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>lexer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>lexer</span><span class=p>(</span><span class=n>input</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>lexer</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>kind</span><span class=p>));</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>lexer</span><span class=p>.</span><span class=n>slice</span><span class=p>(),</span><span class=w> </span><span class=n>input</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_spaces</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;   &#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>Whitespace</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_fn_keyword</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;fn&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>FnKw</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><pre><code class=language-- data-lang=->$ cargo t -q
running 2 tests
..
test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>We can now zoom through lexing all the remaining lexical constructs:</p><ul><li>the <code>let</code> keyword</li><li>identifiers (start with a letter, followed by letters or numbers)</li><li>numbers</li><li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>=</code>, <code>{</code>, <code>}</code></li></ul><p>Here’s the file in its entirety:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>logos</span>::<span class=n>Logos</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Debug, Copy, Clone, PartialEq, Logos)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>enum</span> <span class=nc>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=cp>#[regex(</span><span class=s>&#34; +&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>Whitespace</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[token(</span><span class=s>&#34;fn&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>FnKw</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[token(</span><span class=s>&#34;let&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>LetKw</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[regex(</span><span class=s>&#34;[A-Za-z][A-Za-z0-9]+&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>Ident</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[regex(</span><span class=s>&#34;[0-9]+&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>Number</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[token(</span><span class=s>&#34;+&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>Plus</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[token(</span><span class=s>&#34;-&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>Minus</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[token(</span><span class=s>&#34;*&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>Star</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[token(</span><span class=s>&#34;/&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>Slash</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[token(</span><span class=s>&#34;=&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>Equals</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[token(</span><span class=s>&#34;{&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>LBrace</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[token(</span><span class=s>&#34;}&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>RBrace</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[error]</span><span class=w>
</span><span class=w>    </span><span class=n>Error</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>check</span><span class=p>(</span><span class=n>input</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>kind</span>: <span class=nc>SyntaxKind</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>lexer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>lexer</span><span class=p>(</span><span class=n>input</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>lexer</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>kind</span><span class=p>));</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>lexer</span><span class=p>.</span><span class=n>slice</span><span class=p>(),</span><span class=w> </span><span class=n>input</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_spaces</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;   &#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>Whitespace</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_fn_keyword</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;fn&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>FnKw</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_let_keyword</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;let&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>LetKw</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_alphabetic_identifier</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;abcd&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_alphanumeric_identifier</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;ab123cde456&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_mixed_case_identifier</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;ABCdef&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_number</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;123456&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_plus</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;+&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>Plus</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_minus</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;-&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>Minus</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_star</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;*&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>Star</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_slash</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;/&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>Slash</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_equals</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;=&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>Equals</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_left_brace</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;{&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>LBrace</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_right_brace</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>RBrace</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><pre><code class=language-- data-lang=->$ cargo t -q
running 14 tests
..............
test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><h1 id=a-parser>A parser</h1><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// lib.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>lexer</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>parser</span><span class=p>;</span><span class=w>
</span></code></pre></div><p>The first thing our parser needs to hold is a lexer generated by Logos:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// src/parser.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>lexer</span>::<span class=n>SyntaxKind</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>struct</span> <span class=nc>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>lexer</span>: <span class=nc>logos</span>::<span class=n>Lexer</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>That lifetime <code>'a</code> is needed because Logos’ lexers store the input they were created with, and pull from it as tokens are requested. An approach more common than what we’re doing is to lex the entire input upon creating the parser, but we don’t need to do that: we can lex <em>lazily</em> as we go, rather than <em>eagerly</em> all at once. This is really a micro-optimisation, but it’s so cool and easy to do, and there’s no downside (for now).</p><p>Let’s add a constructor:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>lexer</span>::<span class=n>SyntaxKind</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>logos</span>::<span class=n>Logos</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>input</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>lexer</span>: <span class=nc>SyntaxKind</span>::<span class=n>lexer</span><span class=p>(</span><span class=n>input</span><span class=p>),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>How can we construct a syntax tree, though? This is what we’re using Rowan for. Let’s add the relevant code so we can use Rowan first, and I’ll explain afterwards:</p><div class=highlight><pre class=chroma><code class=language-toml data-lang=toml><span class=c># Cargo.toml</span>

<span class=c># snip</span>

<span class=p>[</span><span class=nx>dependencies</span><span class=p>]</span>
<span class=nx>logos</span> <span class=p>=</span> <span class=s2>&#34;0.11.4&#34;</span>
<span class=nx>rowan</span> <span class=p>=</span> <span class=s2>&#34;0.10.0&#34;</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// parser.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>lexer</span>::<span class=n>SyntaxKind</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>logos</span>::<span class=n>Logos</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>rowan</span>::<span class=n>GreenNodeBuilder</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>struct</span> <span class=nc>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>lexer</span>: <span class=nc>logos</span>::<span class=n>Lexer</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>builder</span>: <span class=nc>GreenNodeBuilder</span><span class=o>&lt;</span><span class=nb>&#39;static</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>input</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>lexer</span>: <span class=nc>SyntaxKind</span>::<span class=n>lexer</span><span class=p>(</span><span class=n>input</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=n>builder</span>: <span class=nc>GreenNodeBuilder</span>::<span class=n>new</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Earlier in this post I explained the gist of Rowan’s syntax trees. Here’s how you create one: the builder remembers what branch of the tree you’re on. It exposes methods to create a new child branch with a given <code>SyntaxKind</code> and make it current, add a token to the current branch, as well as a method to finish the current branch and restore the parent branch as current. Finally, <code>GreenNodeBuilder</code> has a <code>finish</code> method, which outputs the syntax tree it has created.</p><p><code>finish</code> requires the syntax tree to contain just one root node; we can fulfil this requirement by creating all our nodes as children of a single <code>Root</code> node. Let’s add this to <code>SyntaxKind</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// lexer.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Debug, Copy, Clone, PartialEq, Logos)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>enum</span> <span class=nc>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=n>Root</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>We can now start defining a <code>parse</code> method on <code>Parser</code> that creates a <code>Root</code> node:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// parser.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>parse</span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>?</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>start_node</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Root</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>finish_node</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>What do we output from <code>Parser::parse</code>? Let’s define a new structure to hold the output of parsing:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>lexer</span>::<span class=n>SyntaxKind</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>logos</span>::<span class=n>Logos</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>rowan</span>::<span class=p>{</span><span class=n>GreenNode</span><span class=p>,</span><span class=w> </span><span class=n>GreenNodeBuilder</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>parse</span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>start_node</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Root</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>finish_node</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>green_node</span>: <span class=nc>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>finish</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>struct</span> <span class=nc>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>green_node</span>: <span class=nc>GreenNode</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>We now have an error when we’re trying to create our root node about <code>GreenNodeBuilder::start_node</code> expecting a <code>rowan::SyntaxKind</code> instead of our <code>SyntaxKind</code>. To solve this we’ll implement <code>From&lt;SyntaxKind> for rowan::SyntaxKind</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// lexer.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=nb>From</span><span class=o>&lt;</span><span class=n>SyntaxKind</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>rowan</span>::<span class=n>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>from</span><span class=p>(</span><span class=n>kind</span>: <span class=nc>SyntaxKind</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span><span class=p>(</span><span class=n>kind</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>u16</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Note how Rowan never directly interacts with our <code>SyntaxKind</code> &ndash; instead, it’s casted to a <code>u16</code> so that Rowan can work with any enum. Now that that’s done, we can add a call to <code>.into()</code> to convert our <code>SyntaxKind</code> into Rowan’s:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// parser.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>parse</span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>start_node</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Root</span><span class=p>.</span><span class=n>into</span><span class=p>());</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>finish_node</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>green_node</span>: <span class=nc>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>finish</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>So that we can write tests for our parser, we’ll need a way of displaying its output: the <code>GreenNode</code> inside of <code>Parse</code>. We can only do this by converting it to a <code>SyntaxNode</code>.</p><p>Remember how Rowan doesn’t actually store our <code>SyntaxKind</code>, instead storing its own <code>rowan::SyntaxKind</code> with our <code>SyntaxKind</code> casted to a <code>u16</code>? In order for Rowan to be able to give us our <code>SyntaxKind</code> instead of the ‘raw’ Rowan version when we, say, ask Rowan what the kind of a given node is, we need to also have our own version of <code>SyntaxNode</code> that knows how to convert between the two. Eventually we’ll also need our own <code>SyntaxElement</code> and <code>SyntaxToken</code>, but we don’t need those at the moment. The way Rowan automates the conversion is through a trait, namely <code>rowan::Language</code>.</p><h1 id=another-rabbit-hole>Another rabbit hole</h1><p>Once again, a new module is in order:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// lib.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>lexer</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>parser</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>syntax</span><span class=p>;</span><span class=w>
</span></code></pre></div><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// src/syntax.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>lexer</span>::<span class=n>SyntaxKind</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>enum</span> <span class=nc>EldiroLanguage</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>rowan</span>::<span class=n>Language</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>EldiroLanguage</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Kind</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SyntaxKind</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>kind_from_raw</span><span class=p>(</span><span class=n>raw</span>: <span class=nc>rowan</span>::<span class=n>SyntaxKind</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Kind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>todo</span><span class=o>!</span><span class=p>()</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>kind_to_raw</span><span class=p>(</span><span class=n>kind</span>: <span class=nc>Self</span>::<span class=n>Kind</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>rowan</span>::<span class=n>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>todo</span><span class=o>!</span><span class=p>()</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Converting from our <code>SyntaxKind</code> to Rowan’s is easy &ndash; we can re-use the <code>From</code> implementation from earlier:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>rowan</span>::<span class=n>Language</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>EldiroLanguage</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>kind_to_raw</span><span class=p>(</span><span class=n>kind</span>: <span class=nc>Self</span>::<span class=n>Kind</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>rowan</span>::<span class=n>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>kind</span><span class=p>.</span><span class=n>into</span><span class=p>()</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Going the other way, though, is much more difficult &ndash; we have to convert from something with 65,536 possible values (<code>u16</code>) to one with fourteen (<code>SyntaxKind</code>). We could do it the manual way:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>rowan</span>::<span class=n>Language</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>EldiroLanguage</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>kind_from_raw</span><span class=p>(</span><span class=n>raw</span>: <span class=nc>rowan</span>::<span class=n>SyntaxKind</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Kind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=n>raw</span><span class=p>.</span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=mi>0</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Self</span>::<span class=n>Kind</span>::<span class=n>Whitespace</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=mi>1</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Self</span>::<span class=n>Kind</span>::<span class=n>FnKw</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=mi>2</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Self</span>::<span class=n>Kind</span>::<span class=n>LetKw</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=mi>3</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Self</span>::<span class=n>Kind</span>::<span class=n>Ident</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=mi>4</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Self</span>::<span class=n>Kind</span>::<span class=n>Number</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=c1>// etc.
</span><span class=c1></span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>This is tedious, error prone and makes it annoying to modify <code>SyntaxKind</code> in any way. We could also use some <code>unsafe</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>rowan</span>::<span class=n>Language</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>EldiroLanguage</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>kind_from_raw</span><span class=p>(</span><span class=n>raw</span>: <span class=nc>rowan</span>::<span class=n>SyntaxKind</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Kind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert</span><span class=o>!</span><span class=p>(</span><span class=n>raw</span><span class=p>.</span><span class=mi>0</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>14</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>std</span>::<span class=n>mem</span>::<span class=n>transmute</span><span class=p>(</span><span class=n>raw</span><span class=p>)</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>This also works, but means we need to update this seemingly-magical number every time we add or remove a variant from <code>SyntaxKind</code>. rust-analyzer <a href=https://github.com/rust-analyzer/rust-analyzer/blob/7f12a1f225c7d3397f27964ce039b55d680772d3/crates/parser/src/syntax_kind/generated.rs#L250>uses</a> a hidden <code>__LAST</code> enum variant to determine how many variants their <code>SyntaxKind</code> has. Regardless, <code>std::mem::transmute</code> is about the most unsafe thing you can do, so I’d like to avoid it.</p><p>The approach we’ll use utilises a procedural macro to automate the process for us. Usually I’d hesitate before adding a procedural macro due to the compilation time overhead they incur; however, we’re already using a proc-macro &ndash; Logos &ndash; so we’re paying the cost of the procedural macro ecosystem whether we use this approach or not.</p><div class=highlight><pre class=chroma><code class=language-toml data-lang=toml><span class=c># Cargo.toml</span>

<span class=c># snip</span>

<span class=p>[</span><span class=nx>dependencies</span><span class=p>]</span>
<span class=nx>logos</span> <span class=p>=</span> <span class=s2>&#34;0.11.4&#34;</span>
<span class=nx>num</span><span class=err>-</span><span class=nx>derive</span> <span class=p>=</span> <span class=s2>&#34;0.3.3&#34;</span>
<span class=nx>num</span><span class=err>-</span><span class=nx>traits</span> <span class=p>=</span> <span class=s2>&#34;0.2.14&#34;</span>
<span class=nx>rowan</span> <span class=p>=</span> <span class=s2>&#34;0.10.0&#34;</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// lexer.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>logos</span>::<span class=n>Logos</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>num_derive</span>::<span class=p>{</span><span class=n>FromPrimitive</span><span class=p>,</span><span class=w> </span><span class=n>ToPrimitive</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Debug, Copy, Clone, PartialEq, Logos, FromPrimitive, ToPrimitive)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>enum</span> <span class=nc>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// syntax.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>lexer</span>::<span class=n>SyntaxKind</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>num_traits</span>::<span class=p>{</span><span class=n>FromPrimitive</span><span class=p>,</span><span class=w> </span><span class=n>ToPrimitive</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>rowan</span>::<span class=n>Language</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>EldiroLanguage</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Kind</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SyntaxKind</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>kind_from_raw</span><span class=p>(</span><span class=n>raw</span>: <span class=nc>rowan</span>::<span class=n>SyntaxKind</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Kind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span>::<span class=n>Kind</span>::<span class=n>from_u16</span><span class=p>(</span><span class=n>raw</span><span class=p>.</span><span class=mi>0</span><span class=p>).</span><span class=n>unwrap</span><span class=p>()</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>kind_to_raw</span><span class=p>(</span><span class=n>kind</span>: <span class=nc>Self</span>::<span class=n>Kind</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>rowan</span>::<span class=n>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>rowan</span>::<span class=n>SyntaxKind</span><span class=p>(</span><span class=n>kind</span><span class=p>.</span><span class=n>to_u16</span><span class=p>().</span><span class=n>unwrap</span><span class=p>())</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>This also means we can remove our custom <code>From&lt;SyntaxKind> for rowan::SyntaxKind</code> impl.</p><p>Now we can define our own Eldiro-specific <code>SyntaxNode</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>type</span> <span class=nc>SyntaxNode</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rowan</span>::<span class=n>SyntaxNode</span><span class=o>&lt;</span><span class=n>EldiroLanguage</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></code></pre></div><p>Finally, the last error left before we can write tests for our parser is from our usage of <code>.into()</code> in <code>Parser::parse</code>. Let’s replace that with a usage of our <code>EldiroLanguage</code>, plus some helper methods to reduce typing:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>lexer</span>::<span class=n>SyntaxKind</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>syntax</span>::<span class=n>EldiroLanguage</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>logos</span>::<span class=n>Logos</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>rowan</span>::<span class=p>{</span><span class=n>GreenNode</span><span class=p>,</span><span class=w> </span><span class=n>GreenNodeBuilder</span><span class=p>,</span><span class=w> </span><span class=n>Language</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>parse</span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>start_node</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Root</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>finish_node</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>green_node</span>: <span class=nc>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>finish</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>start_node</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>kind</span>: <span class=nc>SyntaxKind</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>start_node</span><span class=p>(</span><span class=n>EldiroLanguage</span>::<span class=n>kind_to_raw</span><span class=p>(</span><span class=n>kind</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>finish_node</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>finish_node</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h1 id=testing-our-parser>Testing our parser</h1><p>And now, finally, we can write the first test for our parser:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>syntax</span>::<span class=n>SyntaxNode</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_nothing</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>parse</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Parser</span>::<span class=n>new</span><span class=p>(</span><span class=s>&#34;&#34;</span><span class=p>).</span><span class=n>parse</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=n>format</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;{:#?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxNode</span>::<span class=n>new_root</span><span class=p>(</span><span class=n>parse</span><span class=p>.</span><span class=n>green_node</span><span class=p>)),</span><span class=w>
</span><span class=w>            </span><span class=s>r#&#34;Root@0..0
</span><span class=s>&#34;#</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Doesn’t look too good, does it? It’s long, tedious to write, and &ndash; worst of all &ndash; doesn’t provide any sort of diff if the test fails. Instead, <code>cargo t</code> will spit out the syntax tree we expected and the one we got, and it’ll be up to us to Spot The Difference. I’ve tried using <a href=https://github.com/colin-kiegel/rust-pretty-assertions>Pretty Assertions</a> for this problem in the past, and although it works well for comparing structured data, it isn’t nice to work with when you’re using strings like we are here. Instead of showing the line-by-line diff, Pretty Assertions instead shows a diff as if the syntax tree is all on one line, with the lines separated by a literal <code>\n</code>.</p><p>We’ll use <a href=https://docs.rs/expect-test/>expect-test</a> instead, which:</p><ul><li>shows line-by-line diffs properly</li><li>gives us the option to automatically update expected test results <em>en masse</em></li></ul><p>From the documentation:</p><blockquote><p>This becomes very useful when you have a lot of tests with verbose and potentially changing expected output.</p></blockquote><p>expect-test sounds perfect for this use case, and that’s no coincidence &ndash; it was made by the developers of rust-analyzer.</p><p>Let’s convert our lone test to use expect-test:</p><div class=highlight><pre class=chroma><code class=language-toml data-lang=toml><span class=c># Cargo.toml</span>

<span class=c># snip</span>

<span class=p>[</span><span class=nx>dev</span><span class=err>-</span><span class=nx>dependencies</span><span class=p>]</span>
<span class=nx>expect</span><span class=err>-</span><span class=nx>test</span> <span class=p>=</span> <span class=s2>&#34;1.0.1&#34;</span>
</code></pre></div><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// parser.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>syntax</span>::<span class=n>SyntaxNode</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=n>expect_test</span>::<span class=p>{</span><span class=n>expect</span><span class=p>,</span><span class=w> </span><span class=n>Expect</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>check</span><span class=p>(</span><span class=n>input</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>expected_tree</span>: <span class=nc>Expect</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>parse</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Parser</span>::<span class=n>new</span><span class=p>(</span><span class=n>input</span><span class=p>).</span><span class=n>parse</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>syntax_node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SyntaxNode</span>::<span class=n>new_root</span><span class=p>(</span><span class=n>parse</span><span class=p>.</span><span class=n>green_node</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>actual_tree</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>format</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;{:#?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>syntax_node</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=c1>// We cut off the last byte because formatting the SyntaxNode adds on a newline at the end.
</span><span class=c1></span><span class=w>        </span><span class=n>expected_tree</span><span class=p>.</span><span class=n>assert_eq</span><span class=p>(</span><span class=o>&amp;</span><span class=n>actual_tree</span><span class=p>[</span><span class=mi>0</span><span class=p>..</span><span class=n>actual_tree</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>]);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_nothing</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=w> </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;Root@0..0&#34;#</span><span class=p>]]);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Running our tests gives us a bunch of warnings, as well as fifteen happy little green dots:</p><pre><code class=language-- data-lang=->$ cargo -t q
running 15 tests
...............
test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><h1 id=cleaning-up-warnings>Cleaning up warnings</h1><p>Let’s make a few things that we know will need to be used by the REPL <code>pub</code> now so that some of those ‘dead code’ warnings go away:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// lib.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>mod</span> <span class=nn>parser</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>lexer</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>syntax</span><span class=p>;</span><span class=w>
</span></code></pre></div><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// parser.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>input</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=c1>// snip
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>parse</span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=c1>// snip
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>While we’re at it we might as well paste in the REPL code from before the wipe of the project:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// crates/eldiro-cli/src/main.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=p>{</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>Write</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>stdin</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>io</span>::<span class=n>stdin</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>stdout</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>io</span>::<span class=n>stdout</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>stderr</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>io</span>::<span class=n>stderr</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>input</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>env</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>eldiro</span>::<span class=n>Env</span>::<span class=n>default</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>write</span><span class=o>!</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span><span class=w> </span><span class=s>&#34;→ &#34;</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=n>stdout</span><span class=p>.</span><span class=n>flush</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>stdin</span><span class=p>.</span><span class=n>read_line</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>input</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=n>run</span><span class=p>(</span><span class=n>input</span><span class=p>.</span><span class=n>trim</span><span class=p>(),</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>env</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=nb>Ok</span><span class=p>(</span><span class=nb>Some</span><span class=p>(</span><span class=n>val</span><span class=p>))</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>writeln</span><span class=o>!</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span><span class=w> </span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>val</span><span class=p>)</span><span class=o>?</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=nb>Ok</span><span class=p>(</span><span class=nb>None</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>            </span><span class=nb>Err</span><span class=p>(</span><span class=n>msg</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>writeln</span><span class=o>!</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=w> </span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>msg</span><span class=p>)</span><span class=o>?</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>input</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>run</span><span class=p>(</span><span class=n>input</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>env</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>eldiro</span>::<span class=n>Env</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=nb>Option</span><span class=o>&lt;</span><span class=n>eldiro</span>::<span class=n>Val</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>parse</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>eldiro</span>::<span class=n>parse</span><span class=p>(</span><span class=n>input</span><span class=p>).</span><span class=n>map_err</span><span class=p>(</span><span class=o>|</span><span class=n>msg</span><span class=o>|</span><span class=w> </span><span class=n>format</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Parse error: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>msg</span><span class=p>))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>evaluated</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>parse</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>eval</span><span class=p>(</span><span class=n>env</span><span class=p>)</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>map_err</span><span class=p>(</span><span class=o>|</span><span class=n>msg</span><span class=o>|</span><span class=w> </span><span class=n>format</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Evaluation error: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>msg</span><span class=p>))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>evaluated</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>eldiro</span>::<span class=n>Val</span>::<span class=n>Unit</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=nb>None</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=nb>Some</span><span class=p>(</span><span class=n>evaluated</span><span class=p>))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>A lot of that code revolves around evaluating the user’s input, which we haven’t implemented yet. Let’s get rid of it and use our new parser too:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>eldiro</span>::<span class=n>parser</span>::<span class=n>Parser</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=p>{</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>Write</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>stdin</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>io</span>::<span class=n>stdin</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>stdout</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>io</span>::<span class=n>stdout</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>input</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>write</span><span class=o>!</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span><span class=w> </span><span class=s>&#34;→ &#34;</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=n>stdout</span><span class=p>.</span><span class=n>flush</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>stdin</span><span class=p>.</span><span class=n>read_line</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>input</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>parse</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Parser</span>::<span class=n>new</span><span class=p>(</span><span class=o>&amp;</span><span class=n>input</span><span class=p>).</span><span class=n>parse</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>input</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>How are we going to display the parser’s output? We can’t access <code>parse.green_node</code> like we can in our <code>check</code> test helper function. Let’s add a method to <code>Parse</code> that provides a debug representation of the parse tree:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// crates/eldiro/src/parser.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>lexer</span>::<span class=n>SyntaxKind</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>syntax</span>::<span class=p>{</span><span class=n>EldiroLanguage</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxNode</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>logos</span>::<span class=n>Logos</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>rowan</span>::<span class=p>{</span><span class=n>GreenNode</span><span class=p>,</span><span class=w> </span><span class=n>GreenNodeBuilder</span><span class=p>,</span><span class=w> </span><span class=n>Language</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>debug_tree</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>String</span> <span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>syntax_node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SyntaxNode</span>::<span class=n>new_root</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>green_node</span><span class=p>.</span><span class=n>clone</span><span class=p>());</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>formatted</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>format</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;{:#?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>syntax_node</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=c1>// We cut off the last byte because formatting the SyntaxNode adds on a newline at the end.
</span><span class=c1></span><span class=w>        </span><span class=n>formatted</span><span class=p>[</span><span class=mi>0</span><span class=p>..</span><span class=n>formatted</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>].</span><span class=n>to_string</span><span class=p>()</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Let’s update <code>check</code> to use this:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=n>expect_test</span>::<span class=p>{</span><span class=n>expect</span><span class=p>,</span><span class=w> </span><span class=n>Expect</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>check</span><span class=p>(</span><span class=n>input</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>expected_tree</span>: <span class=nc>Expect</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>parse</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Parser</span>::<span class=n>new</span><span class=p>(</span><span class=n>input</span><span class=p>).</span><span class=n>parse</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=n>expected_tree</span><span class=p>.</span><span class=n>assert_eq</span><span class=p>(</span><span class=o>&amp;</span><span class=n>parse</span><span class=p>.</span><span class=n>debug_tree</span><span class=p>());</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>We can now use <code>Parse::debug_tree</code> in our REPL:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// crates/eldiro-cli/src/main.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>eldiro</span>::<span class=n>parser</span>::<span class=n>Parser</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=p>{</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>Write</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>io</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>stdin</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>io</span>::<span class=n>stdin</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>stdout</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>io</span>::<span class=n>stdout</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>input</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>write</span><span class=o>!</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span><span class=w> </span><span class=s>&#34;→ &#34;</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=n>stdout</span><span class=p>.</span><span class=n>flush</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>stdin</span><span class=p>.</span><span class=n>read_line</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>input</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>parse</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Parser</span>::<span class=n>new</span><span class=p>(</span><span class=o>&amp;</span><span class=n>input</span><span class=p>).</span><span class=n>parse</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>parse</span><span class=p>.</span><span class=n>debug_tree</span><span class=p>());</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>input</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>As expected, when we run the Eldiro CLI we get our REPL which, no matter the input, gives us a tree with a single <code>Root</code> node:</p><pre><code class=language-- data-lang=->$ cargo r
→
Root@0..0
→ test
Root@0..0
→ fe;wjmfeoijfew;oifjes;oad
Root@0..0
→ 1+1
Root@0..0
→ ^C
$
</code></pre><h1 id=writing-a-parser-that-does-things>Writing a parser that does things</h1><p>As we just saw, our parser isn’t exactly interesting. Let’s parse numbers and binding usages first, since those are both straightforward and only involve a single token of input. First, a test for numbers:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// crates/eldiro/src/parser.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_number</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;123&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;
</span><span class=s>Root@0..3
</span><span class=s>  Number@0..3 &#34;123&#34;&#34;#</span><span class=p>]],</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Here we’re seeing Rowan’s tree format in full &ndash; children are successively indented by two spaces, and lexeme text is included after the text range in quotes. Feel free to run <code>cargo t</code> to see what expect-test’s diffs look like. They use colour, so I can’t reproduce them here.</p><p>Implementing parsing of numbers shows how Rowan and Logos combine:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>parse</span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>start_node</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Root</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>lexer</span><span class=p>.</span><span class=n>next</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>token</span><span class=p>(</span><span class=w>
</span><span class=w>                </span><span class=n>EldiroLanguage</span>::<span class=n>kind_to_raw</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>),</span><span class=w>
</span><span class=w>                </span><span class=bp>self</span><span class=p>.</span><span class=n>lexer</span><span class=p>.</span><span class=n>slice</span><span class=p>().</span><span class=n>into</span><span class=p>(),</span><span class=w>
</span><span class=w>            </span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>finish_node</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>green_node</span>: <span class=nc>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>finish</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>That call to <code>Iterator::next</code> isn’t ideal &ndash; it’s advancing the lexer, even if we don’t have a <code>Number</code>. This is perfectly fine in this case, but in most other cases we’ll only want to keep eating through the input if we are at a certain token. To be able to call <code>next</code> without going any further into the input, we’ll use the <code>Peekable</code> iterator adaptor:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>lexer</span>::<span class=n>SyntaxKind</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>syntax</span>::<span class=p>{</span><span class=n>EldiroLanguage</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxNode</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>logos</span>::<span class=n>Logos</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>rowan</span>::<span class=p>{</span><span class=n>GreenNode</span><span class=p>,</span><span class=w> </span><span class=n>GreenNodeBuilder</span><span class=p>,</span><span class=w> </span><span class=n>Language</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>iter</span>::<span class=n>Peekable</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>lexer</span>: <span class=nc>Peekable</span><span class=o>&lt;</span><span class=n>logos</span>::<span class=n>Lexer</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>builder</span>: <span class=nc>GreenNodeBuilder</span><span class=o>&lt;</span><span class=nb>&#39;static</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>input</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>lexer</span>: <span class=nc>SyntaxKind</span>::<span class=n>lexer</span><span class=p>(</span><span class=n>input</span><span class=p>).</span><span class=n>peekable</span><span class=p>(),</span><span class=w>
</span><span class=w>            </span><span class=n>builder</span>: <span class=nc>GreenNodeBuilder</span>::<span class=n>new</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>This gives us an error, though, when we try to call <code>.slice()</code> in <code>Parser::parse</code>, since that method is defined on the <code>logos::Lexer</code> that <code>Peekable</code> is wrapping, but not <code>Peekable</code> itself. Unfortunately, the only way to solve this is to either:</p><ul><li>lex the entire input eagerly, or</li><li>define our own <code>Lexer</code> that wraps <code>logos::Lexer</code></li></ul><p>We’ll need to do the second one later anyway, so we might as well go down that route.</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// lexer.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>struct</span> <span class=nc>Lexer</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>inner</span>: <span class=nc>logos</span>::<span class=n>Lexer</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Lexer</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>input</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>inner</span>: <span class=nc>SyntaxKind</span>::<span class=n>lexer</span><span class=p>(</span><span class=n>input</span><span class=p>),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=nb>Iterator</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Lexer</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>SyntaxKind</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>next</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>kind</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>inner</span><span class=p>.</span><span class=n>next</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>text</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>inner</span><span class=p>.</span><span class=n>slice</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>((</span><span class=n>kind</span><span class=p>,</span><span class=w> </span><span class=n>text</span><span class=p>))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>To make sure the lexer is working we can modify the <code>check</code> helper function to use our custom lexer wrapper instead of the standard Logos one:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>check</span><span class=p>(</span><span class=n>input</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>kind</span>: <span class=nc>SyntaxKind</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>lexer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Lexer</span>::<span class=n>new</span><span class=p>(</span><span class=n>input</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>lexer</span><span class=p>.</span><span class=n>next</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>((</span><span class=n>kind</span><span class=p>,</span><span class=w> </span><span class=n>input</span><span class=p>)));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><pre><code class=language-- data-lang=->$ cargo t -q
running 16 tests
................
test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>We can now modify <code>Parser</code> to use our new lexer:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// parser.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>lexer</span>::<span class=p>{</span><span class=n>Lexer</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>syntax</span>::<span class=p>{</span><span class=n>EldiroLanguage</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxNode</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>rowan</span>::<span class=p>{</span><span class=n>GreenNode</span><span class=p>,</span><span class=w> </span><span class=n>GreenNodeBuilder</span><span class=p>,</span><span class=w> </span><span class=n>Language</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>iter</span>::<span class=n>Peekable</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>lexer</span>: <span class=nc>Peekable</span><span class=o>&lt;</span><span class=n>Lexer</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>builder</span>: <span class=nc>GreenNodeBuilder</span><span class=o>&lt;</span><span class=nb>&#39;static</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>input</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>lexer</span>: <span class=nc>Lexer</span>::<span class=n>new</span><span class=p>(</span><span class=n>input</span><span class=p>).</span><span class=n>peekable</span><span class=p>(),</span><span class=w>
</span><span class=w>            </span><span class=n>builder</span>: <span class=nc>GreenNodeBuilder</span>::<span class=n>new</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Let’s introduce a <code>peek</code> method to ‘peek’ at what the next <code>SyntaxKind</code> is:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>parse</span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>start_node</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Root</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>token</span><span class=p>(</span><span class=w>
</span><span class=w>                </span><span class=n>EldiroLanguage</span>::<span class=n>kind_to_raw</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>),</span><span class=w>
</span><span class=w>                </span><span class=bp>self</span><span class=p>.</span><span class=n>lexer</span><span class=p>.</span><span class=n>slice</span><span class=p>().</span><span class=n>into</span><span class=p>(),</span><span class=w>
</span><span class=w>            </span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>finish_node</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>green_node</span>: <span class=nc>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>finish</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>peek</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>SyntaxKind</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>lexer</span><span class=p>.</span><span class=n>peek</span><span class=p>().</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=p>(</span><span class=n>kind</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=o>|</span><span class=w> </span><span class=o>*</span><span class=n>kind</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Let’s also introduce a <code>bump</code> method that adds the lexeme the lexer is currently at to the current branch of the parse tree:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>parse</span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>start_node</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Root</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>bump</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>finish_node</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>green_node</span>: <span class=nc>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>finish</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>bump</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>kind</span><span class=p>,</span><span class=w> </span><span class=n>text</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>lexer</span><span class=p>.</span><span class=n>next</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>builder</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>token</span><span class=p>(</span><span class=n>EldiroLanguage</span>::<span class=n>kind_to_raw</span><span class=p>(</span><span class=n>kind</span><span class=p>),</span><span class=w> </span><span class=n>text</span><span class=p>.</span><span class=n>into</span><span class=p>());</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Take note of the <code>.unwrap()</code> in <code>Parser::bump</code>; if we try to add the current lexeme to the parse tree when we’re actually at the end of the input, then we end up panicking. In my opinion this is reasonable, since it’s an error on the behalf of the programmer, and cannot be recovered from.</p><pre><code class=language-- data-lang=->$ cargo t -q
running 16 tests
................
test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>After all that refactoring and refinement, it’s trivial to parse binding usages. Here’s the test:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_binding_usage</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;counter&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;
</span><span class=s>Root@0..7
</span><span class=s>  Ident@0..7 &#34;counter&#34;&#34;#</span><span class=p>]],</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>And here’s how we can implement it:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>parse</span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>start_node</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Root</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>bump</span><span class=p>(),</span><span class=w>
</span><span class=w>            </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>finish_node</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>green_node</span>: <span class=nc>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>finish</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><pre><code class=language-- data-lang=->$ cargo t -q
running 17 tests
.................
test result: ok. 17 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><h1 id=operator-precedence>Operator precedence</h1><p>Now that we’ve gotten to know Rowan a bit better and set up a basic project using it, we can start on the main goal of this post: operator precedence. Up to now, Eldiro has not had operator precedence in any shape or form &ndash; we’ve always disallowed nested operations. A big thanks to <a href=https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html>this fantastic post</a> by <a href=https://github.com/matklad>matklad</a>; it’s the best explanation of the algorithm we’ll be using here I’ve seen. Speaking of the algorithm we’re using, it’s called the ‘Pratt parsing algorithm’.</p><p>If we want to parse a mathematical operation, we’ll need to store it in our Rowan-based syntax tree, which means we’ll also need to create a <code>SyntaxKind</code> variant to differentiate mathematical operations (also known as <em>binary operations</em> due to them having two operands) from all the other node types we’ll have:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// lexer.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Debug, Copy, Clone, PartialEq, Logos, FromPrimitive, ToPrimitive)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>enum</span> <span class=nc>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=n>Root</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>BinOp</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Let’s write a function that parses a single expression. At the moment this will only parse numbers and binding usages:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// parser.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>expr</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>lexer</span>::<span class=p>{</span><span class=n>Lexer</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>syntax</span>::<span class=p>{</span><span class=n>EldiroLanguage</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxNode</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>expr</span>::<span class=n>expr</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>rowan</span>::<span class=p>{</span><span class=n>GreenNode</span><span class=p>,</span><span class=w> </span><span class=n>GreenNodeBuilder</span><span class=p>,</span><span class=w> </span><span class=n>Language</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>iter</span>::<span class=n>Peekable</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>parse</span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>start_node</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Root</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>expr</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>finish_node</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>Parse</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>green_node</span>: <span class=nc>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>finish</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// expr.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=n>Parser</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>lexer</span>::<span class=n>SyntaxKind</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>expr</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Parser</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>All we’ve done here is move some of the code from <code>Parser::parse</code> into its own function. In my opinion tests should be next to the code they’re testing, so let’s migrate the relevant tests from <code>crate::parser</code> to <code>crate::parser::expr</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// parser.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>check</span><span class=p>(</span><span class=n>input</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>expected_tree</span>: <span class=nc>expect_test</span>::<span class=n>Expect</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>parse</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Parser</span>::<span class=n>new</span><span class=p>(</span><span class=n>input</span><span class=p>).</span><span class=n>parse</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=n>expected_tree</span><span class=p>.</span><span class=n>assert_eq</span><span class=p>(</span><span class=o>&amp;</span><span class=n>parse</span><span class=p>.</span><span class=n>debug_tree</span><span class=p>());</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=n>expect_test</span>::<span class=n>expect</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_nothing</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=w> </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;Root@0..0&#34;#</span><span class=p>]]);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// expr.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=k>super</span>::<span class=n>check</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=n>expect_test</span>::<span class=n>expect</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_number</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;123&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;
</span><span class=s>Root@0..3
</span><span class=s>  Number@0..3 &#34;123&#34;&#34;#</span><span class=p>]],</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_binding_usage</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;counter&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;
</span><span class=s>Root@0..7
</span><span class=s>  Ident@0..7 &#34;counter&#34;&#34;#</span><span class=p>]],</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Now that we’re parsing single expressions isolated from the rest of the parser, we need to parse operators:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>super</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>expr</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Parser</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Plus</span><span class=p>)</span><span class=w>
</span><span class=w>        </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Minus</span><span class=p>)</span><span class=w>
</span><span class=w>        </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Star</span><span class=p>)</span><span class=w>
</span><span class=w>        </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Slash</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>To determine precedence we need to have some representation of an operator, since that lets us ask what the precedence of a given operator is:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>enum</span> <span class=nc>Op</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Add</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>Sub</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>Mul</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>Div</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>The representation of precedence Pratt parsing uses is called <em>binding power</em> &ndash; the higher the binding power, the ‘tighter’ the operator holds on to its operands. For example, multiplication has a higher binding power than addition.</p><p>Keep in mind that there are <em>left-associative</em> and <em>right-associative</em> operators. Here’s how <code>1 - 2 - 3 - 4</code> is parsed if we assume <code>-</code> to be left-associative:</p><pre><code>((1 - 2) - 3) - 4
</code></pre><p>And here’s how it’s parsed if <code>-</code> is right-associative:</p><pre><code>1 - (2 - (3 - 4))
</code></pre><p>All of the standard four binary operators are conventionally left-associative. Examples of conventionally right-associative operators include exponentiation (<code>2^3^4</code> is parsed as <code>2^(3^4)</code>) and <a href=https://en.wikipedia.org/wiki/Function_composition>function composition</a>. To convey associativity, Pratt parsing includes different binding powers for the left and the right side of the operator.</p><p>Here’s the conventional binding power table:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Op</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>binding_power</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=bp>self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>Self</span>::<span class=n>Add</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>Self</span>::<span class=n>Sub</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=n>Self</span>::<span class=n>Mul</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>Self</span>::<span class=n>Div</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>I was dumbfounded when I first saw this; how could all these operators possibly be left-associative if their right binding powers are all higher than their left binding powers?! Surely, if you want to make something left-associative you increase its left binding power? This is not the case &ndash; let me see if I can explain. Here’s a simple example of binary operations:</p><pre><code class=language-- data-lang=->1   +   2   +   3   +   4
</code></pre><p>Here’s what happens if we put the relevant binding power next to each operator:</p><pre><code class=language-- data-lang=->1   +   2   +   3   +   4
  1   2   1   2   1   2
</code></pre><p>Let’s now move the operators and numbers together that have the strongest connection (in this case the ones that are separated by <code>2</code> instead of <code>1</code>):</p><pre><code class=language-- data-lang=->1   + 2   + 3   + 4
  1  2  1  2  1  2
</code></pre><p>Take a look at how the intuitive ‘if the right binding power is higher, then it’s right-associative’ idea doesn’t work; <code>+</code> can’t be right associative, since we can’t rip that <code>3</code> away from the <code>+</code> so that it can join together in a binary operation with the <code>4</code>. The only possible way to resolve this is to connect the <code>1</code> to the <code>+ 2</code>, then successively add on the <code>+ 3</code> and the <code>+ 4</code> in increasingly lower levels of precedence.</p><pre><code class=language-- data-lang=->((1   + 2)   + 3)   + 4
    1  2   1  2   1  2
</code></pre><p>This is all well and good, but how do we write this in code? The solution is devilishly simple: we consume a single expression (at this point just a number or binding usage), and then start a loop. We parse out an operator, and based on that figure out what the left and right binding powers of the operator are. We then wrap everything we’ve parsed so far (the expression and the operator) in a new node, recurse, and finally finish that node.</p><p>Now here comes the really cool part:</p><p>This function actually takes a parameter, <code>min_binding_power</code>. Before we recurse, we check if the left binding power of the operator we’ve parsed is <em>less than</em> <code>min_binding_power</code>. If it is, then we can return. Oh, and also, when we recurse, the value we set <code>min_binding_power</code> to is the operator’s <em>right binding power.</em> This leads to some very interesting behaviour: the parser keeps recursing as long as the binding powers are getting higher and higher. Once the parser has found an operator with a lower binding power than what we’ve had so far, the function returns, which means the caller finishes their node and continues trying to parse operators with higher binding powers. It takes a while to fully understand how this works (at least it did for me), but I hope my explanation is enough to make it ‘click’ for you.</p><p>Let’s build up the code bit by bit; we already have a function to parse an expression, and we also have operators and their binding powers set up. First, we’ll determine which particular operator we’re looking at:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>super</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>expr</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Parser</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Plus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Add</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Minus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Sub</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Star</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Mul</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Slash</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Div</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>return</span><span class=p>,</span><span class=w> </span><span class=c1>// we’ll handle errors later.
</span><span class=c1></span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w>    </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Other code parsing expressions shouldn’t have to worry about the implementation details of operator precedence, so we should avoid adding the <code>min_binding_power</code> parameter directly to <code>expr</code>. Instead, we’ll rename <code>expr</code> to <code>expr_binding_power</code> and make <code>expr</code> call <code>expr_binding_power</code> with <code>min_binding_power</code> set to <code>0</code> (since there isn’t a minimum when you haven’t parsed anything yet):</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>super</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>expr</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Parser</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>expr_binding_power</span><span class=p>(</span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>expr_binding_power</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Parser</span><span class=p>,</span><span class=w> </span><span class=n>minimum_binding_power</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Plus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Add</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Minus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Sub</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Star</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Mul</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Slash</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Div</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>return</span><span class=p>,</span><span class=w> </span><span class=c1>// we’ll handle errors later.
</span><span class=c1></span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w>    </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>We can now get the operator’s binding powers and compare them to <code>minimum_binding_power</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>expr_binding_power</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Parser</span><span class=p>,</span><span class=w> </span><span class=n>minimum_binding_power</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Plus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Add</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Minus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Sub</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Star</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Mul</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Slash</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Div</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>return</span><span class=p>,</span><span class=w> </span><span class=c1>// we’ll handle errors later.
</span><span class=c1></span><span class=w>    </span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>left_binding_power</span><span class=p>,</span><span class=w> </span><span class=n>right_binding_power</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>op</span><span class=p>.</span><span class=n>binding_power</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>left_binding_power</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>minimum_binding_power</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// Eat the operator’s token.
</span><span class=c1></span><span class=w>    </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>();</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Let’s add the loop and recursion:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>expr_binding_power</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Parser</span><span class=p>,</span><span class=w> </span><span class=n>minimum_binding_power</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Plus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Add</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Minus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Sub</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Star</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Mul</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Slash</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Div</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>return</span><span class=p>,</span><span class=w> </span><span class=c1>// we’ll handle errors later.
</span><span class=c1></span><span class=w>        </span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>left_binding_power</span><span class=p>,</span><span class=w> </span><span class=n>right_binding_power</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>op</span><span class=p>.</span><span class=n>binding_power</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>left_binding_power</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>minimum_binding_power</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=c1>// Eat the operator’s token.
</span><span class=c1></span><span class=w>        </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>expr_binding_power</span><span class=p>(</span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=n>right_binding_power</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>All that’s left now is to add the wrapping of nodes each time <code>expr_binding_power</code> is called. Rowan allows us to do this with ease by using something called a <em>checkpoint.</em> We create a checkpoint, and can then later call <code>start_node_at</code> on our <code>GreenNodeBuilder</code>, passing in the checkpoint as a parameter. Everything we’ve added to the current branch since the creation of the checkpoint will be ‘indented’ under a new node. As usual, we’ll add helper methods to <code>Parser</code> so we don’t have to directly interact with the <code>GreenNodeBuilder</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// parser.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>expr</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>lexer</span>::<span class=p>{</span><span class=n>Lexer</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>syntax</span>::<span class=p>{</span><span class=n>EldiroLanguage</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxNode</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>expr</span>::<span class=n>expr</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>rowan</span>::<span class=p>{</span><span class=n>Checkpoint</span><span class=p>,</span><span class=w> </span><span class=n>GreenNode</span><span class=p>,</span><span class=w> </span><span class=n>GreenNodeBuilder</span><span class=p>,</span><span class=w> </span><span class=n>Language</span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>iter</span>::<span class=n>Peekable</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>Parser</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>start_node_at</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>checkpoint</span>: <span class=nc>Checkpoint</span><span class=p>,</span><span class=w> </span><span class=n>kind</span>: <span class=nc>SyntaxKind</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>builder</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>start_node_at</span><span class=p>(</span><span class=n>checkpoint</span><span class=p>,</span><span class=w> </span><span class=n>EldiroLanguage</span>::<span class=n>kind_to_raw</span><span class=p>(</span><span class=n>kind</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>checkpoint</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Checkpoint</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>builder</span><span class=p>.</span><span class=n>checkpoint</span><span class=p>()</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// expr.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>expr_binding_power</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Parser</span><span class=p>,</span><span class=w> </span><span class=n>minimum_binding_power</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>checkpoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>checkpoint</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Plus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Add</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Minus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Sub</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Star</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Mul</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Slash</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Op</span>::<span class=n>Div</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>return</span><span class=p>,</span><span class=w> </span><span class=c1>// we’ll handle errors later.
</span><span class=c1></span><span class=w>        </span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>left_binding_power</span><span class=p>,</span><span class=w> </span><span class=n>right_binding_power</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>op</span><span class=p>.</span><span class=n>binding_power</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>left_binding_power</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>minimum_binding_power</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>       </span><span class=c1>// Eat the operator’s token.
</span><span class=c1></span><span class=w>        </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=n>p</span><span class=p>.</span><span class=n>start_node_at</span><span class=p>(</span><span class=n>checkpoint</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>BinOp</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>expr_binding_power</span><span class=p>(</span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=n>right_binding_power</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=n>p</span><span class=p>.</span><span class=n>finish_node</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>And just like that, we’ve implemented bare-minimum operator precedence! Let’s write a few tests to make sure it works:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_simple_binary_expression</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;1+2&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;
</span><span class=s>Root@0..3
</span><span class=s>  BinOp@0..3
</span><span class=s>    Number@0..1 &#34;1&#34;
</span><span class=s>    Plus@1..2 &#34;+&#34;
</span><span class=s>    Number@2..3 &#34;2&#34;&#34;#</span><span class=p>]],</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_left_associative_binary_expression</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;1+2+3+4&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;
</span><span class=s>Root@0..7
</span><span class=s>  BinOp@0..7
</span><span class=s>    BinOp@0..5
</span><span class=s>      BinOp@0..3
</span><span class=s>        Number@0..1 &#34;1&#34;
</span><span class=s>        Plus@1..2 &#34;+&#34;
</span><span class=s>        Number@2..3 &#34;2&#34;
</span><span class=s>      Plus@3..4 &#34;+&#34;
</span><span class=s>      Number@4..5 &#34;3&#34;
</span><span class=s>    Plus@5..6 &#34;+&#34;
</span><span class=s>    Number@6..7 &#34;4&#34;&#34;#</span><span class=p>]],</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_binary_expression_with_mixed_binding_power</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;1+2*3-4&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;
</span><span class=s>Root@0..7
</span><span class=s>  BinOp@0..7
</span><span class=s>    BinOp@0..5
</span><span class=s>      Number@0..1 &#34;1&#34;
</span><span class=s>      Plus@1..2 &#34;+&#34;
</span><span class=s>      BinOp@2..5
</span><span class=s>        Number@2..3 &#34;2&#34;
</span><span class=s>        Star@3..4 &#34;*&#34;
</span><span class=s>        Number@4..5 &#34;3&#34;
</span><span class=s>    Minus@5..6 &#34;-&#34;
</span><span class=s>    Number@6..7 &#34;4&#34;&#34;#</span><span class=p>]],</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>As you can tell, these tests get quite long and can be difficult to follow at times, so I try to keep them as short as possible. I still recommend thoroughly reading through one or two of them to make sure you understand what the parser is doing.</p><p>Congratulations on making it to the end! That’s it for this part; let me know what you think of the length, and if I should have broken this one up into several parts. In the next part we’ll fix two glaring holes in our operator precedence logic: lack of prefix operator support (e.g. <code>-10</code>) and lack of parentheses to control the order of operations.</p></main><nav class=prev-and-next><div class=prev><p class=hint>Previously</p><a href=https://arzg.github.io/lang/9/>Part Nine: Function Calls</a></div><div class=next><p class=hint>Next up</p><a href=https://arzg.github.io/lang/11/>Part Eleven: Refinements</a></div><div style=clear:both></div></nav></body></html>