<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Part Ten: Starting Again · arzg’s website</title><link rel=stylesheet href=https://arzg.github.io/scss/main.5b8c013dd5e51a40b743f06124716408dad09d87641389dd50c9b9d63c648588.css integrity="sha256-W4wBPdXlGkC3Q/BhJHFkCNrQnYdkE4ndUMm51jxkhYg="><script src=https://unpkg.com/quicklink@2.0.0/dist/quicklink.umd.js></script>
<script src=https://unpkg.com/anchor-js@4.3.1/anchor.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/plugins/autoloader/prism-autoloader.min.js></script>
<script>window.onload=()=>{quicklink.listen()},document.addEventListener("DOMContentLoaded",function(a){anchors.add("main h1")})</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body><nav class=site-navigation><ul><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li class=current><a href=/lang/>Make A Language</a></li></ul></nav><header class=header-area><h1 class=title>Part Ten: Starting Again</h1><section class=page-info><ul><li>15 November 2020</li><li>5695 words</li><li>28 minute read</li></ul></section></header><main><p>In Part Nine <a href=/lang/9/#problems-with-the-current-implementation>I described</a> the reasons for switching to <a href=https://github.com/rust-analyzer/rowan>Rowan</a> and a lexer over the current lexerless parsing system we’ve developed in <code>crate::utils</code>. Read that before reading on here.</p><h1 id=wiping-the-project>Wiping the project</h1><p>Sadly, the moment has arrived. It’s time to delete what we’ve created, since almost none of it will be reusable.</p><pre><code class=language-->$ rm -r crates/{eldiro,eldiro-cli}/src
</code></pre><p>Let’s add in placeholder files so everything still compiles:</p><pre><code class=language-rust>// crates/eldiro/src/lib.rs

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre><pre><code class=language-rust>// crates/eldiro-cli/src/main.rs

fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre><h1 id=a-lexer>A lexer</h1><p>To write our lexer, we’ll use the <a href=https://github.com/maciejhirsz/logos/>Logos</a> crate. This will generate a lexer for us that’s <a href=https://github.com/maciejhirsz/logos/blob/73d518c1d248599cad82c36ff34d6c0b41850ed2/README.md#how-fast>really fast</a> (according to the project README) without much effort on our part. Let’s start by adding Logos as a dependency to <code>eldiro</code>:</p><pre><code class=language-toml># crates/eldiro/Cargo.toml

# snip

[dependencies]
logos = &quot;0.11.4&quot;
</code></pre><p>Let’s also create a module for our lexer to live in:</p><pre><code class=language-rust>// crates/eldiro/src/lib.rs

mod lexer;
</code></pre><p>We can now open <code>src/lexer.rs</code> and start writing our lexer. The first thing we need to declare is an enum that will represent the types of <em>tokens</em> our lexer can, well, <em>lex.</em> Why don’t we start with something easy &ndash; whitespace, maybe?</p><pre><code class=language-rust>enum Token {
    Whitespace,
}
</code></pre><p>What if we encounter a piece of text that doesn’t match any token? We need a variant for that, too:</p><pre><code class=language-rust>enum Token {
    Whitespace,
    Error,
}
</code></pre><p>When I first learnt about this I thought it was incredibly perverse. Why let every single token in your implementation be an error when you could instead represent this in a much cleaner way using <code>Result</code>? Remember, though, that our parser has to be lossless, meaning that it must represent the input flawlessly and <em>always</em> return an output, no matter how malformed the input is.</p><h1 id=a-quick-aside-about-rowan>A quick aside about Rowan</h1><p>Rowan manages to represent both an arbitrary input, as well as an arbitrary parser output. How does it do this? Here’s a code sketch slightly modified from the <a href=https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/syntax.md>rust-analyzer docs</a>:</p><pre><code class=language-rust>#[derive(PartialEq, Eq, Clone, Copy)]
struct SyntaxKind(u16);

#[derive(PartialEq, Eq, Clone)]
struct SyntaxNode {
    kind: SyntaxKind,
    children: Vec&lt;Arc&lt;SyntaxElement&gt;&gt;,
}

#[derive(PartialEq, Eq, Clone)]
enum SyntaxElement {
    Node(SyntaxNode),
    Token(SyntaxToken),
}

#[derive(PartialEq, Eq, Clone)]
struct SyntaxToken {
    kind: SyntaxKind,
    text: String,
}
</code></pre><p>Confusingly, <code>SyntaxKind</code> here is our own <code>Token</code> cast to a <code>u16</code>, while <code>SyntaxToken</code> is unrelated. To keep ourselves from getting confused when we use Rowan later, we’ll rename our <code>Token</code> to <code>SyntaxKind</code>:</p><pre><code class=language-rust>enum SyntaxKind {
    Whitespace,
    Error,
}
</code></pre><p>One of the key elements of the Rowan tree structure is that trees are <em>deduplicated,</em> i.e. if you construct two identical trees in your parser, only one copy is ever stored in memory, reducing memory usage.</p><p>Although it isn’t visible here, Rowan gives you access to parents and siblings if you have a <code>SyntaxNode</code>, <code>SyntaxToken</code> or <code>SyntaxElement</code>. This is especially convenient for writing, say, <a href=https://github.com/RDambrosio016/RSLint>a linter with Rowan</a>.</p><h1 id=back-to-the-lexer>Back to the lexer</h1><p>Let’s actually make the lexer lex text. This is where Logos comes into play. Here’s our first test:</p><pre><code class=language-rust>pub(crate) enum SyntaxKind {
    Whitespace,
    Error,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn lex_spaces() {
        let mut lexer = SyntaxKind::lexer(&quot;   &quot;);

        assert_eq!(lexer.next(), Some(SyntaxKind::Whitespace));
        assert_eq!(lexer.slice(), &quot;   &quot;);
    }
}
</code></pre><p>Here we’re creating our lexer from the input we want to test, and then verify that the lexer has determined that the input starts with whitespace. We make sure that the entirety of the input has been classified as whitespace by checking that the text of the current <em>lexeme</em> (you can think of a lexeme as a <code>(SyntaxKind, &str)</code>) is equal to the original input.</p><p>For now, let’s define whitespace to be a series of one or more spaces, which can be represented by the regex <code>/ +/</code>. Here’s how we tell this to Logos:</p><pre><code class=language-rust>use logos::Logos;

#[derive(Debug, Copy, Clone, PartialEq, Logos)]
pub(crate) enum SyntaxKind {
    #[regex(&quot; +&quot;)]
    Whitespace,

    #[error]
    Error,
}
</code></pre><pre><code class=language-->$ cargo t -q
running 1 test
.
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Let’s also lex the <code>fn</code> keyword, used in function definitions. A test first:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn lex_fn_keyword() {
        let mut lexer = SyntaxKind::lexer(&quot;fn&quot;);

        assert_eq!(lexer.next(), Some(SyntaxKind::FnKw));
        assert_eq!(lexer.slice(), &quot;fn&quot;);
    }
}
</code></pre><p>Let’s now write the needed implementation:</p><pre><code class=language-rust>#[derive(Debug, Copy, Clone, PartialEq, Logos)]
pub(crate) enum SyntaxKind {
    #[regex(&quot; +&quot;)]
    Whitespace,

    #[token(&quot;fn&quot;)]
    FnKw,

    #[error]
    Error,
}
</code></pre><pre><code class=language-->$ cargo t -q
running 2 tests
..
test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>That test code is getting repetitive though. Let’s extract the common parts into a helper function:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::*;

    fn check(input: &amp;str, kind: SyntaxKind) {
        let mut lexer = SyntaxKind::lexer(input);

        assert_eq!(lexer.next(), Some(kind));
        assert_eq!(lexer.slice(), input);
    }

    #[test]
    fn lex_spaces() {
        check(&quot;   &quot;, SyntaxKind::Whitespace);
    }

    #[test]
    fn lex_fn_keyword() {
        check(&quot;fn&quot;, SyntaxKind::FnKw);
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
running 2 tests
..
test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>We can now zoom through lexing all the remaining lexical constructs:</p><ul><li>the <code>let</code> keyword</li><li>identifiers (start with a letter, followed by letters or numbers)</li><li>numbers</li><li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>=</code>, <code>{</code>, <code>}</code></li></ul><p>Here’s the file in its entirety:</p><pre><code class=language-rust>use logos::Logos;

#[derive(Debug, Copy, Clone, PartialEq, Logos)]
pub(crate) enum SyntaxKind {
    #[regex(&quot; +&quot;)]
    Whitespace,

    #[token(&quot;fn&quot;)]
    FnKw,

    #[token(&quot;let&quot;)]
    LetKw,

    #[regex(&quot;[A-Za-z][A-Za-z0-9]+&quot;)]
    Ident,

    #[regex(&quot;[0-9]+&quot;)]
    Number,

    #[token(&quot;+&quot;)]
    Plus,

    #[token(&quot;-&quot;)]
    Minus,

    #[token(&quot;*&quot;)]
    Star,

    #[token(&quot;/&quot;)]
    Slash,

    #[token(&quot;=&quot;)]
    Equals,

    #[token(&quot;{&quot;)]
    LBrace,

    #[token(&quot;}&quot;)]
    RBrace,

    #[error]
    Error,
}

#[cfg(test)]
mod tests {
    use super::*;

    fn check(input: &amp;str, kind: SyntaxKind) {
        let mut lexer = SyntaxKind::lexer(input);

        assert_eq!(lexer.next(), Some(kind));
        assert_eq!(lexer.slice(), input);
    }

    #[test]
    fn lex_spaces() {
        check(&quot;   &quot;, SyntaxKind::Whitespace);
    }

    #[test]
    fn lex_fn_keyword() {
        check(&quot;fn&quot;, SyntaxKind::FnKw);
    }

    #[test]
    fn lex_let_keyword() {
        check(&quot;let&quot;, SyntaxKind::LetKw);
    }

    #[test]
    fn lex_alphabetic_identifier() {
        check(&quot;abcd&quot;, SyntaxKind::Ident);
    }

    #[test]
    fn lex_alphanumeric_identifier() {
        check(&quot;ab123cde456&quot;, SyntaxKind::Ident);
    }

    #[test]
    fn lex_mixed_case_identifier() {
        check(&quot;ABCdef&quot;, SyntaxKind::Ident);
    }

    #[test]
    fn lex_number() {
        check(&quot;123456&quot;, SyntaxKind::Number);
    }

    #[test]
    fn lex_plus() {
        check(&quot;+&quot;, SyntaxKind::Plus);
    }

    #[test]
    fn lex_minus() {
        check(&quot;-&quot;, SyntaxKind::Minus);
    }

    #[test]
    fn lex_star() {
        check(&quot;*&quot;, SyntaxKind::Star);
    }

    #[test]
    fn lex_slash() {
        check(&quot;/&quot;, SyntaxKind::Slash);
    }

    #[test]
    fn lex_equals() {
        check(&quot;=&quot;, SyntaxKind::Equals);
    }

    #[test]
    fn lex_left_brace() {
        check(&quot;{&quot;, SyntaxKind::LBrace);
    }

    #[test]
    fn lex_right_brace() {
        check(&quot;}&quot;, SyntaxKind::RBrace);
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
running 14 tests
..............
test result: ok. 14 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><h1 id=a-parser>A parser</h1><pre><code class=language-rust>// lib.rs

mod lexer;
mod parser;
</code></pre><p>The first thing our parser needs to hold is a lexer generated by Logos:</p><pre><code class=language-rust>// src/parser.rs

use crate::lexer::SyntaxKind;

pub(crate) struct Parser&lt;'a&gt; {
    lexer: logos::Lexer&lt;'a, SyntaxKind&gt;,
}
</code></pre><p>That lifetime <code>'a</code> is needed because Logos’ lexers store the input they were created with, and pull from it as tokens are requested. An approach more common than what we’re doing is to lex the entire input upon creating the parser, but we don’t need to do that: we can lex <em>lazily</em> as we go, rather than <em>eagerly</em> all at once. This is really a micro-optimisation, but it’s so cool and easy to do, and there’s no downside (for now).</p><p>Let’s add a constructor:</p><pre><code class=language-rust>use crate::lexer::SyntaxKind;
use logos::Logos;

// snip

impl&lt;'a&gt; Parser&lt;'a&gt; {
    pub(crate) fn new(input: &amp;'a str) -&gt; Self {
        Self {
            lexer: SyntaxKind::lexer(input),
        }
    }
}
</code></pre><p>How can we construct a syntax tree, though? This is what we’re using Rowan for. Let’s add the relevant code so we can use Rowan first, and I’ll explain afterwards:</p><pre><code class=language-toml># Cargo.toml

# snip

[dependencies]
logos = &quot;0.11.4&quot;
rowan = &quot;0.10.0&quot;
</code></pre><pre><code class=language-rust>// parser.rs

use crate::lexer::SyntaxKind;
use logos::Logos;
use rowan::GreenNodeBuilder;

pub(crate) struct Parser&lt;'a&gt; {
    lexer: logos::Lexer&lt;'a, SyntaxKind&gt;,
    builder: GreenNodeBuilder&lt;'static&gt;,
}

impl&lt;'a&gt; Parser&lt;'a&gt; {
    pub(crate) fn new(input: &amp;'a str) -&gt; Self {
        Self {
            lexer: SyntaxKind::lexer(input),
            builder: GreenNodeBuilder::new(),
        }
    }
}
</code></pre><p>Earlier in this post I explained the gist of Rowan’s syntax trees. Here’s how you create one: the builder remembers what branch of the tree you’re on. It exposes methods to create a new child branch with a given <code>SyntaxKind</code> and make it current, add a token to the current branch, as well as a method to finish the current branch and restore the parent branch as current. Finally, <code>GreenNodeBuilder</code> has a <code>finish</code> method, which outputs the syntax tree it has created.</p><p><code>finish</code> requires the syntax tree to contain just one root node; we can fulfil this requirement by creating all our nodes as children of a single <code>Root</code> node. Let’s add this to <code>SyntaxKind</code>:</p><pre><code class=language-rust>// lexer.rs

#[derive(Debug, Copy, Clone, PartialEq, Logos)]
pub(crate) enum SyntaxKind {
    // snip

    Root,
}
</code></pre><p>We can now start defining a <code>parse</code> method on <code>Parser</code> that creates a <code>Root</code> node:</p><pre><code class=language-rust>// parser.rs

impl&lt;'a&gt; Parser&lt;'a&gt; {
    // snip

    pub(crate) fn parse(mut self) -&gt; ? {
        self.builder.start_node(SyntaxKind::Root);
        self.builder.finish_node();
    }
}
</code></pre><p>What do we output from <code>Parser::parse</code>? Let’s define a new structure to hold the output of parsing:</p><pre><code class=language-rust>use crate::lexer::SyntaxKind;
use logos::Logos;
use rowan::{GreenNode, GreenNodeBuilder};

// snip

impl&lt;'a&gt; Parser&lt;'a&gt; {
    // snip

    pub(crate) fn parse(mut self) -&gt; Parse {
        self.builder.start_node(SyntaxKind::Root);
        self.builder.finish_node();

        Parse {
            green_node: self.builder.finish(),
        }
    }
}

pub(crate) struct Parse {
    green_node: GreenNode,
}
</code></pre><p>We now have an error when we’re trying to create our root node about <code>GreenNodeBuilder::start_node</code> expecting a <code>rowan::SyntaxKind</code> instead of our <code>SyntaxKind</code>. To solve this we’ll implement <code>From&lt;SyntaxKind> for rowan::SyntaxKind</code>:</p><pre><code class=language-rust>// lexer.rs

impl From&lt;SyntaxKind&gt; for rowan::SyntaxKind {
    fn from(kind: SyntaxKind) -&gt; Self {
        Self(kind as u16)
    }
}
</code></pre><p>Note how Rowan never directly interacts with our <code>SyntaxKind</code> &ndash; instead, it’s casted to a <code>u16</code> so that Rowan can work with any enum. Now that that’s done, we can add a call to <code>.into()</code> to convert our <code>SyntaxKind</code> into Rowan’s:</p><pre><code class=language-rust>// parser.rs

impl&lt;'a&gt; Parser&lt;'a&gt; {
    // snip

    pub(crate) fn parse(mut self) -&gt; Parse {
        self.builder.start_node(SyntaxKind::Root.into());
        self.builder.finish_node();

        Parse {
            green_node: self.builder.finish(),
        }
    }
}
</code></pre><p>So that we can write tests for our parser, we’ll need a way of displaying its output: the <code>GreenNode</code> inside of <code>Parse</code>. We can only do this by converting it to a <code>SyntaxNode</code>.</p><p>Remember how Rowan doesn’t actually store our <code>SyntaxKind</code>, instead storing its own <code>rowan::SyntaxKind</code> with our <code>SyntaxKind</code> casted to a <code>u16</code>? In order for Rowan to be able to give us our <code>SyntaxKind</code> instead of the ‘raw’ Rowan version when we, say, ask Rowan what the kind of a given node is, we need to also have our own version of <code>SyntaxNode</code> that knows how to convert between the two. Eventually we’ll also need our own <code>SyntaxElement</code> and <code>SyntaxToken</code>, but we don’t need those at the moment. The way Rowan automates the conversion is through a trait, namely <code>rowan::Language</code>.</p><h1 id=another-rabbit-hole>Another rabbit hole</h1><p>Once again, a new module is in order:</p><pre><code class=language-rust>// lib.rs

mod lexer;
mod parser;
mod syntax;
</code></pre><pre><code class=language-rust>// src/syntax.rs

use crate::lexer::SyntaxKind;

#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub(crate) enum EldiroLanguage {}

impl rowan::Language for EldiroLanguage {
    type Kind = SyntaxKind;

    fn kind_from_raw(raw: rowan::SyntaxKind) -&gt; Self::Kind {
        todo!()
    }

    fn kind_to_raw(kind: Self::Kind) -&gt; rowan::SyntaxKind {
        todo!()
    }
}
</code></pre><p>Converting from our <code>SyntaxKind</code> to Rowan’s is easy &ndash; we can re-use the <code>From</code> implementation from earlier:</p><pre><code class=language-rust>impl rowan::Language for EldiroLanguage {
    // snip

    fn kind_to_raw(kind: Self::Kind) -&gt; rowan::SyntaxKind {
        kind.into()
    }
}
</code></pre><p>Going the other way, though, is much more difficult &ndash; we have to convert from something with 65,536 possible values (<code>u16</code>) to one with fourteen (<code>SyntaxKind</code>). We could do it the manual way:</p><pre><code class=language-rust>impl rowan::Language for EldiroLanguage {
    // snip

    fn kind_from_raw(raw: rowan::SyntaxKind) -&gt; Self::Kind {
        match raw.0 {
            0 =&gt; Self::Kind::Whitespace,
            1 =&gt; Self::Kind::FnKw,
            2 =&gt; Self::Kind::LetKw,
            3 =&gt; Self::Kind::Ident,
            4 =&gt; Self::Kind::Number,
            // etc.
        }
    }

    // snip
}
</code></pre><p>This is tedious, error prone and makes it annoying to modify <code>SyntaxKind</code> in any way. We could also use some <code>unsafe</code>:</p><pre><code class=language-rust>impl rowan::Language for EldiroLanguage {
    // snip

    fn kind_from_raw(raw: rowan::SyntaxKind) -&gt; Self::Kind {
        assert!(raw.0 &lt; 14);
        unsafe { std::mem::transmute(raw) }
    }

    // snip
}
</code></pre><p>This also works, but means we need to update this seemingly-magical number every time we add or remove a variant from <code>SyntaxKind</code>. rust-analyzer <a href=https://github.com/rust-analyzer/rust-analyzer/blob/7f12a1f225c7d3397f27964ce039b55d680772d3/crates/parser/src/syntax_kind/generated.rs#L250>uses</a> a hidden <code>__LAST</code> enum variant to determine how many variants their <code>SyntaxKind</code> has. Regardless, <code>std::mem::transmute</code> is about the most unsafe thing you can do, so I’d like to avoid it.</p><p>The approach we’ll use utilises a procedural macro to automate the process for us. Usually I’d hesitate before adding a procedural macro due to the compilation time overhead they incur; however, we’re already using a proc-macro &ndash; Logos &ndash; so we’re paying the cost of the procedural macro ecosystem whether we use this approach or not.</p><pre><code class=language-toml># Cargo.toml

# snip

[dependencies]
logos = &quot;0.11.4&quot;
num-derive = &quot;0.3.3&quot;
num-traits = &quot;0.2.14&quot;
rowan = &quot;0.10.0&quot;
</code></pre><pre><code class=language-rust>// lexer.rs

use logos::Logos;
use num_derive::{FromPrimitive, ToPrimitive};

#[derive(Debug, Copy, Clone, PartialEq, Logos, FromPrimitive, ToPrimitive)]
pub(crate) enum SyntaxKind {
    // snip
}
</code></pre><pre><code class=language-rust>// syntax.rs

use crate::lexer::SyntaxKind;
use num_traits::{FromPrimitive, ToPrimitive};

// snip

impl rowan::Language for EldiroLanguage {
    type Kind = SyntaxKind;

    fn kind_from_raw(raw: rowan::SyntaxKind) -&gt; Self::Kind {
        Self::Kind::from_u16(raw.0).unwrap()
    }

    fn kind_to_raw(kind: Self::Kind) -&gt; rowan::SyntaxKind {
        rowan::SyntaxKind(kind.to_u16().unwrap())
    }
}
</code></pre><p>This also means we can remove our custom <code>From&lt;SyntaxKind> for rowan::SyntaxKind</code> impl.</p><p>Now we can define our own Eldiro-specific <code>SyntaxNode</code>:</p><pre><code class=language-rust>pub(crate) type SyntaxNode = rowan::SyntaxNode&lt;EldiroLanguage&gt;;
</code></pre><p>Finally, the last error left before we can write tests for our parser is from our usage of <code>.into()</code> in <code>Parser::parse</code>. Let’s replace that with a usage of our <code>EldiroLanguage</code>, plus some helper methods to reduce typing:</p><pre><code class=language-rust>use crate::lexer::SyntaxKind;
use crate::syntax::EldiroLanguage;
use logos::Logos;
use rowan::{GreenNode, GreenNodeBuilder, Language};

// snip

impl&lt;'a&gt; Parser&lt;'a&gt; {
    // snip

    pub(crate) fn parse(mut self) -&gt; Parse {
        self.start_node(SyntaxKind::Root);
        self.finish_node();

        Parse {
            green_node: self.builder.finish(),
        }
    }

    fn start_node(&amp;mut self, kind: SyntaxKind) {
        self.builder.start_node(EldiroLanguage::kind_to_raw(kind));
    }

    fn finish_node(&amp;mut self) {
        self.builder.finish_node();
    }
}
</code></pre><h1 id=testing-our-parser>Testing our parser</h1><p>And now, finally, we can write the first test for our parser:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::*;
    use crate::syntax::SyntaxNode;

    #[test]
    fn parse_nothing() {
        let parse = Parser::new(&quot;&quot;).parse();

        assert_eq!(
            format!(&quot;{:#?}&quot;, SyntaxNode::new_root(parse.green_node)),
            r#&quot;Root@0..0
&quot;#,
        );
    }
}
</code></pre><p>Doesn’t look too good, does it? It’s long, tedious to write, and &ndash; worst of all &ndash; doesn’t provide any sort of diff if the test fails. Instead, <code>cargo t</code> will spit out the syntax tree we expected and the one we got, and it’ll be up to us to Spot The Difference. I’ve tried using <a href=https://github.com/colin-kiegel/rust-pretty-assertions>Pretty Assertions</a> for this problem in the past, and although it works well for comparing structured data, it isn’t nice to work with when you’re using strings like we are here. Instead of showing the line-by-line diff, Pretty Assertions instead shows a diff as if the syntax tree is all on one line, with the lines separated by a literal <code>\n</code>.</p><p>We’ll use <a href=https://docs.rs/expect-test/>expect-test</a> instead, which:</p><ul><li>shows line-by-line diffs properly</li><li>gives us the option to automatically update expected test results <em>en masse</em></li></ul><p>From the documentation:</p><blockquote><p>This becomes very useful when you have a lot of tests with verbose and potentially changing expected output.</p></blockquote><p>expect-test sounds perfect for this use case, and that’s no coincidence &ndash; it was made by the developers of rust-analyzer.</p><p>Let’s convert our lone test to use expect-test:</p><pre><code class=language-toml># Cargo.toml

# snip

[dev-dependencies]
expect-test = &quot;1.0.1&quot;
</code></pre><pre><code class=language-rust>// parser.rs

#[cfg(test)]
mod tests {
    use super::*;
    use crate::syntax::SyntaxNode;
    use expect_test::{expect, Expect};

    fn check(input: &amp;str, expected_tree: Expect) {
        let parse = Parser::new(input).parse();
        let syntax_node = SyntaxNode::new_root(parse.green_node);

        let actual_tree = format!(&quot;{:#?}&quot;, syntax_node);

        // We cut off the last byte because formatting the SyntaxNode adds on a newline at the end.
        expected_tree.assert_eq(&amp;actual_tree[0..actual_tree.len() - 1]);
    }

    #[test]
    fn parse_nothing() {
        check(&quot;&quot;, expect![[r#&quot;Root@0..0&quot;#]]);
    }
}
</code></pre><p>Running our tests gives us a bunch of warnings, as well as fifteen happy little green dots:</p><pre><code class=language-->$ cargo -t q
running 15 tests
...............
test result: ok. 15 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><h1 id=cleaning-up-warnings>Cleaning up warnings</h1><p>Let’s make a few things that we know will need to be used by the REPL <code>pub</code> now so that some of those ‘dead code’ warnings go away:</p><pre><code class=language-rust>// lib.rs

pub mod parser;

mod lexer;
mod syntax;
</code></pre><pre><code class=language-rust>// parser.rs

// snip

pub struct Parser&lt;'a&gt; {
    // snip
}

// snip

impl&lt;'a&gt; Parser&lt;'a&gt; {
    pub fn new(input: &amp;'a str) -&gt; Self {
        // snip
    }

    pub fn parse(mut self) -&gt; Parse {
        // snip
    }

    // snip
}

pub struct Parse {
    // snip
}
</code></pre><p>While we’re at it we might as well paste in the REPL code from before the wipe of the project:</p><pre><code class=language-rust>// crates/eldiro-cli/src/main.rs

use std::io::{self, Write};

fn main() -&gt; io::Result&lt;()&gt; {
    let stdin = io::stdin();
    let mut stdout = io::stdout();
    let mut stderr = io::stderr();

    let mut input = String::new();
    let mut env = eldiro::Env::default();

    loop {
        write!(stdout, &quot;→ &quot;)?;
        stdout.flush()?;

        stdin.read_line(&amp;mut input)?;

        match run(input.trim(), &amp;mut env) {
            Ok(Some(val)) =&gt; writeln!(stdout, &quot;{}&quot;, val)?,
            Ok(None) =&gt; {}
            Err(msg) =&gt; writeln!(stderr, &quot;{}&quot;, msg)?,
        }

        input.clear();
    }
}

fn run(input: &amp;str, env: &amp;mut eldiro::Env) -&gt; Result&lt;Option&lt;eldiro::Val&gt;, String&gt; {
    let parse = eldiro::parse(input).map_err(|msg| format!(&quot;Parse error: {}&quot;, msg))?;

    let evaluated = parse
        .eval(env)
        .map_err(|msg| format!(&quot;Evaluation error: {}&quot;, msg))?;

    if evaluated == eldiro::Val::Unit {
        Ok(None)
    } else {
        Ok(Some(evaluated))
    }
}
</code></pre><p>A lot of that code revolves around evaluating the user’s input, which we haven’t implemented yet. Let’s get rid of it and use our new parser too:</p><pre><code class=language-rust>use eldiro::parser::Parser;
use std::io::{self, Write};

fn main() -&gt; io::Result&lt;()&gt; {
    let stdin = io::stdin();
    let mut stdout = io::stdout();

    let mut input = String::new();

    loop {
        write!(stdout, &quot;→ &quot;)?;
        stdout.flush()?;

        stdin.read_line(&amp;mut input)?;

        let parse = Parser::new(&amp;input).parse();

        input.clear();
    }
}
</code></pre><p>How are we going to display the parser’s output? We can’t access <code>parse.green_node</code> like we can in our <code>check</code> test helper function. Let’s add a method to <code>Parse</code> that provides a debug representation of the parse tree:</p><pre><code class=language-rust>// crates/eldiro/src/parser.rs

use crate::lexer::SyntaxKind;
use crate::syntax::{EldiroLanguage, SyntaxNode};
use logos::Logos;
use rowan::{GreenNode, GreenNodeBuilder, Language};

// snip

impl Parse {
    pub fn debug_tree(&amp;self) -&gt; String {
        let syntax_node = SyntaxNode::new_root(self.green_node.clone());
        let formatted = format!(&quot;{:#?}&quot;, syntax_node);

        // We cut off the last byte because formatting the SyntaxNode adds on a newline at the end.
        formatted[0..formatted.len() - 1].to_string()
    }
}
</code></pre><p>Let’s update <code>check</code> to use this:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::*;
    use expect_test::{expect, Expect};

    fn check(input: &amp;str, expected_tree: Expect) {
        let parse = Parser::new(input).parse();
        expected_tree.assert_eq(&amp;parse.debug_tree());
    }

    // snip
}
</code></pre><p>We can now use <code>Parse::debug_tree</code> in our REPL:</p><pre><code class=language-rust>// crates/eldiro-cli/src/main.rs

use eldiro::parser::Parser;
use std::io::{self, Write};

fn main() -&gt; io::Result&lt;()&gt; {
    let stdin = io::stdin();
    let mut stdout = io::stdout();

    let mut input = String::new();

    loop {
        write!(stdout, &quot;→ &quot;)?;
        stdout.flush()?;

        stdin.read_line(&amp;mut input)?;

        let parse = Parser::new(&amp;input).parse();
        println!(&quot;{}&quot;, parse.debug_tree());

        input.clear();
    }
}
</code></pre><p>As expected, when we run the Eldiro CLI we get our REPL which, no matter the input, gives us a tree with a single <code>Root</code> node:</p><pre><code class=language-->$ cargo r
→
Root@0..0
→ test
Root@0..0
→ fe;wjmfeoijfew;oifjes;oad
Root@0..0
→ 1+1
Root@0..0
→ ^C
$
</code></pre><h1 id=writing-a-parser-that-does-things>Writing a parser that does things</h1><p>As we just saw, our parser isn’t exactly interesting. Let’s parse numbers and binding usages first, since those are both straightforward and only involve a single token of input. First, a test for numbers:</p><pre><code class=language-rust>// crates/eldiro/src/parser.rs

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_number() {
        check(
            &quot;123&quot;,
            expect![[r#&quot;
Root@0..3
  Number@0..3 &quot;123&quot;&quot;#]],
        );
    }
}
</code></pre><p>Here we’re seeing Rowan’s tree format in full &ndash; children are successively indented by two spaces, and lexeme text is included after the text range in quotes. Feel free to run <code>cargo t</code> to see what expect-test’s diffs look like. They use colour, so I can’t reproduce them here.</p><p>Implementing parsing of numbers shows how Rowan and Logos combine:</p><pre><code class=language-rust>impl&lt;'a&gt; Parser&lt;'a&gt; {
    // snip

    pub fn parse(mut self) -&gt; Parse {
        self.start_node(SyntaxKind::Root);

        if self.lexer.next() == Some(SyntaxKind::Number) {
            self.builder.token(
                EldiroLanguage::kind_to_raw(SyntaxKind::Number),
                self.lexer.slice().into(),
            );
        }

        self.finish_node();

        Parse {
            green_node: self.builder.finish(),
        }
    }

    // snip
}
</code></pre><p>That call to <code>Iterator::next</code> isn’t ideal &ndash; it’s advancing the lexer, even if we don’t have a <code>Number</code>. This is perfectly fine in this case, but in most other cases we’ll only want to keep eating through the input if we are at a certain token. To be able to call <code>next</code> without going any further into the input, we’ll use the <code>Peekable</code> iterator adaptor:</p><pre><code class=language-rust>use crate::lexer::SyntaxKind;
use crate::syntax::{EldiroLanguage, SyntaxNode};
use logos::Logos;
use rowan::{GreenNode, GreenNodeBuilder, Language};
use std::iter::Peekable;

pub struct Parser&lt;'a&gt; {
    lexer: Peekable&lt;logos::Lexer&lt;'a, SyntaxKind&gt;&gt;,
    builder: GreenNodeBuilder&lt;'static&gt;,
}

impl&lt;'a&gt; Parser&lt;'a&gt; {
    pub fn new(input: &amp;'a str) -&gt; Self {
        Self {
            lexer: SyntaxKind::lexer(input).peekable(),
            builder: GreenNodeBuilder::new(),
        }
    }

    // snip
}
</code></pre><p>This gives us an error, though, when we try to call <code>.slice()</code> in <code>Parser::parse</code>, since that method is defined on the <code>logos::Lexer</code> that <code>Peekable</code> is wrapping, but not <code>Peekable</code> itself. Unfortunately, the only way to solve this is to either:</p><ul><li>lex the entire input eagerly, or</li><li>define our own <code>Lexer</code> that wraps <code>logos::Lexer</code></li></ul><p>We’ll need to do the second one later anyway, so we might as well go down that route.</p><pre><code class=language-rust>// lexer.rs

pub(crate) struct Lexer&lt;'a&gt; {
    inner: logos::Lexer&lt;'a, SyntaxKind&gt;,
}

impl&lt;'a&gt; Lexer&lt;'a&gt; {
    pub(crate) fn new(input: &amp;'a str) -&gt; Self {
        Self {
            inner: SyntaxKind::lexer(input),
        }
    }
}

impl&lt;'a&gt; Iterator for Lexer&lt;'a&gt; {
    type Item = (SyntaxKind, &amp;'a str);

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let kind = self.inner.next()?;
        let text = self.inner.slice();

        Some((kind, text))
    }
}
</code></pre><p>To make sure the lexer is working we can modify the <code>check</code> helper function to use our custom lexer wrapper instead of the standard Logos one:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    fn check(input: &amp;str, kind: SyntaxKind) {
        let mut lexer = Lexer::new(input);
        assert_eq!(lexer.next(), Some((kind, input)));
    }

    // snip
}
</code></pre><pre><code class=language-->$ cargo t -q
running 16 tests
................
test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>We can now modify <code>Parser</code> to use our new lexer:</p><pre><code class=language-rust>// parser.rs

use crate::lexer::{Lexer, SyntaxKind};
use crate::syntax::{EldiroLanguage, SyntaxNode};
use rowan::{GreenNode, GreenNodeBuilder, Language};
use std::iter::Peekable;

pub struct Parser&lt;'a&gt; {
    lexer: Peekable&lt;Lexer&lt;'a&gt;&gt;,
    builder: GreenNodeBuilder&lt;'static&gt;,
}

impl&lt;'a&gt; Parser&lt;'a&gt; {
    pub fn new(input: &amp;'a str) -&gt; Self {
        Self {
            lexer: Lexer::new(input).peekable(),
            builder: GreenNodeBuilder::new(),
        }
    }

    // snip
}
</code></pre><p>Let’s introduce a <code>peek</code> method to ‘peek’ at what the next <code>SyntaxKind</code> is:</p><pre><code class=language-rust>impl&lt;'a&gt; Parser&lt;'a&gt; {
    // snip

    pub fn parse(mut self) -&gt; Parse {
        self.start_node(SyntaxKind::Root);

        if self.peek() == Some(SyntaxKind::Number) {
            self.builder.token(
                EldiroLanguage::kind_to_raw(SyntaxKind::Number),
                self.lexer.slice().into(),
            );
        }

        self.finish_node();

        Parse {
            green_node: self.builder.finish(),
        }
    }

    // snip

    fn peek(&amp;mut self) -&gt; Option&lt;SyntaxKind&gt; {
        self.lexer.peek().map(|(kind, _)| *kind)
    }
}
</code></pre><p>Let’s also introduce a <code>bump</code> method that adds the lexeme the lexer is currently at to the current branch of the parse tree:</p><pre><code class=language-rust>impl&lt;'a&gt; Parser&lt;'a&gt; {
    // snip

    pub fn parse(mut self) -&gt; Parse {
        self.start_node(SyntaxKind::Root);

        if self.peek() == Some(SyntaxKind::Number) {
            self.bump();
        }

        self.finish_node();

        Parse {
            green_node: self.builder.finish(),
        }
    }

    // snip

    fn bump(&amp;mut self) {
        let (kind, text) = self.lexer.next().unwrap();

        self.builder
            .token(EldiroLanguage::kind_to_raw(kind), text.into());
    }

    // snip
}
</code></pre><p>Take note of the <code>.unwrap()</code> in <code>Parser::bump</code>; if we try to add the current lexeme to the parse tree when we’re actually at the end of the input, then we end up panicking. In my opinion this is reasonable, since it’s an error on the behalf of the programmer, and cannot be recovered from.</p><pre><code class=language-->$ cargo t -q
running 16 tests
................
test result: ok. 16 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>After all that refactoring and refinement, it’s trivial to parse binding usages. Here’s the test:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_binding_usage() {
        check(
            &quot;counter&quot;,
            expect![[r#&quot;
Root@0..7
  Ident@0..7 &quot;counter&quot;&quot;#]],
        );
    }
}
</code></pre><p>And here’s how we can implement it:</p><pre><code class=language-rust>impl&lt;'a&gt; Parser&lt;'a&gt; {
    // snip

    pub fn parse(mut self) -&gt; Parse {
        self.start_node(SyntaxKind::Root);

        match self.peek() {
            Some(SyntaxKind::Number) | Some(SyntaxKind::Ident) =&gt; self.bump(),
            _ =&gt; {}
        }

        self.finish_node();

        Parse {
            green_node: self.builder.finish(),
        }
    }

    // snip
}
</code></pre><pre><code class=language-->$ cargo t -q
running 17 tests
.................
test result: ok. 17 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><h1 id=operator-precedence>Operator precedence</h1><p>Now that we’ve gotten to know Rowan a bit better and set up a basic project using it, we can start on the main goal of this post: operator precedence. Up to now, Eldiro has not had operator precedence in any shape or form &ndash; we’ve always disallowed nested operations. A big thanks to <a href=https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html>this fantastic post</a> by <a href=https://github.com/matklad>matklad</a>; it’s the best explanation of the algorithm we’ll be using here I’ve seen. Speaking of the algorithm we’re using, it’s called the ‘Pratt parsing algorithm’.</p><p>If we want to parse a mathematical operation, we’ll need to store it in our Rowan-based syntax tree, which means we’ll also need to create a <code>SyntaxKind</code> variant to differentiate mathematical operations (also known as <em>binary operations</em> due to them having two operands) from all the other node types we’ll have:</p><pre><code class=language-rust>// lexer.rs

// snip

#[derive(Debug, Copy, Clone, PartialEq, Logos, FromPrimitive, ToPrimitive)]
pub(crate) enum SyntaxKind {
    // snip

    Root,
    BinOp,
}
</code></pre><p>Let’s write a function that parses a single expression. At the moment this will only parse numbers and binding usages:</p><pre><code class=language-rust>// parser.rs

mod expr;

use crate::lexer::{Lexer, SyntaxKind};
use crate::syntax::{EldiroLanguage, SyntaxNode};
use expr::expr;
use rowan::{GreenNode, GreenNodeBuilder, Language};
use std::iter::Peekable;

// snip

impl&lt;'a&gt; Parser&lt;'a&gt; {
    // snip

    pub fn parse(mut self) -&gt; Parse {
        self.start_node(SyntaxKind::Root);

        expr(&amp;mut self);

        self.finish_node();

        Parse {
            green_node: self.builder.finish(),
        }
    }

    // snip
}
</code></pre><pre><code class=language-rust>// expr.rs

use super::Parser;
use crate::lexer::SyntaxKind;

fn expr(p: &amp;mut Parser) {
    match p.peek() {
        Some(SyntaxKind::Number) | Some(SyntaxKind::Ident) =&gt; p.bump(),
        _ =&gt; {}
    }
}
</code></pre><p>All we’ve done here is move some of the code from <code>Parser::parse</code> into its own function. In my opinion tests should be next to the code they’re testing, so let’s migrate the relevant tests from <code>crate::parser</code> to <code>crate::parser::expr</code>:</p><pre><code class=language-rust>// parser.rs

#[cfg(test)]
fn check(input: &amp;str, expected_tree: expect_test::Expect) {
    let parse = Parser::new(input).parse();
    expected_tree.assert_eq(&amp;parse.debug_tree());
}

#[cfg(test)]
mod tests {
    use super::*;
    use expect_test::expect;

    #[test]
    fn parse_nothing() {
        check(&quot;&quot;, expect![[r#&quot;Root@0..0&quot;#]]);
    }
}
</code></pre><pre><code class=language-rust>// expr.rs

#[cfg(test)]
mod tests {
    use super::super::check;
    use expect_test::expect;

    #[test]
    fn parse_number() {
        check(
            &quot;123&quot;,
            expect![[r#&quot;
Root@0..3
  Number@0..3 &quot;123&quot;&quot;#]],
        );
    }

    #[test]
    fn parse_binding_usage() {
        check(
            &quot;counter&quot;,
            expect![[r#&quot;
Root@0..7
  Ident@0..7 &quot;counter&quot;&quot;#]],
        );
    }
}
</code></pre><p>Now that we’re parsing single expressions isolated from the rest of the parser, we need to parse operators:</p><pre><code class=language-rust>pub(super) fn expr(p: &amp;mut Parser) {
    match p.peek() {
        Some(SyntaxKind::Number) | Some(SyntaxKind::Ident) =&gt; p.bump(),
        _ =&gt; {}
    }

    match p.peek() {
        Some(SyntaxKind::Plus)
        | Some(SyntaxKind::Minus)
        | Some(SyntaxKind::Star)
        | Some(SyntaxKind::Slash) =&gt; p.bump(),
        _ =&gt; {}
    }
}
</code></pre><p>To determine precedence we need to have some representation of an operator, since that lets us ask what the precedence of a given operator is:</p><pre><code class=language-rust>enum Op {
    Add,
    Sub,
    Mul,
    Div,
}
</code></pre><p>The representation of precedence Pratt parsing uses is called <em>binding power</em> &ndash; the higher the binding power, the ‘tighter’ the operator holds on to its operands. For example, multiplication has a higher binding power than addition.</p><p>Keep in mind that there are <em>left-associative</em> and <em>right-associative</em> operators. Here’s how <code>1 - 2 - 3 - 4</code> is parsed if we assume <code>-</code> to be left-associative:</p><pre><code>((1 - 2) - 3) - 4
</code></pre><p>And here’s how it’s parsed if <code>-</code> is right-associative:</p><pre><code>1 - (2 - (3 - 4))
</code></pre><p>All of the standard four binary operators are conventionally left-associative. Examples of conventionally right-associative operators include exponentiation (<code>2^3^4</code> is parsed as <code>2^(3^4)</code>) and <a href=https://en.wikipedia.org/wiki/Function_composition>function composition</a>. To convey associativity, Pratt parsing includes different binding powers for the left and the right side of the operator.</p><p>Here’s the conventional binding power table:</p><pre><code class=language-rust>impl Op {
    fn binding_power(&amp;self) -&gt; (u8, u8) {
        match self {
            Self::Add | Self::Sub =&gt; (1, 2),
            Self::Mul | Self::Div =&gt; (3, 4),
        }
    }
}
</code></pre><p>I was dumbfounded when I first saw this; how could all these operators possibly be left-associative if their right binding powers are all higher than their left binding powers?! Surely, if you want to make something left-associative you increase its left binding power? This is not the case &ndash; let me see if I can explain. Here’s a simple example of binary operations:</p><pre><code class=language-->1   +   2   +   3   +   4
</code></pre><p>Here’s what happens if we put the relevant binding power next to each operator:</p><pre><code class=language-->1   +   2   +   3   +   4
  1   2   1   2   1   2
</code></pre><p>Let’s now move the operators and numbers together that have the strongest connection (in this case the ones that are separated by <code>2</code> instead of <code>1</code>):</p><pre><code class=language-->1   + 2   + 3   + 4
  1  2  1  2  1  2
</code></pre><p>Take a look at how the intuitive ‘if the right binding power is higher, then it’s right-associative’ idea doesn’t work; <code>+</code> can’t be right associative, since we can’t rip that <code>3</code> away from the <code>+</code> so that it can join together in a binary operation with the <code>4</code>. The only possible way to resolve this is to connect the <code>1</code> to the <code>+ 2</code>, then successively add on the <code>+ 3</code> and the <code>+ 4</code> in increasingly lower levels of precedence.</p><pre><code class=language-->((1   + 2)   + 3)   + 4
    1  2   1  2   1  2
</code></pre><p>This is all well and good, but how do we write this in code? The solution is devilishly simple: we consume a single expression (at this point just a number or binding usage), and then start a loop. We parse out an operator, and based on that figure out what the left and right binding powers of the operator are. We then wrap everything we’ve parsed so far (the expression and the operator) in a new node, recurse, and finally finish that node.</p><p>Now here comes the really cool part:</p><p>This function actually takes a parameter, <code>min_binding_power</code>. Before we recurse, we check if the left binding power of the operator we’ve parsed is <em>less than</em> <code>min_binding_power</code>. If it is, then we can return. Oh, and also, when we recurse, the value we set <code>min_binding_power</code> to is the operator’s <em>right binding power.</em> This leads to some very interesting behaviour: the parser keeps recursing as long as the binding powers are getting higher and higher. Once the parser has found an operator with a lower binding power than what we’ve had so far, the function returns, which means the caller finishes their node and continues trying to parse operators with higher binding powers. It takes a while to fully understand how this works (at least it did for me), but I hope my explanation is enough to make it ‘click’ for you.</p><p>Let’s build up the code bit by bit; we already have a function to parse an expression, and we also have operators and their binding powers set up. First, we’ll determine which particular operator we’re looking at:</p><pre><code class=language-rust>pub(super) fn expr(p: &amp;mut Parser) {
    match p.peek() {
        Some(SyntaxKind::Number) | Some(SyntaxKind::Ident) =&gt; p.bump(),
        _ =&gt; {}
    }

    let op = match p.peek() {
        Some(SyntaxKind::Plus) =&gt; Op::Add,
        Some(SyntaxKind::Minus) =&gt; Op::Sub,
        Some(SyntaxKind::Star) =&gt; Op::Mul,
        Some(SyntaxKind::Slash) =&gt; Op::Div,
        _ =&gt; return, // we’ll handle errors later.
    };
    p.bump();
}
</code></pre><p>Other code parsing expressions shouldn’t have to worry about the implementation details of operator precedence, so we should avoid adding the <code>min_binding_power</code> parameter directly to <code>expr</code>. Instead, we’ll rename <code>expr</code> to <code>expr_binding_power</code> and make <code>expr</code> call <code>expr_binding_power</code> with <code>min_binding_power</code> set to <code>0</code> (since there isn’t a minimum when you haven’t parsed anything yet):</p><pre><code class=language-rust>pub(super) fn expr(p: &amp;mut Parser) {
    expr_binding_power(p, 0);
}

fn expr_binding_power(p: &amp;mut Parser, minimum_binding_power: u8) {
    match p.peek() {
        Some(SyntaxKind::Number) | Some(SyntaxKind::Ident) =&gt; p.bump(),
        _ =&gt; {}
    }

    let op = match p.peek() {
        Some(SyntaxKind::Plus) =&gt; Op::Add,
        Some(SyntaxKind::Minus) =&gt; Op::Sub,
        Some(SyntaxKind::Star) =&gt; Op::Mul,
        Some(SyntaxKind::Slash) =&gt; Op::Div,
        _ =&gt; return, // we’ll handle errors later.
    };
    p.bump();
}
</code></pre><p>We can now get the operator’s binding powers and compare them to <code>minimum_binding_power</code>:</p><pre><code class=language-rust>fn expr_binding_power(p: &amp;mut Parser, minimum_binding_power: u8) {
    match p.peek() {
        Some(SyntaxKind::Number) | Some(SyntaxKind::Ident) =&gt; p.bump(),
        _ =&gt; {}
    }

    let op = match p.peek() {
        Some(SyntaxKind::Plus) =&gt; Op::Add,
        Some(SyntaxKind::Minus) =&gt; Op::Sub,
        Some(SyntaxKind::Star) =&gt; Op::Mul,
        Some(SyntaxKind::Slash) =&gt; Op::Div,
        _ =&gt; return, // we’ll handle errors later.
    };

    let (left_binding_power, right_binding_power) = op.binding_power();

    if left_binding_power &lt; minimum_binding_power {
        return;
    }

    // Eat the operator’s token.
    p.bump();
}
</code></pre><p>Let’s add the loop and recursion:</p><pre><code class=language-rust>fn expr_binding_power(p: &amp;mut Parser, minimum_binding_power: u8) {
    match p.peek() {
        Some(SyntaxKind::Number) | Some(SyntaxKind::Ident) =&gt; p.bump(),
        _ =&gt; {}
    }

    loop {
        let op = match p.peek() {
            Some(SyntaxKind::Plus) =&gt; Op::Add,
            Some(SyntaxKind::Minus) =&gt; Op::Sub,
            Some(SyntaxKind::Star) =&gt; Op::Mul,
            Some(SyntaxKind::Slash) =&gt; Op::Div,
            _ =&gt; return, // we’ll handle errors later.
        };

        let (left_binding_power, right_binding_power) = op.binding_power();

        if left_binding_power &lt; minimum_binding_power {
            return;
        }

        // Eat the operator’s token.
        p.bump();

        expr_binding_power(p, right_binding_power);
    }
}
</code></pre><p>All that’s left now is to add the wrapping of nodes each time <code>expr_binding_power</code> is called. Rowan allows us to do this with ease by using something called a <em>checkpoint.</em> We create a checkpoint, and can then later call <code>start_node_at</code> on our <code>GreenNodeBuilder</code>, passing in the checkpoint as a parameter. Everything we’ve added to the current branch since the creation of the checkpoint will be ‘indented’ under a new node. As usual, we’ll add helper methods to <code>Parser</code> so we don’t have to directly interact with the <code>GreenNodeBuilder</code>:</p><pre><code class=language-rust>// parser.rs

mod expr;

use crate::lexer::{Lexer, SyntaxKind};
use crate::syntax::{EldiroLanguage, SyntaxNode};
use expr::expr;
use rowan::{Checkpoint, GreenNode, GreenNodeBuilder, Language};
use std::iter::Peekable;

// snip

impl&lt;'a&gt; Parser&lt;'a&gt; {
    // snip

    fn start_node_at(&amp;mut self, checkpoint: Checkpoint, kind: SyntaxKind) {
        self.builder
            .start_node_at(checkpoint, EldiroLanguage::kind_to_raw(kind));
    }

    // snip

    fn checkpoint(&amp;self) -&gt; Checkpoint {
        self.builder.checkpoint()
    }

    // snip
}
</code></pre><pre><code class=language-rust>// expr.rs

fn expr_binding_power(p: &amp;mut Parser, minimum_binding_power: u8) {
    let checkpoint = p.checkpoint();

    match p.peek() {
        Some(SyntaxKind::Number) | Some(SyntaxKind::Ident) =&gt; p.bump(),
        _ =&gt; {}
    }

    loop {
        let op = match p.peek() {
            Some(SyntaxKind::Plus) =&gt; Op::Add,
            Some(SyntaxKind::Minus) =&gt; Op::Sub,
            Some(SyntaxKind::Star) =&gt; Op::Mul,
            Some(SyntaxKind::Slash) =&gt; Op::Div,
            _ =&gt; return, // we’ll handle errors later.
        };

        let (left_binding_power, right_binding_power) = op.binding_power();

        if left_binding_power &lt; minimum_binding_power {
            return;
        }

       // Eat the operator’s token.
        p.bump();

        p.start_node_at(checkpoint, SyntaxKind::BinOp);
        expr_binding_power(p, right_binding_power);
        p.finish_node();
    }
}
</code></pre><p>And just like that, we’ve implemented bare-minimum operator precedence! Let’s write a few tests to make sure it works:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_simple_binary_expression() {
        check(
            &quot;1+2&quot;,
            expect![[r#&quot;
Root@0..3
  BinOp@0..3
    Number@0..1 &quot;1&quot;
    Plus@1..2 &quot;+&quot;
    Number@2..3 &quot;2&quot;&quot;#]],
        );
    }

    #[test]
    fn parse_left_associative_binary_expression() {
        check(
            &quot;1+2+3+4&quot;,
            expect![[r#&quot;
Root@0..7
  BinOp@0..7
    BinOp@0..5
      BinOp@0..3
        Number@0..1 &quot;1&quot;
        Plus@1..2 &quot;+&quot;
        Number@2..3 &quot;2&quot;
      Plus@3..4 &quot;+&quot;
      Number@4..5 &quot;3&quot;
    Plus@5..6 &quot;+&quot;
    Number@6..7 &quot;4&quot;&quot;#]],
        );
    }

    #[test]
    fn parse_binary_expression_with_mixed_binding_power() {
        check(
            &quot;1+2*3-4&quot;,
            expect![[r#&quot;
Root@0..7
  BinOp@0..7
    BinOp@0..5
      Number@0..1 &quot;1&quot;
      Plus@1..2 &quot;+&quot;
      BinOp@2..5
        Number@2..3 &quot;2&quot;
        Star@3..4 &quot;*&quot;
        Number@4..5 &quot;3&quot;
    Minus@5..6 &quot;-&quot;
    Number@6..7 &quot;4&quot;&quot;#]],
        );
    }
}
</code></pre><p>As you can tell, these tests get quite long and can be difficult to follow at times, so I try to keep them as short as possible. I still recommend thoroughly reading through one or two of them to make sure you understand what the parser is doing.</p><p>Congratulations on making it to the end! That’s it for this part; let me know what you think of the length, and if I should have broken this one up into several parts. In the next part we’ll fix two glaring holes in our operator precedence logic: lack of prefix operator support (e.g. <code>-10</code>) and lack of parentheses to control the order of operations.</p></main><nav class=page-navigation><div class=prev><p class=hint>Previously</p><a href=https://arzg.github.io/lang/9/>Part Nine: Function Calls</a></div><div class=next><p class=hint>Next up</p><a href=https://arzg.github.io/lang/11/>Part Eleven: Refinements</a></div><div style=clear:both></div></nav></body></html>