<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Part Two: Whitespace support · arzg’s blog</title><link rel=stylesheet href=https://arzg.github.io/scss/main.f6fc4e7615cb54898cf43dfe33e9be7700a97e5304dedac899128bc7971d804a.css integrity="sha256-9vxOdhXLVImM9D3+M+m+dwCpflME3trImRKLx5cdgEo="></head><body><nav class=page-nav><ul><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li><a href=/lang/>Make A Language</a></li></ul></nav><header><subtitle>Make A Language</subtitle><h1>Part Two: Whitespace support</h1></header><p>September 9, 2020</p><main><p>Last time, we made a parser for simple unnested mathematical expressions, such as <code>1+1</code> or <code>3*4</code>. In this post, we’ll add support for whitespace (so that users of Eldiro will be able to use <code>2 + 2</code> instead of <code>2+2</code>).</p><p>We can achieve this by creating an <code>extract_whitespace</code> function similar to <code>extract_digits</code>:</p><pre><code>// utils.rs

// Let’s copy-paste from extract_digits
pub(crate) fn extract_whitespace(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    let whitespace_end = s
        .char_indices()
        .find_map(|(idx, c)| if c == ' ' { None } else { Some(idx) })
        .unwrap_or_else(|| s.len());

    let whitespace = &amp;s[..whitespace_end];
    let remainder = &amp;s[whitespace_end..];
    (remainder, whitespace)
}

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn extract_spaces() {
        assert_eq!(extract_whitespace(&quot;    1&quot;), (&quot;1&quot;, &quot;    &quot;));
    }
}
</code></pre><p>Although this <em>does</em> indeed work, it involves quite a bit of repetition. What if we want a similar function for, say, extracting variable names? Instead of copy-pasting <code>extract_digits</code> yet again, we can define a <code>take_while</code> function with the following signature:</p><pre><code>fn take_while(accept: impl Fn(char) -&gt; bool, s: &amp;str) -&gt; (&amp;str, &amp;str)
</code></pre><p><code>take_while</code> takes a function called <code>accept</code> that determines whether to accept a given character or not. Once it encounters a character that is not accepted, it stops consuming characters and returns.</p><pre><code>pub(crate) fn take_while(accept: impl Fn(char) -&gt; bool, s: &amp;str) -&gt; (&amp;str, &amp;str) {
    let extracted_end = s
        .char_indices()
        .find_map(|(idx, c)| if accept(c) { None } else { Some(idx) })
        .unwrap_or_else(|| s.len());

    let extracted = &amp;s[..extracted_end];
    let remainder = &amp;s[extracted_end..];
    (remainder, extracted)
}
</code></pre><p>We can now redefine <code>extract_digits</code> and <code>extract_whitespace</code> in terms of <code>take_while</code>:</p><pre><code>pub(crate) fn extract_digits(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    take_while(|c| c.is_ascii_digit(), s)
}

pub(crate) fn extract_whitespace(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    take_while(|c| c == ' ', s)
}
</code></pre><p>And our tests still pass!</p><p>To actually allow whitespace inside expressions, we can call <code>extract_whitespace</code> while throwing away the output:</p><pre><code>// lib.rs

impl Expr {
    pub fn new(s: &amp;str) -&gt; (&amp;str, Self) {
        let (s, lhs) = Number::new(s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, op) = Op::new(s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, rhs) = Number::new(s);

        (s, Self { lhs, rhs, op })
    }
}

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_expr_with_whitespace() {
        assert_eq!(
            Expr::new(&quot;2 * 2&quot;),
            (
                &quot;&quot;,
                Expr {
                    lhs: Number(2),
                    rhs: Number(2),
                    op: Op::Mul,
                },
            ),
        );
    }
}
</code></pre><p>Note that we aren’t using <code>let _ = utils::extract_whitespace(s)</code>, as that would throw away the <code>s</code> that we get back, thereby not progressing through the input. Instead, by using <code>let (s, _) = ...</code> we keep advancing, but throw away the actual whitespace we extracted.</p><p>In the next post, Eldiro will gain the ability to create variables. This involves both parsing, as well as the beginnings of an interpreter.</p></main><nav class=prev-and-next><div class=prev><p class=hint>Previously</p><a href=https://arzg.github.io/lang/1/>Part One: A basic parser</a></div><div style=clear:both></div></nav></body></html>