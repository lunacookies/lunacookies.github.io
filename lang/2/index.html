<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Part Two: Whitespace Support · arzg’s website</title><link rel=stylesheet href=https://arzg.github.io/scss/main.04c23afe51262a10ee61829da41f4d7318ff311ed0d0bcbf1db0fde96e3830f4.css integrity="sha256-BMI6/lEmKhDuYYKdpB9Ncxj/MR7Q0Ly/HbD96W44MPQ="><script src=https://unpkg.com/quicklink@2.0.0/dist/quicklink.umd.js></script>
<script src=https://unpkg.com/anchor-js@4.3.1/anchor.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/plugins/autoloader/prism-autoloader.min.js></script>
<script>window.onload=()=>{quicklink.listen()},document.addEventListener("DOMContentLoaded",function(a){anchors.add("main h1")})</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body><nav class=site-navigation><ul><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li class=current><a href=/lang/>Make A Language</a></li></ul></nav><header class=header-area><h1 class=title>Part Two: Whitespace Support</h1><section class=page-info><ul><li>9 September 2020</li><li>443 words</li><li>two minute read</li></ul></section></header><main><p>Last time, we made a parser for simple unnested mathematical expressions, such as <code>1+1</code> or <code>3*4</code>. In this post, we’ll add support for whitespace (so that users of Eldiro will be able to use <code>2 + 2</code> instead of <code>2+2</code>).</p><p>We can achieve this by creating an <code>extract_whitespace</code> function similar to <code>extract_digits</code>:</p><pre><code class=language-rust>// utils.rs

// Let’s copy-paste from extract_digits
pub(crate) fn extract_whitespace(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    let whitespace_end = s
        .char_indices()
        .find_map(|(idx, c)| if c == ' ' { None } else { Some(idx) })
        .unwrap_or_else(|| s.len());

    let whitespace = &amp;s[..whitespace_end];
    let remainder = &amp;s[whitespace_end..];
    (remainder, whitespace)
}

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn extract_spaces() {
        assert_eq!(extract_whitespace(&quot;    1&quot;), (&quot;1&quot;, &quot;    &quot;));
    }
}
</code></pre><p>Although this <em>does</em> indeed work, it involves quite a bit of repetition. What if we want a similar function for, say, extracting variable names? Instead of copy-pasting <code>extract_digits</code> yet again, we can define a <code>take_while</code> function with the following signature:</p><pre><code class=language-rust>fn take_while(accept: impl Fn(char) -&gt; bool, s: &amp;str) -&gt; (&amp;str, &amp;str)
</code></pre><p><code>take_while</code> takes a function called <code>accept</code> that determines whether to accept a given character or not. Once it encounters a character that is not accepted, it stops consuming characters and returns.</p><pre><code class=language-rust>pub(crate) fn take_while(accept: impl Fn(char) -&gt; bool, s: &amp;str) -&gt; (&amp;str, &amp;str) {
    let extracted_end = s
        .char_indices()
        .find_map(|(idx, c)| if accept(c) { None } else { Some(idx) })
        .unwrap_or_else(|| s.len());

    let extracted = &amp;s[..extracted_end];
    let remainder = &amp;s[extracted_end..];
    (remainder, extracted)
}
</code></pre><p>We can now redefine <code>extract_digits</code> and <code>extract_whitespace</code> in terms of <code>take_while</code>:</p><pre><code class=language-rust>pub(crate) fn extract_digits(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    take_while(|c| c.is_ascii_digit(), s)
}

pub(crate) fn extract_whitespace(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    take_while(|c| c == ' ', s)
}
</code></pre><p>And our tests still pass!</p><p>To actually allow whitespace inside expressions, we can call <code>extract_whitespace</code> while throwing away the output:</p><pre><code class=language-rust>// lib.rs

impl Expr {
    pub fn new(s: &amp;str) -&gt; (&amp;str, Self) {
        let (s, lhs) = Number::new(s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, op) = Op::new(s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, rhs) = Number::new(s);

        (s, Self { lhs, rhs, op })
    }
}

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_expr_with_whitespace() {
        assert_eq!(
            Expr::new(&quot;2 * 2&quot;),
            (
                &quot;&quot;,
                Expr {
                    lhs: Number(2),
                    rhs: Number(2),
                    op: Op::Mul,
                },
            ),
        );
    }
}
</code></pre><p>Note that we aren’t using <code>let _ = utils::extract_whitespace(s)</code>, as that would throw away the <code>s</code> that we get back, thereby not progressing through the input. Instead, by using <code>let (s, _) = ...</code> we keep advancing, but throw away the actual whitespace we extracted.</p><p>In the next post, Eldiro will gain the ability to create variables. This involves both parsing, as well as the beginnings of an interpreter.</p></main><nav class=page-navigation><div class=prev><p class=hint>Previously</p><a href=https://arzg.github.io/lang/1/>Part One: A Basic Parser</a></div><div class=next><p class=hint>Next up</p><a href=https://arzg.github.io/lang/3/>Part Three: Defining Variables</a></div><div style=clear:both></div></nav></body></html>