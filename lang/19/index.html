<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Part Nineteen: Code Representations · arzg’s website</title><link rel=stylesheet href=https://arzg.github.io/scss/main.04c23afe51262a10ee61829da41f4d7318ff311ed0d0bcbf1db0fde96e3830f4.css integrity="sha256-BMI6/lEmKhDuYYKdpB9Ncxj/MR7Q0Ly/HbD96W44MPQ="><script src=https://unpkg.com/quicklink@2.0.0/dist/quicklink.umd.js></script>
<script src=https://unpkg.com/anchor-js@4.3.1/anchor.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/plugins/autoloader/prism-autoloader.min.js></script>
<script>window.onload=()=>{quicklink.listen()},document.addEventListener("DOMContentLoaded",function(a){anchors.add("main h1")})</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body><nav class=site-navigation><ul><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li class=current><a href=/lang/>Make A Language</a></li></ul></nav><header class=header-area><h1 class=title>Part Nineteen: Code Representations</h1><section class=page-info><ul><li>24 January 2021</li><li>4411 words</li><li>22 minute read</li></ul></section></header><main><p>So far we have only used two different data structures to represent code:</p><ul><li>abstract syntax trees</li><li>concrete syntax trees</li></ul><p>An <em>abstract syntax tree</em> is a data structure that represents the bare minimum about a chunk of code. We used ASTs in the early parts of this series prior to the Rowan rewrite. For example, here’s an AST that represents variable definitions:</p><pre><code class=language-rust>struct VariableDef {
    name: String,
    value: Expr,
}

enum Expr {
    // snip
}
</code></pre><p>Note how it doesn’t include the <code>let</code> token or the <code>=</code>, and ignores trivia like whitespace and comments; it’s <em>abstract,</em> and only contains the information necessary to implement, say, a compiler. Although this makes them convenient to work with, it also prevents us from implementing some IDE features on top of them.</p><p>Automatic refactorings are a good example. How are meant to implement a feature that relies on knowing and being able to modify source code when we don’t know the exact text of the code being analysed?</p><p><em>Concrete syntax trees,</em> on the other hand, include the text of the source code in full. We’ve used CSTs whenever we’ve used Rowan, as the trees it produces can reproduce the text they were created from. Here’s a CST (in this case from Rowan) that represents a binary expression:</p><pre><code>Root@0..5
  InfixExpr@0..5
    Literal@0..2
      Number@0..1 &quot;1&quot;
      Whitespace@1..2 &quot; &quot;
    Plus@2..3 &quot;+&quot;
    Whitespace@3..4 &quot; &quot;
    Literal@4..5
      Number@4..5 &quot;1&quot;
</code></pre><p>It includes the entire input, whitespace and all. An interesting feature of Rowan’s CSTs is that they are <em>untyped,</em> meaning that nodes of differing kinds (e.g. <code>VariableDef</code> and <code>InfixExpr</code>) have the same type &ndash; <code>SyntaxNode</code>. Although this means we can implement features that don’t depend on node kinds more easily than we could otherwise,<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> it also means that more complex analysis on Rowan CSTs is painful, since we need to call <code>.kind()</code> whenever we want to know a node’s kind. We wouldn’t have to do this if nodes of different kinds had different types.</p><p>Programming language implementations that use Rowan usually include a typed layer on top of the CST for analysis purposes. Confusingly, this layer is called an AST in spite of its knowledge of the full input text, since it uses an unmodified Rowan CST under the hood. Here’s an example of what one for binary expressions might look like:</p><pre><code class=language-rust>struct BinaryExpr(SyntaxNode);

impl BinaryExpr {
    fn lhs(&amp;self) -&gt; Option&lt;Expr&gt; {
        // do stuff to extract the left-hand side
    }

    fn rhs(&amp;self) -&gt; Option&lt;Expr&gt; {
        // do stuff to extract the right-hand side
    }

    fn op(&amp;self) -&gt; Option&lt;BinaryOp&gt; {
        // do stuff to extract the operator
    }
}
</code></pre><p>Note how all these methods return <code>Option</code>s &ndash; this is because the parser supports error recovery and allows incomplete trees; as such, these methods cannot be sure that the thing they are trying to extract is actually present.</p><p>Note also how the API provided by this is similar to the simple <code>struct</code> from earlier, with the distinction that components are accessed through methods that return <code>Option</code>, rather than non-optional fields.</p><p>Finally, programming language implementations with Rowan usually include one more, higher-level representation: the <em>high-level intermediate representation,</em> or HIR. These are equivalent to the classical ASTs that we used before the rewrite. For comparison, here’s what a HIR data structure that represents binary expressions could look like:</p><pre><code class=language-rust>struct BinaryExpr {
    lhs: Option&lt;Expr&gt;,
    rhs: Option&lt;Expr&gt;,
    op: Option&lt;BinaryOp&gt;,
}
</code></pre><p>HIRs can make it easier to implement the parts of a programming language that don’t have to worry about original source code text, because this very property &ndash; the ability to differ from the original input &ndash; allows for the use of <em>lowering.</em></p><p>Lowering is the process of changing syntactic sugar, or shorthand, into its lower-level form. For example, a <code>while</code> loop is syntactic sugar for a <code>loop</code> with an <code>if</code> statement:</p><pre><code class=language-rust>while !should_exit() {
    handle_connection();
}

// is sugar for

loop {
    if should_exit() {
        break;
    }

    handle_connection();
}
</code></pre><p>Imagine you’re implementing a Rust type checker &ndash; if you don’t lower <code>while</code> loops, you need to worry about type-checking both <code>loop</code> statements and <code>while</code> loops. However, if you lower <code>while</code> loops into <code>loop</code> statements, you’d only have to implement type-checking for <code>loop</code>. The same principle can be applied to lots of other components of programming language tooling.</p><p>Lowering isn’t possible with a Rowan AST, as it has to represent the input text losslessly. It <em>is</em> possible with a HIR, though, since they don’t have to correspond with the input text.</p><p>Eldiro will use three different code representations:</p><ul><li>CST (Rowan), constructed during parsing</li><li>AST (typed layer on top of untyped CST) for anything that needs to deal with source code directly (e.g. refactorings)</li><li>HIR (abstract, lowered representation) for everything else</li></ul><h1 id=implementing-an-ast>Implementing an AST</h1><p>Although we could stick this in an existing crate, it doesn’t really belong in any of them. Let’s create a new one:</p><pre><code class=language-->$ cargo new --lib crates/ast
     Created library `crates/ast` package
</code></pre><p>This crate will need to use <code>SyntaxNode</code> from the <code>syntax</code> crate, so we’ll add that as a dependency:</p><pre><code class=language-toml># crates/ast/Cargo.toml

[dependencies]
syntax = {path = &quot;../syntax&quot;}
</code></pre><p>Let’s start by writing the skeleton of a variable definition’s AST node:</p><pre><code class=language-rust>// lib.rs

use syntax::SyntaxNode;

#[derive(Debug)]
pub struct VariableDef(SyntaxNode);

impl VariableDef {
    pub fn name(&amp;self) -&gt; Option&lt;?&gt; {
        todo!()
    }

    pub fn value(&amp;self) -&gt; Option&lt;?&gt; {
        todo!()
    }
}
</code></pre><p>Let’s look at a typical <code>VariableDef</code> CST to remind us of its structure:</p><pre><code>Root@0..13
  VariableDef@0..13
    LetKw@0..3 &quot;let&quot;
    Whitespace@3..4 &quot; &quot;
    Ident@4..7 &quot;foo&quot;
    Whitespace@7..8 &quot; &quot;
    Equals@8..9 &quot;=&quot;
    Whitespace@9..10 &quot; &quot;
    VariableRef@10..13
      Ident@10..13 &quot;bar&quot;
</code></pre><p>We would want <code>VariableDef::name</code> to return that <code>Ident</code>, a token, not a node, and <code>VariableDef::value</code> should return the <code>VariableRef</code> node. We have a type for nodes from the Rowan syntax tree &ndash; <code>SyntaxNode</code>. We don’t have a type for tokens from the Rowan CST though; let’s create that now:</p><pre><code class=language-rust>// crates/syntax/src/lib.rs

pub type SyntaxNode = rowan::SyntaxNode&lt;EldiroLanguage&gt;;
pub type SyntaxToken = rowan::SyntaxToken&lt;EldiroLanguage&gt;;
</code></pre><p>We can now fill in those missing types from the AST:</p><pre><code class=language-rust>// crates/ast/src/lib.rs

use syntax::{SyntaxNode, SyntaxToken};

// snip

impl VariableDef {
    pub fn name(&amp;self) -&gt; Option&lt;SyntaxToken&gt; {
        todo!()
    }

    pub fn value(&amp;self) -&gt; Option&lt;SyntaxNode&gt; {
        todo!()
    }
}
</code></pre><p>To determine a <code>VariableDef</code>’s name, we would want to iterate over its child tokens, stoping at the first one whose kind is <code>Ident</code>. Rowan doesn’t give us a way to iterate over only the child tokens of a node, so we’ll iterate over the tokens <em>and</em> nodes (known to Rowan as <code>SyntaxElement</code>s), filtering out the nodes:</p><pre><code class=language-rust>use syntax::{SyntaxKind, SyntaxNode, SyntaxToken};

// snip

impl VariableDef {
    pub fn name(&amp;self) -&gt; Option&lt;SyntaxToken&gt; {
        self.0
            .children_with_tokens()
            .filter_map(SyntaxElement::into_token)
            .find(|token| token.kind() == SyntaxKind::Ident)
    }

    // snip
}
</code></pre><p>We need to define our own version of <code>SyntaxElement</code>:</p><pre><code class=language-rust>// crates/syntax/src/lib.rs

pub type SyntaxNode = rowan::SyntaxNode&lt;EldiroLanguage&gt;;
pub type SyntaxToken = rowan::SyntaxToken&lt;EldiroLanguage&gt;;
pub type SyntaxElement = rowan::SyntaxElement&lt;EldiroLanguage&gt;;
</code></pre><p>And import it from <code>ast</code>:</p><pre><code class=language-rust>// crates/ast/src/lib.rs

use syntax::{SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken};
</code></pre><p>Let’s define <code>VariableDef::value</code> by finding the first child node that is an expression. For this we can use the non-existent <code>Expr::cast</code> function:</p><pre><code class=language-rust>impl VariableDef {
    // snip

    pub fn value(&amp;self) -&gt; Option&lt;Expr&gt; {
        self.0.children().find_map(Expr::cast)
    }
}

</code></pre><p>To continue we have to define <code>Expr</code>:</p><pre><code class=language-rust>#[derive(Debug)]
pub enum Expr {
    BinaryExpr(BinaryExpr),
    Literal(Literal),
    ParenExpr(ParenExpr),
    UnaryExpr(UnaryExpr),
    VariableRef(VariableRef),
}
</code></pre><p>Let’s define each of its variant types:</p><pre><code class=language-rust>#[derive(Debug)]
pub struct BinaryExpr(SyntaxNode);

#[derive(Debug)]
pub struct Literal(SyntaxNode);

#[derive(Debug)]
pub struct ParenExpr(SyntaxNode);

#[derive(Debug)]
pub struct UnaryExpr(SyntaxNode);

#[derive(Debug)]
pub struct VariableRef(SyntaxNode);
</code></pre><p>The only remaining compile error is <code>Expr::cast</code>, which we can define:</p><pre><code class=language-rust>impl Expr {
    pub fn cast(node: SyntaxNode) -&gt; Option&lt;Self&gt; {
        let result = match node.kind() {
            SyntaxKind::InfixExpr =&gt; Self::BinaryExpr(BinaryExpr(node)),
            SyntaxKind::Literal =&gt; Self::Literal(Literal(node)),
            SyntaxKind::ParenExpr =&gt; Self::ParenExpr(ParenExpr(node)),
            SyntaxKind::PrefixExpr =&gt; Self::UnaryExpr(UnaryExpr(node)),
            SyntaxKind::VariableRef =&gt; Self::VariableRef(VariableRef(node)),
            _ =&gt; return None,
        };

        Some(result)
    }
}
</code></pre><p>We’re still missing an AST node, namely <code>Stmt</code>. Its definition is similar to <code>Expr</code>’s:</p><pre><code class=language-rust>#[derive(Debug)]
pub enum Stmt {
    VariableDef(VariableDef),
    Expr(Expr),
}

impl Stmt {
    pub fn cast(node: SyntaxNode) -&gt; Option&lt;Self&gt; {
        let result = match node.kind() {
            SyntaxKind::VariableDef =&gt; Self::VariableDef(VariableDef(node)),
            _ =&gt; Self::Expr(Expr::cast(node)?),
        };

        Some(result)
    }
}
</code></pre><p>Next, let’s add methods to <code>BinaryExpr</code> to extract the left-hand side, right-hand side and operator:</p><pre><code class=language-rust>impl BinaryExpr {
    pub fn lhs(&amp;self) -&gt; Option&lt;Expr&gt; {
        self.0.children().find_map(Expr::cast)
    }

    pub fn rhs(&amp;self) -&gt; Option&lt;Expr&gt; {
        self.0.children().filter_map(Expr::cast).nth(1)
    }

    pub fn op(&amp;self) -&gt; Option&lt;SyntaxToken&gt; {
        self.0
            .children_with_tokens()
            .filter_map(SyntaxElement::into_token)
            .find(|token| {
                matches!(
                    token.kind(),
                    SyntaxKind::Plus | SyntaxKind::Minus | SyntaxKind::Star | SyntaxKind::Slash,
                )
            })
    }
}
</code></pre><p><code>UnaryExpr</code> also needs equivalents of these:</p><pre><code class=language-rust>impl UnaryExpr {
    pub fn expr(&amp;self) -&gt; Option&lt;Expr&gt; {
        self.0.children().find_map(Expr::cast)
    }

    pub fn op(&amp;self) -&gt; Option&lt;SyntaxToken&gt; {
        self.0
            .children_with_tokens()
            .filter_map(SyntaxElement::into_token)
            .find(|token| token.kind() == SyntaxKind::Minus)
    }
}
</code></pre><p>And <code>ParenExpr</code> could use a method that extracts the contained expression:</p><pre><code class=language-rust>impl ParenExpr {
    pub fn expr(&amp;self) -&gt; Option&lt;Expr&gt; {
        self.0.children().find_map(Expr::cast)
    }
}
</code></pre><p><code>VariableRef</code> and <code>Literal</code> too:</p><pre><code class=language-rust>use smol_str::SmolStr;
use syntax::{SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken};

impl Literal {
    pub fn parse(&amp;self) -&gt; u64 {
        self.0.first_token().unwrap().text().parse().unwrap()
    }
}

// snip

impl VariableRef {
    pub fn name(&amp;self) -&gt; SmolStr {
        self.0.first_token().unwrap().text().clone()
    }
}
</code></pre><p>Let’s add the missing <code>smol_str</code> dependency:</p><pre><code class=language-toml># Cargo.toml

[dependencies]
smol_str = &quot;0.1.17&quot;
syntax = {path = &quot;../syntax&quot;}
</code></pre><p>Finally, we need to define the root of the AST:</p><pre><code class=language-rust>#[derive(Debug)]
pub struct Root(SyntaxNode);

impl Root {
    pub fn cast(node: SyntaxNode) -&gt; Option&lt;Self&gt; {
        if node.kind() == SyntaxKind::Root {
            Some(Self(node))
        } else {
            None
        }
    }
}
</code></pre><p>For any other code to be able to interact with the contents of <code>Root</code>, it needs to have methods that make its contents accessible. Since the parser currently consumes multiple statements, so we can make those available:</p><pre><code class=language-rust>impl Root {
    // snip

    pub fn stmts(&amp;self) -&gt; impl Iterator&lt;Item = Stmt&gt; {
        self.0.children().filter_map(Stmt::cast)
    }
}
</code></pre><p>Let’s try this code out by printing the value of any variable definition we might see in the syntax tree when in the REPL:</p><pre><code class=language-rust>// crates/parser/src/lib.rs

impl Parse {
    pub fn debug_tree(&amp;self) -&gt; String {
        let mut s = String::new();

        let tree = format!(&quot;{:#?}&quot;, self.syntax());

        // snip
    }

    pub fn syntax(&amp;self) -&gt; SyntaxNode {
        SyntaxNode::new_root(self.green_node.clone())
    }
}
</code></pre><pre><code class=language-rust>// crates/eldiro/src/main.rs

fn main() -&gt; io::Result&lt;()&gt; {
    // snip

    loop {
        // snip

        let parse = parse(&amp;input);
        println!(&quot;{}&quot;, parse.debug_tree());

        let root = ast::Root::cast(parse.syntax()).unwrap();

        dbg!(root
            .stmts()
            .filter_map(|stmt| if let ast::Stmt::VariableDef(var_def) = stmt {
                Some(var_def.value())
            } else {
                None
            })
            .collect::&lt;Vec&lt;_&gt;&gt;());

        // snip
    }
}

</code></pre><p>The REPL now has to depend on <code>ast</code>:</p><pre><code class=language-toml># Cargo.toml

[dependencies]
ast = {path = &quot;../ast&quot;}
parser = {path = &quot;../parser&quot;}
</code></pre><p>We can now run the REPL:</p><pre><code class=language-->$ cargo r -q
→ let one = 1 let two = one + one
# snip
[
    Some(
        Literal(
            Literal(
                Literal@10..12
                  Number@10..11 &quot;1&quot;
                  Whitespace@11..12 &quot; &quot;
                ,
            ),
        ),
    ),
    Some(
        BinaryExpr(
            BinaryExpr(
                InfixExpr@22..32
                  VariableRef@22..26
                    Ident@22..25 &quot;one&quot;
                    Whitespace@25..26 &quot; &quot;
                  Plus@26..27 &quot;+&quot;
                  Whitespace@27..28 &quot; &quot;
                  VariableRef@28..32
                    Ident@28..31 &quot;one&quot;
                    Whitespace@31..32 &quot;\n&quot;
                ,
            ),
        ),
    ),
]
</code></pre><p>It’s extracted that <code>1</code> literal from the first variable, as well as the binary expression from the second variable.</p><p>Note how each of the two expressions our REPL is printing out is wrapped in a <code>Some</code> &ndash; this is because it’s possible for a variable definition to not have a value. Although this isn’t allowed by the language, it still happens because the parser recovers from the error and marches on. Let’s see if we get a <code>None</code> when we type in a variable definition that’s missing a value:</p><pre><code class=language-->→ let a = let b = 1 let c =
# snip
[
    None,
    Some(
        Literal(
            Literal(
                Literal@16..18
                  Number@16..17 &quot;1&quot;
                  Whitespace@17..18 &quot; &quot;
                ,
            ),
        ),
    ),
    None,
]
</code></pre><p>As expected, since the first and last variable definitions are missing values, we get <code>None</code>, <code>Some</code> and <code>None</code>.</p><h1 id=implementing-a-hir>Implementing a HIR</h1><p>Now that we have completed the implementation of a lossless AST, we can move on to implementing a HIR. In case you’ve forgotten, a HIR is a lowered, abstract representation of code that doesn’t include syntactic details and doesn’t have to match the input text exactly. As with the AST, we’ll start by letting Cargo generate a new crate for us:</p><pre><code class=language-->$ cargo new --lib crates/hir
     Created library `crates/hir` package
</code></pre><p>Let’s start with statements and variable definitions:</p><pre><code class=language-rust>// crates/hir/src/lib.rs

use smol_str::SmolStr;

#[derive(Debug)]
pub enum Stmt {
    VariableDef { name: SmolStr, value: Expr },
    Expr(Expr),
}
</code></pre><pre><code class=language-toml># Cargo.toml

[dependencies]
smol_str = &quot;0.1.17&quot;
</code></pre><p>Next we’ll define <code>Expr</code>:</p><pre><code class=language-rust>#[derive(Debug)]
pub enum Expr {
    Binary { op: BinaryOp, lhs: Self, rhs: Self },
    Literal { n: u64 },
    Unary { op: UnaryOp, expr: Self },
    VariableRef { var: SmolStr },
}

#[derive(Debug)]
pub enum BinaryOp {
    Add,
    Sub,
    Mul,
    Div,
}

#[derive(Debug)]
pub enum UnaryOp {
    Neg,
}
</code></pre><p>We now have the same problem as we had in <a href=/lang/8>Part Eight</a>; namely, we have a type that contains itself, and thus has an infinite size. We can fix this by wrapping all recursive usages of <code>Expr</code> in <code>Box</code>, which has a fixed size. This eliminates the recursion:</p><pre><code class=language-rust>#[derive(Debug)]
pub enum Expr {
    Binary {
        op: BinaryOp,
        lhs: Box&lt;Self&gt;,
        rhs: Box&lt;Self&gt;,
    },
    Literal {
        n: u64,
    },
    Unary {
        op: UnaryOp,
        expr: Box&lt;Self&gt;,
    },
    VariableRef {
        var: SmolStr,
    },
}
</code></pre><p>This HIR is missing a critical component of our Rowan-based AST: the ability to represent incorrect parser inputs. We <em>could</em> represent the possibility of, say, a binary expression missing its right-hand side by wrapping <code>rhs</code> in an <code>Option</code>. We’d have to do this at every usage of <code>Expr</code>, though. Instead, we’ll add a <code>Missing</code> variant to <code>Expr</code>, so all usages of <code>Expr</code> are effectively optional:</p><pre><code class=language-rust>#[derive(Debug)]
pub enum Expr {
    Missing,
    // snip
}
</code></pre><p>There’s only one other part of the HIR that can be missing from the AST: <code>VariableDef</code>’s <code>name</code> field. A <code>VariableDef</code> node can be missing a name when the user has only typed the <code>let</code> keyword, since <code>let</code> is enough to trigger the creation of a <code>VariableDef</code>. In spite of this, we shouldn’t make <code>name</code> optional, because the HIR is used for features like type inference and IDE indexing that rely on the presence of names. If we made names optional, we’d have to handle the case where they don’t exist again and again.</p><p>Now that the HIR’s basic data structures are in place, we can implement lowering:</p><pre><code class=language-toml># Cargo.toml

[dependencies]
ast = {path = &quot;../ast&quot;}
smol_str = &quot;0.1.17&quot;
syntax = {path = &quot;../syntax&quot;}
</code></pre><pre><code class=language-rust>// lib.rs

use smol_str::SmolStr;
use syntax::SyntaxKind;

// snip

impl Stmt {
    fn lower(ast: ast::Stmt) -&gt; Option&lt;Self&gt; {
        let result = match ast {
            ast::Stmt::VariableDef(ast) =&gt; Self::VariableDef {
                name: ast.name()?.text().clone(),
                value: Expr::lower(ast.value()),
            },
            ast::Stmt::Expr(ast) =&gt; Self::Expr(Expr::lower(Some(ast))),
        };

        Some(result)
    }
}

// snip

impl Expr {
    fn lower(ast: Option&lt;ast::Expr&gt;) -&gt; Self {
        if let Some(ast) = ast {
            match ast {
                ast::Expr::BinaryExpr(ast) =&gt; Self::lower_binary(ast),
                ast::Expr::Literal(ast) =&gt; Self::Literal { n: ast.parse() },
                ast::Expr::ParenExpr(ast) =&gt; Expr::lower(ast.expr()),
                ast::Expr::UnaryExpr(ast) =&gt; Self::lower_unary(ast),
                ast::Expr::VariableRef(ast) =&gt; Self::VariableRef { var: ast.name() },
            }
        } else {
            Self::Missing
        }
    }

    fn lower_binary(ast: ast::BinaryExpr) -&gt; Self {
        let op = match ast.op().unwrap().kind() {
            SyntaxKind::Plus =&gt; BinaryOp::Add,
            SyntaxKind::Minus =&gt; BinaryOp::Sub,
            SyntaxKind::Star =&gt; BinaryOp::Mul,
            SyntaxKind::Slash =&gt; BinaryOp::Div,
            _ =&gt; unreachable!(),
        };

        Self::Binary {
            op,
            lhs: Box::new(Expr::lower(ast.lhs())),
            rhs: Box::new(Expr::lower(ast.rhs())),
        }
    }

    fn lower_unary(ast: ast::UnaryExpr) -&gt; Self {
        let op = match ast.op().unwrap().kind() {
            SyntaxKind::Minus =&gt; UnaryOp::Neg,
            _ =&gt; unreachable!(),
        };

        Self::Unary {
            op,
            expr: Box::new(Expr::lower(ast.expr())),
        }
    }
}
</code></pre><p>All that’s left to do for lowering is to write a <code>lower</code> function that takes the root of an AST, and lowers it to a <code>Vec&lt;Stmt></code>:</p><pre><code class=language-rust>pub fn lower(ast: ast::Root) -&gt; impl Iterator&lt;Item = Stmt&gt; {
    ast.stmts().filter_map(Stmt::lower)
}
</code></pre><p>Let’s try lowering out by making the REPL print all HIR elements it can find in the input:</p><pre><code class=language-toml># crates/eldiro/Cargo.toml

[dependencies]
ast = {path = &quot;../ast&quot;}
hir = {path = &quot;../hir&quot;}
parser = {path = &quot;../parser&quot;}
</code></pre><pre><code class=language-rust>// crates/eldiro/src/main.rs

fn main() -&gt; io::Result&lt;()&gt; {
    // snip

    loop {
        // snip

        let root = ast::Root::cast(parse.syntax()).unwrap();

        dbg!(/* snip */);

        dbg!(hir::lower(root).collect::&lt;Vec&lt;_&gt;&gt;());

        // snip
    }
}
</code></pre><pre><code class=language-->$ cargo r -q
→ let a = 10
# snip
[
    VariableDef {
        name: &quot;a&quot;,
        value: Literal {
            n: 10,
        },
    },
]
→ 5 + a * 100
# snip
[
    Expr(
        Binary {
            op: Add,
            lhs: Literal {
                n: 5,
            },
            rhs: Binary {
                op: Mul,
                lhs: VariableRef {
                    var: &quot;a&quot;,
                },
                rhs: Literal {
                    n: 100,
                },
            },
        },
    ),
]
</code></pre><h1 id=migrating-to-an-arena>Migrating to an arena</h1><p>We currently use <code>Box</code> to add indirection where <code>Expr</code> recurses. Let’s take a look at the layout of <code>Expr</code> in memory:</p><p><img src=box.svg alt="A visualisation of Expr’s layout in memory"></p><p>Each of those arrows is a pointer to another location in memory, one that could be far away; there is a significant chance that the HIR elements are spread out across the heap. This is bad for performance, because it means the CPU can’t keep them all in the cache at the same time.</p><p>We can instead store each <code>Expr</code> in a <code>Vec</code>, and index into this <code>Vec</code> instead of using <code>Box</code>es to reference the subtrees. Here’s a visualisation of the same <code>Expr</code>’s memory layout with this setup:</p><p><img src=arena.svg alt="A visualisation of Expr’s memory layout when storing subtrees in a Vector"></p><p>Since <code>Vec</code>’s storage is contiguous, we know that each <code>Expr</code> will be right next to all the others, encouraging caching and increasing performance. A secondary benefit of this approach is that the indices into the <code>Vec</code> don’t necessarily have to be <code>usize</code>s &ndash; we could use <code>u32</code>s instead to save memory, since it’s unlikely we’ll have more than 2<sup>32</sup> &ndash; 1 = four billion <code>Expr</code> subtrees.</p><p>A <code>Vec</code> gives us too much control over the subtrees; all we want is to allocate another subtree, and get its index. Luckily, there is a data structure that does this job: the arena. There are <a href=https://docs.rs/typed-arena/>lots</a> <a href=https://docs.rs/id-arena>of</a> <a href=https://docs.rs/vec-arena>arena</a> <a href=https://docs.rs/slab>implementations</a> <a href=https://docs.rs/compact-arena>in</a> <a href=https://docs.rs/trove>Rust</a>. Each one that I have seen has more complexity than the basic <code>Vec</code>-like structure I described earlier. In some cases this is to allow the allocation of more than <code>usize::MAX</code> elements; in other cases the complexity allows removing elements one by one without invalidating existing indexes; in others still, it allows customisation of the index type (e.g. <code>usize</code>).</p><p>Let’s write our own, as-simple-as-possible arena implementation. We’ll start with a new crate:</p><pre><code class=language-->$ cargo new --lib crates/arena
     Created library `crates/arena` package
</code></pre><pre><code class=language-rust>// crates/arena/src/lib.rs

#[derive(Debug)]
pub struct Arena&lt;T&gt; {
    data: Vec&lt;T&gt;,
}
</code></pre><p>We need methods to create new arenas and to allocate values on the arena:</p><pre><code class=language-rust>impl&lt;T&gt; Default for Arena&lt;T&gt; {
    fn default() -&gt; Self {
        Self::new()
    }
}

impl&lt;T&gt; Arena&lt;T&gt; {
    pub fn new() -&gt; Self {
        Self { data: Vec::new() }
    }

    pub fn alloc(&amp;mut self, t: T) -&gt; usize {
        let idx = self.next_idx();
        self.data.push(t);

        idx
    }

    fn next_idx(&amp;self) -&gt; usize {
        self.data.len()
    }
}
</code></pre><p>We also need to allow indexing into the arena to retrieve values:</p><pre><code class=language-rust>use std::ops::Index;

// snip

impl&lt;T&gt; Index&lt;usize&gt; for Arena&lt;T&gt; {
    type Output = T;

    fn index(&amp;self, idx: usize) -&gt; &amp;Self::Output {
        &amp;self.data[idx]
    }
}
</code></pre><p>Let’s employ that index size optimisation from earlier, where we use <code>u32</code>s for indexes instead of <code>usize</code>s:</p><pre><code class=language-rust>impl&lt;T&gt; Arena&lt;T&gt; {
    // snip

    pub fn alloc(&amp;mut self, t: T) -&gt; u32 {
        let idx = self.next_idx();
        self.data.push(t);

        idx
    }

    fn next_idx(&amp;self) -&gt; u32 {
        self.data.len() as u32
    }
}

impl&lt;T&gt; Index&lt;u32&gt; for Arena&lt;T&gt; {
    type Output = T;

    fn index(&amp;self, idx: u32) -&gt; &amp;Self::Output {
        &amp;self.data[idx as usize]
    }
}
</code></pre><p>We’ve created a new problem for ourselves by doing this, though: when reading code, <code>usize</code>s are often used as indexes, so we can be reasonably sure what their purpose is. However, now that we’re using <code>u32</code>s, it can get confusing &ndash; if you see</p><pre><code class=language-rust>// This is just an example; don’t write this!

struct BinaryExpr {
    lhs: u32,
    rhs: u32,
    op: BinaryOp,
}
</code></pre><p>in a codebase, it isn’t clear what the usage of that <code>u32</code> looks like. We can alleviate this problem by wrapping the <code>u32</code> in a <a href=https://doc.rust-lang.org/rust-by-example/generics/new_types.html>newtype</a>:</p><pre><code class=language-rust>#[derive(Debug)]
pub struct Idx {
    raw: u32,
}
</code></pre><p>We can replace all usages of <code>u32</code> with <code>Idx</code> and add a little bit of glue:</p><pre><code class=language-rust>impl&lt;T&gt; Arena&lt;T&gt; {
    // snip

    pub fn alloc(&amp;mut self, t: T) -&gt; Idx {
        let idx = self.next_idx();
        self.data.push(t);

        idx
    }

    fn next_idx(&amp;self) -&gt; Idx {
        Idx {
            raw: self.data.len() as u32,
        }
    }
}

impl&lt;T&gt; Index&lt;Idx&gt; for Arena&lt;T&gt; {
    type Output = T;

    fn index(&amp;self, idx: Idx) -&gt; &amp;Self::Output {
        &amp;self.data[idx.raw as usize]
    }
}
</code></pre><p>Let’s take a look at that example from earlier again with this change:</p><pre><code class=language-rust>// This is just an example; don’t write this!

struct BinaryExpr {
    lhs: Idx,
    rhs: Idx,
    op: BinaryOp,
}
</code></pre><p>It’s <em>better,</em> but it’s still unclear. What type do you get as a result of indexing? Let’s add a type parameter to <code>Idx</code> to improve this further:</p><pre><code class=language-rust>#[derive(Debug)]
pub struct Idx&lt;T&gt; {
    raw: u32,
    _phantom: PhantomData&lt;fn() -&gt; T&gt;,
}
</code></pre><p><code>PhantomData</code> is a way of telling the Rust compiler that, although this type may not actually use the <code>T</code> type parameter, it still should have the parameter and shouldn’t have an ‘unused type parameter’ error. We don’t use <code>PhantomData&lt;T></code> in this case, because that communicates to the compiler that <code>Idx</code> <em>owns</em> a <code>T</code>, which can affect <a href=https://doc.rust-lang.org/nomicon/dropck.html>drop check</a>. <code>PhantomData&lt;fn() -> T></code> avoids this.</p><p>Let’s update all of <code>Idx</code>’s usages:</p><pre><code class=language-rust>impl&lt;T&gt; Arena&lt;T&gt; {
    // snip

    pub fn alloc(&amp;mut self, t: T) -&gt; Idx&lt;T&gt; {
        let idx = self.next_idx();
        self.data.push(t);

        idx
    }

    fn next_idx(&amp;self) -&gt; Idx&lt;T&gt; {
        Idx {
            raw: self.data.len() as u32,
            _phantom: PhantomData,
        }
    }
}

impl&lt;T&gt; Index&lt;Idx&lt;T&gt;&gt; for Arena&lt;T&gt; {
    type Output = T;

    fn index(&amp;self, idx: Idx&lt;T&gt;) -&gt; &amp;Self::Output {
        &amp;self.data[idx.raw as usize]
    }
}
</code></pre><p>Now that our arena implementation is complete, we can make use of it in the HIR:</p><pre><code class=language-toml># crates/hir/Cargo.toml

[dependencies]
arena = {path = &quot;../arena&quot;}
ast = {path = &quot;../ast&quot;}
smol_str = &quot;0.1.17&quot;
syntax = {path = &quot;../syntax&quot;}
</code></pre><p>The first thing we need is a type to store the arena:</p><pre><code class=language-rust>// lib.rs

mod database;
pub use database::Database;
</code></pre><pre><code class=language-rust>// crates/hir/src/database.rs

use crate::Expr;
use arena::Arena;

#[derive(Debug, Default)]
pub struct Database {
    exprs: Arena&lt;Expr&gt;,
}
</code></pre><p>Let’s replace <code>Box&lt;Expr></code> with <code>Idx&lt;Expr></code>:</p><pre><code class=language-rust>// lib.rs

use arena::Idx;
use smol_str::SmolStr;
use syntax::SyntaxKind;

// snip

#[derive(Debug)]
pub enum Expr {
    Missing,
    Binary {
        op: BinaryOp,
        lhs: Idx&lt;Self&gt;,
        rhs: Idx&lt;Self&gt;,
    },
    Literal {
        n: u64,
    },
    Unary {
        op: UnaryOp,
        expr: Idx&lt;Self&gt;,
    },
    VariableRef {
        var: SmolStr,
    },
}
</code></pre><p>We can make this a little cleaner by creating a type alias for <code>Idx&lt;Expr></code>:</p><pre><code class=language-rust>type ExprIdx = Idx&lt;Expr&gt;;

// snip

#[derive(Debug)]
pub enum Expr {
    Missing,
    Binary {
        op: BinaryOp,
        lhs: ExprIdx,
        rhs: ExprIdx,
    },
    Literal {
        n: u64,
    },
    Unary {
        op: UnaryOp,
        expr: ExprIdx,
    },
    VariableRef {
        var: SmolStr,
    },
}
</code></pre><p>All the lowering methods need to take a <code>&mut Database</code> as a parameter:</p><pre><code class=language-rust>impl Stmt {
    fn lower(ast: ast::Stmt, db: &amp;mut Database) -&gt; Option&lt;Self&gt; {
        let result = match ast {
            ast::Stmt::VariableDef(ast) =&gt; Self::VariableDef {
                name: ast.name()?.text().clone(),
                value: Expr::lower(ast.value(), db),
            },
            ast::Stmt::Expr(ast) =&gt; Self::Expr(Expr::lower(Some(ast), db)),
        };

        Some(result)
    }
}

impl Expr {
    fn lower(ast: Option&lt;ast::Expr&gt;, db: &amp;mut Database) -&gt; Self {
        if let Some(ast) = ast {
            match ast {
                ast::Expr::BinaryExpr(ast) =&gt; Self::lower_binary(ast, db),
                // snip
                ast::Expr::ParenExpr(ast) =&gt; Expr::lower(ast.expr(), db),
                ast::Expr::UnaryExpr(ast) =&gt; Self::lower_unary(ast, db),
                // snip
            }
        } else {
            // snip
        }
    }

    fn lower_binary(ast: ast::BinaryExpr, db: &amp;mut Database) -&gt; Self {
        // snip

        Self::Binary {
            op,
            lhs: db.exprs.alloc(Expr::lower(ast.lhs(), db)),
            rhs: db.exprs.alloc(Expr::lower(ast.rhs(), db)),
        }
    }

    fn lower_unary(ast: ast::UnaryExpr, db: &amp;mut Database) -&gt; Self {
        // snip

        Self::Unary {
            op,
            expr: db.exprs.alloc(Expr::lower(ast.expr(), db)),
        }
    }
}
</code></pre><p>We’ve got a code smell here: we’re threading the same value through each and every method. This is a sign that these methods should be <code>impl</code>ed on the type of that value, which in this case is <code>&mut Database</code>. Let’s change the lowering code to be methods on <code>Database</code>:</p><pre><code class=language-rust>// database.rs

use crate::{BinaryOp, Expr, Stmt, UnaryOp};
use arena::Arena;
use syntax::SyntaxKind;

// snip

impl Database {
    pub(crate) fn lower_stmt(&amp;mut self, ast: ast::Stmt) -&gt; Option&lt;Stmt&gt; {
        let result = match ast {
            ast::Stmt::VariableDef(ast) =&gt; Stmt::VariableDef {
                name: ast.name()?.text().clone(),
                value: self.lower_expr(ast.value()),
            },
            ast::Stmt::Expr(ast) =&gt; Stmt::Expr(self.lower_expr(Some(ast))),
        };

        Some(result)
    }

    pub(crate) fn lower_expr(&amp;mut self, ast: Option&lt;ast::Expr&gt;) -&gt; Expr {
        if let Some(ast) = ast {
            match ast {
                ast::Expr::BinaryExpr(ast) =&gt; self.lower_binary(ast),
                ast::Expr::Literal(ast) =&gt; Expr::Literal { n: ast.parse() },
                ast::Expr::ParenExpr(ast) =&gt; self.lower_expr(ast.expr()),
                ast::Expr::UnaryExpr(ast) =&gt; self.lower_unary(ast),
                ast::Expr::VariableRef(ast) =&gt; Expr::VariableRef { var: ast.name() },
            }
        } else {
            Expr::Missing
        }
    }

    fn lower_binary(&amp;mut self, ast: ast::BinaryExpr) -&gt; Expr {
        let op = match ast.op().unwrap().kind() {
            SyntaxKind::Plus =&gt; BinaryOp::Add,
            SyntaxKind::Minus =&gt; BinaryOp::Sub,
            SyntaxKind::Star =&gt; BinaryOp::Mul,
            SyntaxKind::Slash =&gt; BinaryOp::Div,
            _ =&gt; unreachable!(),
        };

        Expr::Binary {
            op,
            lhs: self.exprs.alloc(self.lower_expr(ast.lhs())),
            rhs: self.exprs.alloc(self.lower_expr(ast.rhs())),
        }
    }

    fn lower_unary(&amp;mut self, ast: ast::UnaryExpr) -&gt; Expr {
        let op = match ast.op().unwrap().kind() {
            SyntaxKind::Minus =&gt; UnaryOp::Neg,
            _ =&gt; unreachable!(),
        };

        Expr::Unary {
            op,
            expr: self.exprs.alloc(self.lower_expr(ast.expr())),
        }
    }
}
</code></pre><p>Finally, we need to update <code>hir::lower</code> to call <code>Database::lower_stmt</code>:</p><pre><code class=language-rust>// lib.rs

pub fn lower(ast: ast::Root) -&gt; (Database, impl Iterator&lt;Item = Stmt&gt;) {
    let mut db = Database::default();
    (db, ast.stmts().filter_map(|stmt| db.lower_stmt(stmt)))
}
</code></pre><p>Note how we return the database so that the user of the function can use the otherwise-opaque arena indexes. This function doesn’t compile though, because returning the iterator means that the closure passed to <code>filter_map</code> won’t be run until the caller decides to consume the iterator. Rust can’t verify that <code>db</code> will still be alive when the closure is run, so it gives us an error. We can fix this by collecting the iterator to a <code>Vec</code>:</p><pre><code class=language-rust>pub fn lower(ast: ast::Root) -&gt; (Database, Vec&lt;Stmt&gt;) {
    let mut db = Database::default();
    let stmts = ast.stmts().filter_map(|stmt| db.lower_stmt(stmt)).collect();

    (db, stmts)
}
</code></pre><p>Next, we have several errors caused by borrowing mutably more than once at a time. These can be fixed by extracting the first mutable borrows to temporary variables:</p><pre><code class=language-rust>// database.rs

impl Database {
    // snip

    fn lower_binary(&amp;mut self, ast: ast::BinaryExpr) -&gt; Expr {
        // snip

        let lhs = self.lower_expr(ast.lhs());
        let rhs = self.lower_expr(ast.rhs());

        Expr::Binary {
            op,
            lhs: self.exprs.alloc(lhs),
            rhs: self.exprs.alloc(rhs),
        }
    }

    fn lower_unary(&amp;mut self, ast: ast::UnaryExpr) -&gt; Expr {
        // snip

        let expr = self.lower_expr(ast.expr());

        Expr::Unary {
            op,
            expr: self.exprs.alloc(expr),
        }
    }
}

</code></pre><p>The last remaining error stems from us trying to <code>collect</code> the result of <code>hir::lower</code> in the REPL. Let’s remove this:</p><pre><code class=language-rust>// crates/eldiro/src/main.rs

fn main() -&gt; io::Result&lt;()&gt; {
    // snip

    loop {
        // snip

        dbg!(hir::lower(root));

        input.clear();
    }
}
</code></pre><p>We also have an unused import that we should delete:</p><pre><code class=language-rust>// crates/hir/src/lib.rs

mod database;
pub use database::Database;

use arena::Idx;
use smol_str::SmolStr;
</code></pre><p>The arena we’ve created is very similar to la-arena, <a href=https://github.com/rust-analyzer/rust-analyzer/blob/cd532e615abdac766ce9110e02e197f674fce375/lib/arena/src/lib.rs>the arena used in rust-analyzer</a>, which is <a href=https://crates.io/crates/la-arena>published on crates.io</a>. In fact, la-arena’s implementation is essentially the same as ours, with a few more bells and whistles.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> Let’s delete our implementation, and use la-arena instead:</p><pre><code class=language-->$ rm -r crates/arena
</code></pre><pre><code class=language-toml># Cargo.toml

[dependencies]
ast = {path = &quot;../ast&quot;}
la-arena = &quot;0.2.0&quot;
smol_str = &quot;0.1.17&quot;
syntax = {path = &quot;../syntax&quot;}
</code></pre><pre><code class=language-rust>// lib.rs

mod database;
pub use database::Database;

use la_arena::Idx;
use smol_str::SmolStr;
</code></pre><pre><code class=language-rust>// database.rs

use crate::{BinaryOp, Expr, Stmt, UnaryOp};
use la_arena::Arena;
use syntax::SyntaxKind;
</code></pre><h1 id=conclusion>Conclusion</h1><p>I hope you’re enjoying the series; the next part will be a shorter one focusing on tests.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>An example here is Expand Selection.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>la-arena has more methods (such as <code>len</code> and <code>iter</code>), allows the creation of arbitrary <code>Idx</code> values, and has a customised <code>Debug</code> implementation that is easier to read.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></main><nav class=page-navigation><div class=prev><p class=hint>Previously</p><a href=https://arzg.github.io/lang/18/>Part Eighteen: Errors</a></div><div class=next><p class=hint>Next up</p><a href=https://arzg.github.io/lang/20/>Part Twenty: Testing</a></div><div style=clear:both></div></nav></body></html>