<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Part Eleven: Refinements · arzg’s website</title><link rel=stylesheet href=https://arzg.github.io/scss/main.b763c3746f235d1e84e23bc1b3d94a46534216d5bbae8ce5b8ae93e8c0816df3.css integrity="sha256-t2PDdG8jXR6E4jvBs9lKRlNCFtW7rozluK6T6MCBbfM="><script src=https://unpkg.com/quicklink@2.0.0/dist/quicklink.umd.js></script>
<script src=https://unpkg.com/anchor-js@4.3.1/anchor.min.js></script>
<script>window.onload=()=>{quicklink.listen()},document.addEventListener("DOMContentLoaded",function(a){anchors.add("main h1")})</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body><nav class=site-navigation><ul><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li class=current><a href=/lang/>Make A Language</a></li></ul></nav><header class=header-area><h1 class=title>Part Eleven: Refinements</h1><section class=page-info><ul><li>17 November 2020</li><li>929 words</li><li>five minute read</li></ul></section></header><main><p>We’ve got a number of topics to cover this time, so let’s get started.</p><h1 id=a-bug-fix>A bug fix</h1><p>u/mozjag <a href="https://www.reddit.com/r/rust/comments/ju1vhl/make_a_language_in_rust_part_ten_starting_again/gcc7rk8?utm_source=share&utm_medium=web2x&context=3">pointed out</a> on Reddit that the regex we’re using to lex identifiers mandates that they have a length of two, when we could also allow identifiers with a single character. Let’s write a test for lexing a single-letter identifier to verify the bug is actually present:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// lexer.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_single_char_identifier</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;x&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><pre tabindex=0><code class=language-- data-lang=->$ cargo t -q
running 21 tests
..............F......
failures:

---- lexer::tests::lex_single_char_identifier stdout ----
thread 'lexer::tests::lex_single_char_identifier' panicked at 'assertion failed: `(left == right)`
  left: `Some((Error, &quot;x&quot;))`,
 right: `Some((Ident, &quot;x&quot;))`', crates/eldiro/src/lexer.rs:78:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    lexer::tests::lex_single_char_identifier

test result: FAILED. 20 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>We need to change the <code>+</code> in the <code>Ident</code> regex to be a <code>*</code> instead, so that <em>zero or more</em> repetitions are allowed instead of <em>one or more:</em></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(Debug, Copy, Clone, PartialEq, Logos, FromPrimitive, ToPrimitive)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>enum</span> <span class=nc>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[regex(</span><span class=s>&#34;[A-Za-z][A-Za-z0-9]*&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>Ident</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><pre tabindex=0><code class=language-- data-lang=->$ cargo t -q
.....................
test result: ok. 21 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><h1 id=negation>Negation</h1><p>Up to now, all the operators we support have been <em>binary,</em> meaning that they have two operands. We’d like to have <em>unary</em> operators too, which are operators that have one operand. The operator we’ll add here is the prefix unary minus, as used for negation &ndash; the <code>-</code> in <code>-10</code>, for example. To start, we’ll need another node type:<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(Debug, Copy, Clone, PartialEq, Logos, FromPrimitive, ToPrimitive)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>enum</span> <span class=nc>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=n>Root</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>BinOp</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>PrefixExpr</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Let’s rename <code>BinOp</code> to <code>BinaryExpr</code> for consistency (after all, we aren’t abbreviating <code>Prefix</code>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(Debug, Copy, Clone, PartialEq, Logos, FromPrimitive, ToPrimitive)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>enum</span> <span class=nc>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=n>Root</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>BinaryExpr</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>PrefixExpr</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// expr.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>expr_binding_power</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Parser</span><span class=p>,</span><span class=w> </span><span class=n>minimum_binding_power</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=c1>// snip
</span><span class=c1></span><span class=w>        </span><span class=n>p</span><span class=p>.</span><span class=n>start_node_at</span><span class=p>(</span><span class=n>checkpoint</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>BinaryExpr</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=c1>// snip
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_simple_binary_expression</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;1+2&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;
</span><span class=s>Root@0..3
</span><span class=s>  BinaryExpr@0..3
</span><span class=s>    Number@0..1 &#34;1&#34;
</span><span class=s>    Plus@1..2 &#34;+&#34;
</span><span class=s>    Number@2..3 &#34;2&#34;&#34;#</span><span class=p>]],</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_left_associative_binary_expression</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;1+2+3+4&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;
</span><span class=s>Root@0..7
</span><span class=s>  BinaryExpr@0..7
</span><span class=s>    BinaryExpr@0..5
</span><span class=s>      BinaryExpr@0..3
</span><span class=s>        Number@0..1 &#34;1&#34;
</span><span class=s>        Plus@1..2 &#34;+&#34;
</span><span class=s>        Number@2..3 &#34;2&#34;
</span><span class=s>      Plus@3..4 &#34;+&#34;
</span><span class=s>      Number@4..5 &#34;3&#34;
</span><span class=s>    Plus@5..6 &#34;+&#34;
</span><span class=s>    Number@6..7 &#34;4&#34;&#34;#</span><span class=p>]],</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_binary_expression_with_mixed_binding_power</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;1+2*3-4&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;
</span><span class=s>Root@0..7
</span><span class=s>  BinaryExpr@0..7
</span><span class=s>    BinaryExpr@0..5
</span><span class=s>      Number@0..1 &#34;1&#34;
</span><span class=s>      Plus@1..2 &#34;+&#34;
</span><span class=s>      BinaryExpr@2..5
</span><span class=s>        Number@2..3 &#34;2&#34;
</span><span class=s>        Star@3..4 &#34;*&#34;
</span><span class=s>        Number@4..5 &#34;3&#34;
</span><span class=s>    Minus@5..6 &#34;-&#34;
</span><span class=s>    Number@6..7 &#34;4&#34;&#34;#</span><span class=p>]],</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>We can write a test for parsing an expression with the negation operator:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_negation</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;-10&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;
</span><span class=s>Root@0..3
</span><span class=s>  PrefixExpr@0..3
</span><span class=s>    Minus@0..1 &#34;-&#34;
</span><span class=s>    Number@1..3 &#34;10&#34;&#34;#</span><span class=p>]],</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Now that an expression can start with something other than a number or an identifier, we need to modify that <code>match</code> at the start of <code>expr_binding_power</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>expr_binding_power</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Parser</span><span class=p>,</span><span class=w> </span><span class=n>minimum_binding_power</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>checkpoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>checkpoint</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Minus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>todo</span><span class=o>!</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>First, we should determine the binding power of the prefix operator we’ve found. To do this, we need to define a type that represents all the possible prefix operators we might encounter &ndash; <code>PrefixOp</code> sounds like a good name. Also, we should rename <code>Op</code> to <code>InfixOp</code> so that it’s differentiated from <code>PrefixOp</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>expr_binding_power</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Parser</span><span class=p>,</span><span class=w> </span><span class=n>minimum_binding_power</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>checkpoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>checkpoint</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Minus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PrefixOp</span>::<span class=n>Neg</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=p>((),</span><span class=w> </span><span class=n>right_binding_power</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>op</span><span class=p>.</span><span class=n>binding_power</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Plus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>InfixOp</span>::<span class=n>Add</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Minus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>InfixOp</span>::<span class=n>Sub</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Star</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>InfixOp</span>::<span class=n>Mul</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Slash</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>InfixOp</span>::<span class=n>Div</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>return</span><span class=p>,</span><span class=w> </span><span class=c1>// we’ll handle errors later.
</span><span class=c1></span><span class=w>        </span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=c1>// snip
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>enum</span> <span class=nc>InfixOp</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Add</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>Sub</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>Mul</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>Div</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>InfixOp</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>binding_power</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=kt>u8</span><span class=p>,</span><span class=w> </span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=c1>// snip
</span><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>enum</span> <span class=nc>PrefixOp</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Neg</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>PrefixOp</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>binding_power</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>((),</span><span class=w> </span><span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=bp>self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>Self</span>::<span class=n>Neg</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>((),</span><span class=w> </span><span class=mi>5</span><span class=p>),</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Note how the binding power of the negation operator is higher than that of any infix operator. This means that <code>-10 + 5</code> is parsed as <code>(-10) + 5</code> instead of <code>-(10 + 5)</code>.</p><p>We now do the same as in the case of an infix operator:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>expr_binding_power</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Parser</span><span class=p>,</span><span class=w> </span><span class=n>minimum_binding_power</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>checkpoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>checkpoint</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Minus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PrefixOp</span>::<span class=n>Neg</span><span class=p>;</span><span class=w>
</span><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=p>((),</span><span class=w> </span><span class=n>right_binding_power</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>op</span><span class=p>.</span><span class=n>binding_power</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>            </span><span class=c1>// Eat the operator’s token.
</span><span class=c1></span><span class=w>            </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>            </span><span class=n>p</span><span class=p>.</span><span class=n>start_node_at</span><span class=p>(</span><span class=n>checkpoint</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>PrefixExpr</span><span class=p>);</span><span class=w>
</span><span class=w>            </span><span class=n>expr_binding_power</span><span class=p>(</span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=n>right_binding_power</span><span class=p>);</span><span class=w>
</span><span class=w>            </span><span class=n>p</span><span class=p>.</span><span class=n>finish_node</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><pre tabindex=0><code class=language-- data-lang=->$ cargo t -q
running 22 tests
......................
test result: ok. 22 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Let’s add a test to make sure precedence is working as we would hope:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>negation_has_higher_binding_power_than_infix_operators</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;-20+20&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;
</span><span class=s>Root@0..6
</span><span class=s>  BinaryExpr@0..6
</span><span class=s>    PrefixExpr@0..3
</span><span class=s>      Minus@0..1 &#34;-&#34;
</span><span class=s>      Number@1..3 &#34;20&#34;
</span><span class=s>    Plus@3..4 &#34;+&#34;
</span><span class=s>    Number@4..6 &#34;20&#34;&#34;#</span><span class=p>]],</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><pre tabindex=0><code class=language-- data-lang=->$ cargo t -q
running 23 tests
.......................
test result: ok. 23 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><h1 id=parentheses>Parentheses</h1><p>Our lexer doesn’t lex parentheses, so we should start off by adding that:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// lexer.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[derive(Debug, Copy, Clone, PartialEq, Logos, FromPrimitive, ToPrimitive)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>enum</span> <span class=nc>SyntaxKind</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[token(</span><span class=s>&#34;(&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>LParen</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[token(</span><span class=s>&#34;)&#34;</span><span class=cp>)]</span><span class=w>
</span><span class=w>    </span><span class=n>RParen</span><span class=p>,</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_left_parenthesis</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;(&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>LParen</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>lex_right_parenthesis</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=s>&#34;)&#34;</span><span class=p>,</span><span class=w> </span><span class=n>SyntaxKind</span>::<span class=n>RParen</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><pre tabindex=0><code class=language-- data-lang=->$ cargo t -q
running 25 tests
.........................
test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Let’s write a test for parsing a bunch of nested parentheses:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=c1>// expr.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_nested_parentheses</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;((((((10))))))&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;
</span><span class=s>Root@0..14
</span><span class=s>  LParen@0..1 &#34;(&#34;
</span><span class=s>  LParen@1..2 &#34;(&#34;
</span><span class=s>  LParen@2..3 &#34;(&#34;
</span><span class=s>  LParen@3..4 &#34;(&#34;
</span><span class=s>  LParen@4..5 &#34;(&#34;
</span><span class=s>  LParen@5..6 &#34;(&#34;
</span><span class=s>  Number@6..8 &#34;10&#34;
</span><span class=s>  RParen@8..9 &#34;)&#34;
</span><span class=s>  RParen@9..10 &#34;)&#34;
</span><span class=s>  RParen@10..11 &#34;)&#34;
</span><span class=s>  RParen@11..12 &#34;)&#34;
</span><span class=s>  RParen@12..13 &#34;)&#34;
</span><span class=s>  RParen@13..14 &#34;)&#34;&#34;#</span><span class=p>]],</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Let’s also add a test to see if adding parentheses allows us to change precedence as we would expect:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parentheses_affect_precedence</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>check</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;5*(2+1)&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>expect</span><span class=o>!</span><span class=p>[[</span><span class=s>r#&#34;
</span><span class=s>Root@0..7
</span><span class=s>  BinaryExpr@0..7
</span><span class=s>    Number@0..1 &#34;5&#34;
</span><span class=s>    Star@1..2 &#34;*&#34;
</span><span class=s>    LParen@2..3 &#34;(&#34;
</span><span class=s>    BinaryExpr@3..6
</span><span class=s>      Number@3..4 &#34;2&#34;
</span><span class=s>      Plus@4..5 &#34;+&#34;
</span><span class=s>      Number@5..6 &#34;1&#34;
</span><span class=s>    RParen@6..7 &#34;)&#34;&#34;#</span><span class=p>]],</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Once again we need to add another case to the <code>match</code> statement at the top of <code>expr_binding_power</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>expr_binding_power</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Parser</span><span class=p>,</span><span class=w> </span><span class=n>minimum_binding_power</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>checkpoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>checkpoint</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Minus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=c1>// snip
</span><span class=c1></span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>LParen</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>todo</span><span class=o>!</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>The first thing we should do is <code>bump</code> the left parenthesis onto the current branch:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>expr_binding_power</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Parser</span><span class=p>,</span><span class=w> </span><span class=n>minimum_binding_power</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>checkpoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>checkpoint</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Minus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=c1>// snip
</span><span class=c1></span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>LParen</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>();</span><span class=w>
</span><span class=w>            </span><span class=n>todo</span><span class=o>!</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>If you think about it, we can parse the contents of the parenthesised expression by calling <code>expr_binding_power</code> with <code>minimum_binding_power</code> set to <code>0</code>, since parenthesising something ‘resets’ precedence inside it. All we need to do after writing that is add another <code>p.bump()</code> to account for the closing parenthesis:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>expr_binding_power</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Parser</span><span class=p>,</span><span class=w> </span><span class=n>minimum_binding_power</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>checkpoint</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>checkpoint</span><span class=p>();</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Number</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Ident</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>Minus</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=c1>// snip
</span><span class=c1></span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>LParen</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>();</span><span class=w>
</span><span class=w>            </span><span class=n>expr_binding_power</span><span class=p>(</span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>            </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>peek</span><span class=p>(),</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>SyntaxKind</span>::<span class=n>RParen</span><span class=p>));</span><span class=w>
</span><span class=w>            </span><span class=n>p</span><span class=p>.</span><span class=n>bump</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><pre tabindex=0><code class=language-- data-lang=->$ cargo t -q
running 27 tests
...........................
test result: ok. 27 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><h1 id=next-time>Next time</h1><p>In the next part we’ll restructure how the parser works internally so Eldiro can support a seemingly-basic feature: whitespace.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>It’s more appropriate to use <code>PrefixExpr</code> instead of <code>UnaryExpr</code> because a unary operator could also be <em>postfix,</em> meaning that you add it after the operand. For example, <code>?</code> in Rust is a postfix operator. It makes sense to differentiate the two because we might have to treat them differently in future.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></main><nav class=page-navigation><div class=prev><p class=hint>Previously</p><a href=https://arzg.github.io/lang/10/>Part Ten: Starting Again</a></div><div class=next><p class=hint>Next up</p><a href=https://arzg.github.io/lang/12/>Part Twelve: Terminology</a></div><div style=clear:both></div></nav></body></html>