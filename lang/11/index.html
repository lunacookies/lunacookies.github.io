<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Part Eleven: Refinements · arzg’s website</title><link rel=stylesheet href=https://arzg.github.io/scss/main.04c23afe51262a10ee61829da41f4d7318ff311ed0d0bcbf1db0fde96e3830f4.css integrity="sha256-BMI6/lEmKhDuYYKdpB9Ncxj/MR7Q0Ly/HbD96W44MPQ="><script src=https://unpkg.com/quicklink@2.0.0/dist/quicklink.umd.js></script>
<script src=https://unpkg.com/anchor-js@4.3.1/anchor.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/plugins/autoloader/prism-autoloader.min.js></script>
<script>window.onload=()=>{quicklink.listen()},document.addEventListener("DOMContentLoaded",function(a){anchors.add("main h1")})</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body><nav class=site-navigation><ul><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li class=current><a href=/lang/>Make A Language</a></li></ul></nav><header class=header-area><h1 class=title>Part Eleven: Refinements</h1><section class=page-info><ul><li>17 November 2020</li><li>1327 words</li><li>seven minute read</li></ul></section></header><main><p>We’ve got a number of topics to cover this time, so let’s get started.</p><h1 id=a-bug-fix>A bug fix</h1><p>u/mozjag <a href="https://www.reddit.com/r/rust/comments/ju1vhl/make_a_language_in_rust_part_ten_starting_again/gcc7rk8?utm_source=share&utm_medium=web2x&context=3">pointed out</a> on Reddit that the regex we’re using to lex identifiers mandates that they have a length of two, when we could also allow identifiers with a single character. Let’s write a test for lexing a single-letter identifier to verify the bug is actually present:</p><pre><code class=language-rust>// lexer.rs

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn lex_single_char_identifier() {
        check(&quot;x&quot;, SyntaxKind::Ident);
    }

    // snip
}
</code></pre><pre><code class=language-->$ cargo t -q
running 21 tests
..............F......
failures:

---- lexer::tests::lex_single_char_identifier stdout ----
thread 'lexer::tests::lex_single_char_identifier' panicked at 'assertion failed: `(left == right)`
  left: `Some((Error, &quot;x&quot;))`,
 right: `Some((Ident, &quot;x&quot;))`', crates/eldiro/src/lexer.rs:78:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    lexer::tests::lex_single_char_identifier

test result: FAILED. 20 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>We need to change the <code>+</code> in the <code>Ident</code> regex to be a <code>*</code> instead, so that <em>zero or more</em> repetitions are allowed instead of <em>one or more:</em></p><pre><code class=language-rust>#[derive(Debug, Copy, Clone, PartialEq, Logos, FromPrimitive, ToPrimitive)]
pub(crate) enum SyntaxKind {
    // snip

    #[regex(&quot;[A-Za-z][A-Za-z0-9]*&quot;)]
    Ident,

    // snip
}
</code></pre><pre><code class=language-->$ cargo t -q
.....................
test result: ok. 21 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><h1 id=negation>Negation</h1><p>Up to now, all the operators we support have been <em>binary,</em> meaning that they have two operands. We’d like to have <em>unary</em> operators too, which are operators that have one operand. The operator we’ll add here is the prefix unary minus, as used for negation &ndash; the <code>-</code> in <code>-10</code>, for example. To start, we’ll need another node type:<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><pre><code class=language-rust>#[derive(Debug, Copy, Clone, PartialEq, Logos, FromPrimitive, ToPrimitive)]
pub(crate) enum SyntaxKind {
    // snip

    Root,
    BinOp,
    PrefixExpr,
}
</code></pre><p>Let’s rename <code>BinOp</code> to <code>BinaryExpr</code> for consistency (after all, we aren’t abbreviating <code>Prefix</code>):</p><pre><code class=language-rust>#[derive(Debug, Copy, Clone, PartialEq, Logos, FromPrimitive, ToPrimitive)]
pub(crate) enum SyntaxKind {
    // snip

    Root,
    BinaryExpr,
    PrefixExpr,
}
</code></pre><pre><code class=language-rust>// expr.rs

fn expr_binding_power(p: &amp;mut Parser, minimum_binding_power: u8) {
    // snip

    loop {
        // snip
        p.start_node_at(checkpoint, SyntaxKind::BinaryExpr);
        // snip
    }
}

// snip

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_simple_binary_expression() {
        check(
            &quot;1+2&quot;,
            expect![[r#&quot;
Root@0..3
  BinaryExpr@0..3
    Number@0..1 &quot;1&quot;
    Plus@1..2 &quot;+&quot;
    Number@2..3 &quot;2&quot;&quot;#]],
        );
    }

    #[test]
    fn parse_left_associative_binary_expression() {
        check(
            &quot;1+2+3+4&quot;,
            expect![[r#&quot;
Root@0..7
  BinaryExpr@0..7
    BinaryExpr@0..5
      BinaryExpr@0..3
        Number@0..1 &quot;1&quot;
        Plus@1..2 &quot;+&quot;
        Number@2..3 &quot;2&quot;
      Plus@3..4 &quot;+&quot;
      Number@4..5 &quot;3&quot;
    Plus@5..6 &quot;+&quot;
    Number@6..7 &quot;4&quot;&quot;#]],
        );
    }

    #[test]
    fn parse_binary_expression_with_mixed_binding_power() {
        check(
            &quot;1+2*3-4&quot;,
            expect![[r#&quot;
Root@0..7
  BinaryExpr@0..7
    BinaryExpr@0..5
      Number@0..1 &quot;1&quot;
      Plus@1..2 &quot;+&quot;
      BinaryExpr@2..5
        Number@2..3 &quot;2&quot;
        Star@3..4 &quot;*&quot;
        Number@4..5 &quot;3&quot;
    Minus@5..6 &quot;-&quot;
    Number@6..7 &quot;4&quot;&quot;#]],
        );
    }
}
</code></pre><p>We can write a test for parsing an expression with the negation operator:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_negation() {
        check(
            &quot;-10&quot;,
            expect![[r#&quot;
Root@0..3
  PrefixExpr@0..3
    Minus@0..1 &quot;-&quot;
    Number@1..3 &quot;10&quot;&quot;#]],
        );
    }
}
</code></pre><p>Now that an expression can start with something other than a number or an identifier, we need to modify that <code>match</code> at the start of <code>expr_binding_power</code>:</p><pre><code class=language-rust>fn expr_binding_power(p: &amp;mut Parser, minimum_binding_power: u8) {
    let checkpoint = p.checkpoint();

    match p.peek() {
        Some(SyntaxKind::Number) | Some(SyntaxKind::Ident) =&gt; p.bump(),
        Some(SyntaxKind::Minus) =&gt; todo!(),
        _ =&gt; {}
    }

    // snip
}
</code></pre><p>First, we should determine the binding power of the prefix operator we’ve found. To do this, we need to define a type that represents all the possible prefix operators we might encounter &ndash; <code>PrefixOp</code> sounds like a good name. Also, we should rename <code>Op</code> to <code>InfixOp</code> so that it’s differentiated from <code>PrefixOp</code>:</p><pre><code class=language-rust>fn expr_binding_power(p: &amp;mut Parser, minimum_binding_power: u8) {
    let checkpoint = p.checkpoint();

    match p.peek() {
        Some(SyntaxKind::Number) | Some(SyntaxKind::Ident) =&gt; p.bump(),
        Some(SyntaxKind::Minus) =&gt; {
            let op = PrefixOp::Neg;
            let ((), right_binding_power) = op.binding_power();
        }
        _ =&gt; {}
    }

    loop {
        let op = match p.peek() {
            Some(SyntaxKind::Plus) =&gt; InfixOp::Add,
            Some(SyntaxKind::Minus) =&gt; InfixOp::Sub,
            Some(SyntaxKind::Star) =&gt; InfixOp::Mul,
            Some(SyntaxKind::Slash) =&gt; InfixOp::Div,
            _ =&gt; return, // we’ll handle errors later.
        };

        // snip
    }
}

enum InfixOp {
    Add,
    Sub,
    Mul,
    Div,
}

impl InfixOp {
    fn binding_power(&amp;self) -&gt; (u8, u8) {
        // snip
    }
}

enum PrefixOp {
    Neg,
}

impl PrefixOp {
    fn binding_power(&amp;self) -&gt; ((), u8) {
        match self {
            Self::Neg =&gt; ((), 5),
        }
    }
}
</code></pre><p>Note how the binding power of the negation operator is higher than that of any infix operator. This means that <code>-10 + 5</code> is parsed as <code>(-10) + 5</code> instead of <code>-(10 + 5)</code>.</p><p>We now do the same as in the case of an infix operator:</p><pre><code class=language-rust>fn expr_binding_power(p: &amp;mut Parser, minimum_binding_power: u8) {
    let checkpoint = p.checkpoint();

    match p.peek() {
        Some(SyntaxKind::Number) | Some(SyntaxKind::Ident) =&gt; p.bump(),
        Some(SyntaxKind::Minus) =&gt; {
            let op = PrefixOp::Neg;
            let ((), right_binding_power) = op.binding_power();

            // Eat the operator’s token.
            p.bump();

            p.start_node_at(checkpoint, SyntaxKind::PrefixExpr);
            expr_binding_power(p, right_binding_power);
            p.finish_node();
        }
        _ =&gt; {}
    }

    // snip
}
</code></pre><pre><code class=language-->$ cargo t -q
running 22 tests
......................
test result: ok. 22 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Let’s add a test to make sure precedence is working as we would hope:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn negation_has_higher_binding_power_than_infix_operators() {
        check(
            &quot;-20+20&quot;,
            expect![[r#&quot;
Root@0..6
  BinaryExpr@0..6
    PrefixExpr@0..3
      Minus@0..1 &quot;-&quot;
      Number@1..3 &quot;20&quot;
    Plus@3..4 &quot;+&quot;
    Number@4..6 &quot;20&quot;&quot;#]],
        );
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
running 23 tests
.......................
test result: ok. 23 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><h1 id=parentheses>Parentheses</h1><p>Our lexer doesn’t lex parentheses, so we should start off by adding that:</p><pre><code class=language-rust>// lexer.rs

#[derive(Debug, Copy, Clone, PartialEq, Logos, FromPrimitive, ToPrimitive)]
pub(crate) enum SyntaxKind {
    // snip

    #[token(&quot;(&quot;)]
    LParen,

    #[token(&quot;)&quot;)]
    RParen,

    // snip
}

// snip

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn lex_left_parenthesis() {
        check(&quot;(&quot;, SyntaxKind::LParen);
    }

    #[test]
    fn lex_right_parenthesis() {
        check(&quot;)&quot;, SyntaxKind::RParen);
    }

    // snip
}
</code></pre><pre><code class=language-->$ cargo t -q
running 25 tests
.........................
test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Let’s write a test for parsing a bunch of nested parentheses:</p><pre><code class=language-rust>// expr.rs

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_nested_parentheses() {
        check(
            &quot;((((((10))))))&quot;,
            expect![[r#&quot;
Root@0..14
  LParen@0..1 &quot;(&quot;
  LParen@1..2 &quot;(&quot;
  LParen@2..3 &quot;(&quot;
  LParen@3..4 &quot;(&quot;
  LParen@4..5 &quot;(&quot;
  LParen@5..6 &quot;(&quot;
  Number@6..8 &quot;10&quot;
  RParen@8..9 &quot;)&quot;
  RParen@9..10 &quot;)&quot;
  RParen@10..11 &quot;)&quot;
  RParen@11..12 &quot;)&quot;
  RParen@12..13 &quot;)&quot;
  RParen@13..14 &quot;)&quot;&quot;#]],
        );
    }
}
</code></pre><p>Let’s also add a test to see if adding parentheses allows us to change precedence as we would expect:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parentheses_affect_precedence() {
        check(
            &quot;5*(2+1)&quot;,
            expect![[r#&quot;
Root@0..7
  BinaryExpr@0..7
    Number@0..1 &quot;5&quot;
    Star@1..2 &quot;*&quot;
    LParen@2..3 &quot;(&quot;
    BinaryExpr@3..6
      Number@3..4 &quot;2&quot;
      Plus@4..5 &quot;+&quot;
      Number@5..6 &quot;1&quot;
    RParen@6..7 &quot;)&quot;&quot;#]],
        );
    }
}
</code></pre><p>Once again we need to add another case to the <code>match</code> statement at the top of <code>expr_binding_power</code>:</p><pre><code class=language-rust>fn expr_binding_power(p: &amp;mut Parser, minimum_binding_power: u8) {
    let checkpoint = p.checkpoint();

    match p.peek() {
        Some(SyntaxKind::Number) | Some(SyntaxKind::Ident) =&gt; p.bump(),
        Some(SyntaxKind::Minus) =&gt; {
            // snip
        }
        Some(SyntaxKind::LParen) =&gt; todo!(),
        _ =&gt; {}
    }

    // snip
}
</code></pre><p>The first thing we should do is <code>bump</code> the left parenthesis onto the current branch:</p><pre><code class=language-rust>fn expr_binding_power(p: &amp;mut Parser, minimum_binding_power: u8) {
    let checkpoint = p.checkpoint();

    match p.peek() {
        Some(SyntaxKind::Number) | Some(SyntaxKind::Ident) =&gt; p.bump(),
        Some(SyntaxKind::Minus) =&gt; {
            // snip
        }
        Some(SyntaxKind::LParen) =&gt; {
            p.bump();
            todo!();
        }
        _ =&gt; {}
    }

    // snip
}
</code></pre><p>If you think about it, we can parse the contents of the parenthesised expression by calling <code>expr_binding_power</code> with <code>minimum_binding_power</code> set to <code>0</code>, since parenthesising something ‘resets’ precedence inside it. All we need to do after writing that is add another <code>p.bump()</code> to account for the closing parenthesis:</p><pre><code class=language-rust>fn expr_binding_power(p: &amp;mut Parser, minimum_binding_power: u8) {
    let checkpoint = p.checkpoint();

    match p.peek() {
        Some(SyntaxKind::Number) | Some(SyntaxKind::Ident) =&gt; p.bump(),
        Some(SyntaxKind::Minus) =&gt; {
            // snip
        }
        Some(SyntaxKind::LParen) =&gt; {
            p.bump();
            expr_binding_power(p, 0);

            assert_eq!(p.peek(), Some(SyntaxKind::RParen));
            p.bump();
        }
        _ =&gt; {}
    }

    // snip
}
</code></pre><pre><code class=language-->$ cargo t -q
running 27 tests
...........................
test result: ok. 27 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><h1 id=next-time>Next time</h1><p>In the next part we’ll restructure how the parser works internally so Eldiro can support a seemingly-basic feature: whitespace.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>It’s more appropriate to use <code>PrefixExpr</code> instead of <code>UnaryExpr</code> because a unary operator could also be <em>postfix,</em> meaning that you add it after the operand. For example, <code>?</code> in Rust is a postfix operator. It makes sense to differentiate the two because we might have to treat them differently in future.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></main><nav class=page-navigation><div class=prev><p class=hint>Previously</p><a href=https://arzg.github.io/lang/10/>Part Ten: Starting Again</a></div><div class=next><p class=hint>Next up</p><a href=https://arzg.github.io/lang/12/>Part Twelve: Terminology</a></div><div style=clear:both></div></nav></body></html>