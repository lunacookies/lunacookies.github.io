<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Part Three: Defining Variables · arzg’s website</title><link rel=stylesheet href=https://arzg.github.io/scss/main.04c23afe51262a10ee61829da41f4d7318ff311ed0d0bcbf1db0fde96e3830f4.css integrity="sha256-BMI6/lEmKhDuYYKdpB9Ncxj/MR7Q0Ly/HbD96W44MPQ="><script src=https://unpkg.com/quicklink@2.0.0/dist/quicklink.umd.js></script>
<script src=https://unpkg.com/anchor-js@4.3.1/anchor.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/plugins/autoloader/prism-autoloader.min.js></script>
<script>window.onload=()=>{quicklink.listen()},document.addEventListener("DOMContentLoaded",function(a){anchors.add("main h1")})</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body><nav class=site-navigation><ul><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li class=current><a href=/lang/>Make A Language</a></li></ul></nav><header class=header-area><h1 class=title>Part Three: Defining Variables</h1><section class=page-info><ul><li>9 September 2020</li><li>2099 words</li><li>ten minute read</li></ul></section></header><main><p>Welcome back! This time, we’ll parse and evaluate variable definitions.</p><h1 id=parsing>Parsing</h1><p>Before we can begin writing a parser, we need to decide on a syntax. Since we like Rust, we’ll go for a similar syntax:</p><pre><code class=language-rust>let a = 5
</code></pre><p>To start off, Eldiro will only include immutable variables, or <em>bindings,</em><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> as they’re sometimes called (at least that’s what I’ll be calling them for the rest of this series).</p><p>Although we’d usually start writing a test here, I fear that <code>lib.rs</code> will become too cluttered. To ameliorate this, we’ll move <code>lib.rs</code> to <code>expr.rs</code>, remove <code>mod utils;</code> from <code>expr.rs</code>, and put the following in <code>lib.rs</code>:</p><pre><code class=language-rust>pub mod expr;
mod utils;
</code></pre><p>We also need to import <code>crate::utils</code> in <code>expr.rs</code>:</p><pre><code class=language-rust>use crate::utils;
</code></pre><p>Now we can start writing a test. Open <code>lib.rs</code> and add <code>pub mod binding_def;</code> to the top, and open up <code>src/binding_def.rs</code>:</p><pre><code class=language-rust>use crate::expr::Expr;

#[derive(Debug, PartialEq)]
pub struct BindingDef {
    name: String,
    val: Expr,
}

impl BindingDef {
    pub fn new(s: &amp;str) -&gt; (&amp;str, Self) {
        todo!()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::expr::{Number, Op};

    #[test]
    fn parse_binding_def() {
        assert_eq!(
            BindingDef::new(&quot;let a = 10 / 2&quot;),
            (
                &quot;&quot;,
                BindingDef {
                    name: &quot;a&quot;.to_string(),
                    val: Expr {
                        lhs: Number(10),
                        rhs: Number(2),
                        op: Op::Div,
                    },
                },
            ),
        );
    }
}
</code></pre><p>Let’s implement the <code>BindingDef</code> parser:</p><pre><code class=language-rust>use crate::utils;

// snip

impl BindingDef {
    pub fn new(s: &amp;str) -&gt; (&amp;str, Self) {
        let s = if s.starts_with(&quot;let&quot;) {
            &amp;s[3..]
        } else {
            panic!(&quot;expected let&quot;)
        };
        let (s, _) = utils::extract_whitespace(s);

        let (s, name) = utils::extract_ident(s); // Unimplemented!
        let (s, _) = utils::extract_whitespace(s);

        let s = if s.starts_with('=') {
            &amp;s[1..]
        } else {
            panic!(&quot;expected equals sign&quot;)
        };
        let (s, _) = utils::extract_whitespace(s);

        let (s, val) = Expr::new(s);

        (
            s,
            Self {
                name: name.to_string(),
                val,
            },
        )
    }
}
</code></pre><p>We start by checking if the input starts with <code>let</code>; if it does, we strip it off and continue. If it doesn’t, we panic. Next, we strip off whitespace. After this, we extract an identifier using a function we haven’t defined yet, and strip off whitespace. Next, we follow the same pattern we used to strip off the <code>let</code>, but instead this time with <code>=</code>. Finally, we strip off whitespace yet again and can parse an expression from the remaining input.</p><p>Although the panicking isn’t pretty, it’s good enough for this tutorial. The repetition, on the other hand, isn’t. Before we get too ahead of ourselves, we should implement <code>utils::extract_ident</code>, though:</p><pre><code class=language-rust>// utils.rs

pub(crate) fn extract_ident(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    take_while(|c| c.is_ascii_alphabetic(), s)
}

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn extract_alphabetic_ident() {
        assert_eq!(extract_ident(&quot;abcdEFG stop&quot;), (&quot; stop&quot;, &quot;abcdEFG&quot;));
    }
}
</code></pre><p>Easy enough! But what if we want our identifiers to contain numbers?</p><pre><code class=language-rust>pub(crate) fn extract_ident(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    // Notice this is now alphanumeric instead of alphabetic
    take_while(|c| c.is_ascii_alphanumeric(), s)
}

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn extract_alphanumeric_ident() {
        assert_eq!(extract_ident(&quot;foobar1()&quot;), (&quot;()&quot;, &quot;foobar1&quot;));
    }
}
</code></pre><p>Fortunately, this works. It has one problem, though: what if we’re in a situation where either a number or an identifier is permissible? For example, both of the following will work once Eldiro becomes more developed:</p><pre><code class=language-rust>let a = 10       # numbers
let n = a        # identifier
</code></pre><p>A number or an identifier works in the same place.</p><p>The problem is that <code>extract_ident</code> allows <em>all</em> characters of the identifier to be numbers, thereby allowing the mistaken treatment of numbers as identifiers. It is for this reason that many programming languages (Rust and C included) don’t allow identifiers to start with a number; Eldiro should follow in their footsteps. Luckily, this is pretty easy to implement:</p><pre><code class=language-rust>pub(crate) fn extract_ident(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    let input_starts_with_alphabetic = s
        .chars()
        .next()
        .map(|c| c.is_ascii_alphabetic())
        .unwrap_or(false);

    if input_starts_with_alphabetic {
        take_while(|c| c.is_ascii_alphanumeric(), s)
    } else {
        (s, &quot;&quot;)
    }
}

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn cannot_extract_ident_beginning_with_number() {
        assert_eq!(extract_ident(&quot;123abc&quot;), (&quot;123abc&quot;, &quot;&quot;));
    }
}
</code></pre><p>Note how we try to extract the identifier in the test, but the entire input is returned as leftover, meaning the parser didn’t consume anything. This matches what we wrote on the second-last line of <code>extract_ident</code>’s definition: if the input doesn’t start with an alphabetic character, then we know we won’t be able to parse an identifier and can just give up by not consuming anything.</p><p>Now that we have <code>utils::extract_ident</code> working, we can move on to the next problem: the duplication of logic in <code>BindingDef::new</code>. Here’s the current code of that function for a quick refresher:</p><pre><code class=language-rust>impl BindingDef {
    pub fn new(s: &amp;str) -&gt; (&amp;str, Self) {
        let s = if s.starts_with(&quot;let&quot;) {
            &amp;s[3..]
        } else {
            panic!(&quot;expected let&quot;)
        };
        let (s, _) = utils::extract_whitespace(s);

        let (s, name) = utils::extract_ident(s);
        let (s, _) = utils::extract_whitespace(s);

        let s = if s.starts_with('=') {
            &amp;s[1..]
        } else {
            panic!(&quot;expected equals sign&quot;)
        };
        let (s, _) = utils::extract_whitespace(s);

        let (s, val) = Expr::new(s);

        (
            s,
            Self {
                name: name.to_string(),
                val,
            },
        )
    }
}
</code></pre><p>For both <code>let</code> and <code>=</code> we follow the same pattern:</p><ol><li>Check if the input starts with the desired text</li><li>If it does, return the input with the desired text chopped off</li><li>If it doesn’t, panic</li></ol><p>This can be abstracted away into a function, which we should definitely do since we’ll be using it a lot.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> Inspired by the <a href=https://github.com/Geal/nom>Nom parsing library</a>,<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> we’ll call this function <code>tag</code>:</p><pre><code class=language-rust>// utils.rs

pub(crate) fn tag&lt;'a, 'b&gt;(starting_text: &amp;'a str, s: &amp;'b str) -&gt; &amp;'b str {
    if s.starts_with(starting_text) {
        &amp;s[starting_text.len()..]
    } else {
        panic!(&quot;expected {}&quot;, starting_text);
    }
}

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn tag_word() {
        assert_eq!(tag(&quot;let&quot;, &quot;let a&quot;), &quot; a&quot;);
    }
}
</code></pre><p>Those lifetimes on <code>tag</code> might look scary, but all they’re doing is telling Rust that the lifetimes of <code>s</code> and the output are related, while the lifetimes of <code>starting_text</code> and the output aren’t. If we didn’t have the lifetimes, Rust wouldn’t know if the returned value has to live as long as <code>starting_text</code>, or <code>s</code>, or both.</p><p>With <code>tag</code> working, let’s go back to <code>BindingDef::new</code> and refactor it to use our new function:</p><pre><code class=language-rust>impl BindingDef {
    pub fn new(s: &amp;str) -&gt; (&amp;str, Self) {
        let s = utils::tag(&quot;let&quot;, s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, name) = utils::extract_ident(s);
        let (s, _) = utils::extract_whitespace(s);

        let s = utils::tag(&quot;=&quot;, s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, val) = Expr::new(s);

        (
            s,
            Self {
                name: name.to_string(),
                val,
            },
        )
    }
}
</code></pre><p>Now for the moment of truth:</p><pre><code class=language-->$ cargo t
running 21 tests
test expr::tests::parse_add_op ... ok
test expr::tests::parse_div_op ... ok
test binding_def::tests::parse_binding_def ... ok
test expr::tests::parse_expr_with_whitespace ... ok
test expr::tests::parse_mul_op ... ok
test expr::tests::parse_number ... ok
test expr::tests::parse_one_plus_two ... ok
test expr::tests::parse_sub_op ... ok
test utils::tests::cannot_extract_ident_beginning_with_number ... ok
test utils::tests::do_not_extract_anything_from_empty_input ... ok
test utils::tests::extract_alphabetic_ident ... ok
test utils::tests::extract_alphanumeric_ident ... ok
test utils::tests::extract_digits_with_no_remainder ... ok
test utils::tests::extract_minus ... ok
test utils::tests::extract_multiple_digits ... ok
test utils::tests::extract_one_digit ... ok
test utils::tests::extract_plus ... ok
test utils::tests::extract_slash ... ok
test utils::tests::extract_spaces ... ok
test utils::tests::tag_word ... ok
test utils::tests::extract_star ... ok

test result: ok. 21 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Huzzah! That output is getting a little long, though, so let’s rerun with <code>--quiet</code>, or <code>-q</code> for short:</p><pre><code class=language-->$ cargo t -q
running 21 tests
.....................
test result: ok. 21 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Much better. Now that we can parse binding definitions, we need to evaluate them.</p><h1 id=evaluation>Evaluation</h1><p>Up to now, all we’ve done is parsing. Now it’s time for something different: evaluation. Since Eldiro doesn’t at the moment have a way to access the value of bindings (we haven’t parsed binding usages yet), and can only define new bindings, we need to worry solely about the problem of storing bindings. Of course, we will eventually add a way to get the value of a binding, but we’ll worry about that when we get to it.</p><p>Imagine that Eldiro had the ability to access the value of bindings; how would binding storage work? If we have a binding definition <code>let a = 2 + 2</code>, and later use it by typing <code>a</code>, how can we figure out what the value of the usage is? When we’re evaluating the binding usage, we know that a binding is in scope with the name <code>a</code> and a value of <code>4</code>. We also know that we’re trying to use a binding with the name <code>a</code>. To me, this sounds like a job for a <code>HashMap</code> (also known as a ‘dictionary’ or ‘map’ in other languages). A <code>HashMap</code> allows you to store values, associating them with a key. Given that same key, you can later extract the value associated with that key. In this case, the keys are binding names (<code>String</code>s), and the values are … well, we’ll see.</p><p>Traditionally, all the context needed to evaluate code is called an <em>environment.</em> Let’s define one. Add the module declaration to <code>lib.rs</code>:</p><pre><code class=language-rust>pub mod binding_def;
pub mod expr;

mod env;
mod utils;
</code></pre><p>And create and open <code>src/env.rs</code>:</p><pre><code class=language-rust>use std::collections::HashMap;

#[derive(Debug, PartialEq, Default)]
pub(crate) struct Env {
    bindings: HashMap&lt;String, ???&gt;,
}
</code></pre><p>What do we put where the question marks are? Well, that’s the type of the value of a binding. At the moment Eldiro only supports expressions with numbers, but we’ll add support for all kinds of data types later. To make these future enhancements easier, we can declare Eldiro <em>values</em> as an enum with variants for each data type. We’ll need another module for this:</p><pre><code class=language-rust>// lib.rs
pub mod binding_def;
pub mod expr;
pub mod val;

mod env;
mod utils;
</code></pre><p>And in <code>src/val.rs</code>:</p><pre><code class=language-rust>#[derive(Debug, PartialEq)]
pub enum Val {
    Number(i32),
}
</code></pre><p>Let’s head back over to <code>env.rs</code> so we can use <code>Val</code> as the value type of our bindings <code>HashMap</code>:</p><pre><code class=language-rust>use crate::val::Val;
use std::collections::HashMap;

#[derive(Debug, PartialEq, Default)]
pub(crate) struct Env {
    bindings: HashMap&lt;String, Val&gt;,
}
</code></pre><p>All that’s left is a way for code outside of the <code>env</code> module to insert bindings:</p><pre><code class=language-rust>impl Env {
    pub(crate) fn store_binding(&amp;mut self, name: String, val: Val) {
        self.bindings.insert(name, val);
    }
}
</code></pre><p>Well, that was easy! Let’s go back to <code>binding_def.rs</code> to add an <code>eval</code> method to <code>BindingDef</code> that calls <code>Env::store_binding</code> for us:</p><pre><code class=language-rust>use crate::env::Env;

// snip

impl BindingDef {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;mut Env) {
        env.store_binding(self.name.clone(), self.val.eval());
    }
}
</code></pre><p>This stores in the environment a binding with the <em>name</em> of the <code>BindingDef</code> we’re evaluating (the <code>bar</code> in <code>let bar = 2 * 10</code>). The value of the new binding we’re storing is the <em>value</em> of the <code>BindingDef</code> we’re evaluating (the <code>2 * 10</code> in <code>let bar = 2 * 10</code>). There’s an issue with this code, though: it calls a non-existent method <code>eval</code> on <code>self.val</code> (which is of type <code>Expr</code>); we should implement it:</p><pre><code class=language-rust>// expr.rs
use crate::val::Val

// snip

impl Expr {
    // snip

    pub(crate) fn eval(&amp;self) -&gt; Val {
        let Number(lhs) = self.lhs;
        let Number(rhs) = self.rhs;

        let result = match self.op {
            Op::Add =&gt; lhs + rhs,
            Op::Sub =&gt; lhs - rhs,
            Op::Mul =&gt; lhs * rhs,
            Op::Div =&gt; lhs / rhs,
        };

        Val::Number(result)
    }
}
</code></pre><p>This method first extracts the numeric values of the left-hand side and right-hand sides of the expression, and then, depending on the operator, completes the needed calculation. To make sure <code>Expr::eval</code> is working, we should add some tests:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_add() {
        assert_eq!(
            Expr {
                lhs: Number(10),
                rhs: Number(10),
                op: Op::Add,
            }
            .eval(),
            Val::Number(20),
        );
    }

    #[test]
    fn eval_sub() {
        assert_eq!(
            Expr {
                lhs: Number(1),
                rhs: Number(5),
                op: Op::Sub,
            }
            .eval(),
            Val::Number(-4),
        );
    }

    #[test]
    fn eval_mul() {
        assert_eq!(
            Expr {
                lhs: Number(5),
                rhs: Number(6),
                op: Op::Mul,
            }
            .eval(),
            Val::Number(30),
        );
    }

    #[test]
    fn eval_div() {
        assert_eq!(
            Expr {
                lhs: Number(200),
                rhs: Number(20),
                op: Op::Div,
            }
            .eval(),
            Val::Number(10),
        );
    }
}
</code></pre><p>Let’s see if it works:</p><pre><code class=language-->$ cargo t -q
// lots of warnings
running 25 tests
.........................
test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Great!</p><p>Next time around, we’ll allow Eldiro’s <code>Expr</code>s to be just numbers by themselves, without requiring that everything is a mathematical operation (so <code>let foo = 100</code> will work). This might sound trivial, but it actually requires some significant changes across the project.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>A <em>var</em>iable that you can’t <em>var</em>y doesn’t make much sense.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Anywhere where you know you’ll see a given string, the function will be used. Examples include all keywords, parentheses, and some operators.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>In case you haven’t used Nom before, all the functions in <code>util</code> are loosely modelled off Nom. I decided against directly using Nom because I think it’s easier to understand when you write all the code yourself. In some cases this is impractical, but for something this simple I think the tradeoff is worth it.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></main><nav class=page-navigation><div class=prev><p class=hint>Previously</p><a href=https://arzg.github.io/lang/2/>Part Two: Whitespace Support</a></div><div class=next><p class=hint>Next up</p><a href=https://arzg.github.io/lang/4/>Part Four: Backtracking</a></div><div style=clear:both></div></nav></body></html>