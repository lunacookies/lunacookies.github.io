<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Make A Language on arzg’s website</title><link>https://arzg.github.io/lang/</link><description>Recent content in Make A Language on arzg’s website</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><lastBuildDate>Thu, 08 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://arzg.github.io/lang/index.xml" rel="self" type="application/rss+xml"/><item><title>Part Eight: Function Definitions</title><link>https://arzg.github.io/lang/8/</link><pubDate>Thu, 08 Oct 2020 00:00:00 +0000</pubDate><guid>https://arzg.github.io/lang/8/</guid><description>First, we need to decide on a syntax. Let’s start with Rust’s syntax:
fn frobnicate(foo: String,bar: String)-&amp;gt; Vec&amp;lt;Bar&amp;gt;{...}Eldiro doesn’t have types (yet), so we need to remove those:1
fn frobnicate(foo, bar) { ... } Parentheses and commas are annoying, so let’s get rid of those:
fn frobnicate foo bar { ... } Often we have functions whose body is just a single statement. Here’s a contrived example:
fn add x y { x + y } It can be convenient to not force function bodies to be blocks in these cases.</description></item><item><title>Part Seven: A REPL</title><link>https://arzg.github.io/lang/7/</link><pubDate>Wed, 07 Oct 2020 00:00:00 +0000</pubDate><guid>https://arzg.github.io/lang/7/</guid><description>In case you aren’t familiar with the concept, a read-eval-print-loop, or REPL, is a program that lets you interactively use a programming language. Here’s a hypothetical session with an Eldiro REPL:
$ eldiro → 5 5 → 10 - 7 3 → let one = 1 → one 1 To implement such a thing, the REPL needs to have access to Stmt::new, Val and Env (to store the evaluation environment between inputs).</description></item><item><title>Part Six: Blocks</title><link>https://arzg.github.io/lang/6/</link><pubDate>Tue, 06 Oct 2020 00:00:00 +0000</pubDate><guid>https://arzg.github.io/lang/6/</guid><description>By the end of this post, Eldiro will have blocks. By block, I mean the Rust meaning, not one from any other programming language.1
What is a block, anyway? In Rust (and Eldiro, once they are implemented), blocks are a way to group a bunch of bindings together and ensure that they are not accessible from outside the block. For example, foo and bar aren’t accessible outside the curly braces.</description></item><item><title>Part Five: Binding Usages</title><link>https://arzg.github.io/lang/5/</link><pubDate>Mon, 05 Oct 2020 00:00:00 +0000</pubDate><guid>https://arzg.github.io/lang/5/</guid><description>After Part Four, the longest so far, this will be a relatively short post: we’ll be adding support for binding usages. Here’s the syntax we’re after:
let a = 10 let b = a where a is a binding usage.
Parsing Let’s begin with the parser. Add pub mod binding_usage; to lib.rs, and create a new file at src/binding_usage.rs. As usual, we’ll start with a test:
#[cfg(test)]mod tests{usesuper::*;#[test]fn parse_binding_usage(){assert_eq!(BindingUsage::new(&amp;#34;abc&amp;#34;),Ok((&amp;#34;&amp;#34;,BindingUsage{name: &amp;#34;abc&amp;#34;.to_string(),},)),);}}Let’s add the definition of BindingUsage:</description></item><item><title>Part Four: Backtracking</title><link>https://arzg.github.io/lang/4/</link><pubDate>Mon, 05 Oct 2020 00:00:00 +0000</pubDate><guid>https://arzg.github.io/lang/4/</guid><description>In this part of the series we’ll start with the goal of allowing Exprs to be numbers. In case you’ve forgotten, at the moment Exprs have to be mathematical operations, making simple things like let x = 5 impossible.
Let’s start by hopping over to Expr’s definition in expr.rs, and changing it to be an enum that can hold either a mathematical operation, or a number:
#[derive(Debug, PartialEq)]pubenum Expr{Number(Number),Operation{lhs: Number,rhs: Number,op: Op},}We’ve got errors appearing all over the place; let’s fix parsing first.</description></item><item><title>Part Three: Defining Variables</title><link>https://arzg.github.io/lang/3/</link><pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate><guid>https://arzg.github.io/lang/3/</guid><description>Welcome back! This time, we’ll parse and evaluate variable definitions.
Parsing Before we can begin writing a parser, we need to decide on a syntax. Since we like Rust, we’ll go for a similar syntax:
leta=5To start off, Eldiro will only include immutable variables, or bindings,1 as they’re sometimes called (at least that’s what I’ll be calling them for the rest of this series).
Although we’d usually start writing a test here, I fear that lib.</description></item><item><title>Part Two: Whitespace Support</title><link>https://arzg.github.io/lang/2/</link><pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate><guid>https://arzg.github.io/lang/2/</guid><description>Last time, we made a parser for simple unnested mathematical expressions, such as 1+1 or 3*4. In this post, we’ll add support for whitespace (so that users of Eldiro will be able to use 2 + 2 instead of 2+2).
We can achieve this by creating an extract_whitespace function similar to extract_digits:
// utils.rs // Let’s copy-paste from extract_digits pub(crate)fn extract_whitespace(s: &amp;amp;str)-&amp;gt; (&amp;amp;str,&amp;amp;str){letwhitespace_end=s.char_indices().find_map(|(idx,c)|ifc==&amp;#39; &amp;#39;{None}else{Some(idx)}).unwrap_or_else(||s.len());letwhitespace=&amp;amp;s[..whitespace_end];letremainder=&amp;amp;s[whitespace_end..];(remainder,whitespace)}#[cfg(test)]mod tests{// snip #[test]fn extract_spaces(){assert_eq!(extract_whitespace(&amp;#34; 1&amp;#34;),(&amp;#34;1&amp;#34;,&amp;#34; &amp;#34;));}}Although this does indeed work, it involves quite a bit of repetition.</description></item><item><title>Part One: A Basic Parser</title><link>https://arzg.github.io/lang/1/</link><pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate><guid>https://arzg.github.io/lang/1/</guid><description>The most fundamental part of any language is the parser1 &amp;ndash; a piece of software whose purpose is to take a flat structure (usually text in some form) and convert it into a tree structure. In this post, we’ll make a parser for mathematical expressions that don’t contain nesting. For example, 1 + 1 is allowed, but 2 * 3 + 4 isn’t (because that’s shorthand for (2 * 3) + 4, and thus contains nesting).</description></item><item><title>Part Zero: Getting set up</title><link>https://arzg.github.io/lang/0/</link><pubDate>Mon, 07 Sep 2020 00:00:00 +0000</pubDate><guid>https://arzg.github.io/lang/0/</guid><description>Let’s create a new Rust project:
$ cargo new --lib error: The following required arguments were not provided: &amp;lt;path&amp;gt; USAGE: cargo new &amp;lt;path&amp;gt; --lib For more information try --help Oh, yeah, we need a name. Hmmm. Let’s open the thesaurus and search for ‘language’:
Speech, writing, conversation … ooh, utterance. I like the sound of that! Time to check if it’s taken.
Damn, it’s already taken. Maybe I can do what so many projects seem to do and use a random non-English word.</description></item></channel></rss>