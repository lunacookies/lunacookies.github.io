<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Part Six: Blocks · arzg’s website</title><link rel=stylesheet href=https://arzg.github.io/scss/main.5b8c013dd5e51a40b743f06124716408dad09d87641389dd50c9b9d63c648588.css integrity="sha256-W4wBPdXlGkC3Q/BhJHFkCNrQnYdkE4ndUMm51jxkhYg="><script src=https://unpkg.com/quicklink@2.0.0/dist/quicklink.umd.js></script>
<script src=https://unpkg.com/anchor-js@4.3.1/anchor.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/plugins/autoloader/prism-autoloader.min.js></script>
<script>window.onload=()=>{quicklink.listen()},document.addEventListener("DOMContentLoaded",function(a){anchors.add("main h1")})</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body><nav class=site-navigation><ul><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li class=current><a href=/lang/>Make A Language</a></li></ul></nav><header class=header-area><h1 class=title>Part Six: Blocks</h1><section class=page-info><ul><li>6 October 2020</li><li>5538 words</li><li>28 minute read</li></ul></section></header><main><p>By the end of this post, Eldiro will have <a href=https://doc.rust-lang.org/reference/expressions/block-expr.html>blocks</a>. By <em>block,</em> I mean the Rust meaning, not one from any other programming language.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><h1 id=what-is-a-block-anyway>What is a block, anyway?</h1><p>In Rust (and Eldiro, once they are implemented), blocks are a way to group a bunch of bindings together and ensure that they are not accessible from outside the block. For example, <code>foo</code> and <code>bar</code> aren’t accessible outside the curly braces.</p><pre><code class=language-rust>{
    let foo = 100;
    let bar = &quot;hello&quot;;
}
</code></pre><p>What makes blocks interesting, though, is how, when evaluated, the value of the entire block is the value of its last expression. For example, the value of this block is <code>2</code>:</p><pre><code class=language-rust>{
    let one = 1;
    one + one
}
</code></pre><p>Because blocks are expressions, we can use them <em>anywhere</em> where an expression can be used. Consider this real-world example of reading a line from <code>STDIN</code>:</p><pre><code class=language-rust>let mut input = String::new();
std::io::stdin().read_line(&amp;mut input)?;
</code></pre><p>We need to explicitly declare <code>input</code> to be <code>mut</code>able. This protects us from accidentally mutating something that should never be changed. Let’s say that <code>input</code> is one of these cases &ndash; we don’t want to alter the user’s input, so it should really be immutable. We can’t remove the <code>mut</code> from <code>input</code> though, because we <em>are</em> mutating it by reading in the line from <code>STDIN</code>.</p><p>One possible solution to this problem is to use a block:</p><pre><code class=language-rust>let input = {
    let mut s = String::new();
    std::io::stdin().read_line(&amp;mut s)?;
    s
};
</code></pre><p><code>input</code> has the same value as before, but now it’s immutable. We have restricted the mutability to the inside of the block, thereby potentially preventing mistakes.</p><p>This is just one example of the usage of blocks &ndash; as you may imagine, they are a useful language feature to have.</p><h1 id=parsing-blocks>Parsing blocks</h1><p>Like always, we will begin with a parser. Create a module called <code>block</code> by adding <code>pub mod block;</code> to <code>lib.rs</code> and creating the file <code>src/block.rs</code>. Let’s get started with a test:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_empty_block() {
        assert_eq!(Block::new(&quot;{}&quot;), Ok((&quot;&quot;, Block { exprs: Vec::new() })));
    }
}
</code></pre><p>Let’s define <code>Block</code>:</p><pre><code class=language-rust>use crate::expr::Expr;

#[derive(Debug, PartialEq)]
pub struct Block {
    pub exprs: Vec&lt;Expr&gt;,
}
</code></pre><p>Notice anything strange here? In our previous Rust examples, blocks could contain both expressions and binding definitions. If we go by the definition above, though, blocks can only contain expressions. The solution to this issue is that blocks actually contain <em>statements,</em> which, in Eldiro’s case, means an enum that can either contain a binding definition or an expression.</p><h1 id=a-detour-into-statements>A detour into statements</h1><p>Add <code>pub mod stmt;</code> to <code>lib.rs</code> and open <code>src/stmt.rs</code> in your editor. Let’s write two tests to make sure that statements can parse both expressions and binding definitions.</p><pre><code class=language-rust>use crate::binding_def::BindingDef;
use crate::expr::Expr;

#[cfg(test)]
mod tests {
    use super::*;
    use crate::expr::{Number, Op};

    #[test]
    fn parse_binding_def() {
        assert_eq!(
            Stmt::new(&quot;let a = 10&quot;),
            Ok((
                &quot;&quot;,
                Stmt::BindingDef(BindingDef {
                    name: &quot;a&quot;.to_string(),
                    val: Expr::Number(Number(10)),
                }),
            )),
        );
    }

    #[test]
    fn parse_expr() {
        assert_eq!(
            Stmt::new(&quot;1+1&quot;),
            Ok((
                &quot;&quot;,
                Stmt::Expr(Expr::Operation {
                    lhs: Number(1),
                    rhs: Number(1),
                    op: Op::Add,
                }),
            )),
        );
    }
}
</code></pre><p>This doesn’t compile, though, because <code>BindingDef</code>’s fields are not public. Let’s go to <code>binding_def.rs</code> and make them <code>pub</code>:</p><pre><code class=language-rust>#[derive(Debug, PartialEq)]
pub struct BindingDef {
    pub name: String,
    pub val: Expr,
}
</code></pre><p>Cool! We now need to write <code>Stmt</code>’s definition:</p><pre><code class=language-rust>// stmt.rs

#[derive(Debug, PartialEq)]
pub enum Stmt {
    BindingDef(BindingDef),
    Expr(Expr),
}
</code></pre><p>Now we can write the parser, which makes use of <a href=/lang/4>backtracking</a>:</p><pre><code class=language-rust>impl Stmt {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        BindingDef::new(s)
            .map(|(s, binding_def)| (s, Self::BindingDef(binding_def)))
            .or_else(|_| Expr::new(s).map(|(s, expr)| (s, Self::Expr(expr))))
    }
}
</code></pre><p>It may look intimidating, but what this is doing is parsing a binding definition and, if successful, turning that into a <code>Stmt::BindingDef</code>. If it’s unsuccessful, it instead tries to parse an <code>Expr</code> and, if that was successful, turns that into a <code>Stmt::Expr</code>.</p><h1 id=back-to-blocks>Back to blocks</h1><p>Now that we have statements, we can go back to <code>block.rs</code> and replace expressions with statements:</p><pre><code class=language-rust>use crate::stmt::Stmt;

#[derive(Debug, PartialEq)]
pub struct Block {
    pub stmts: Vec&lt;Stmt&gt;,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_empty_block() {
        assert_eq!(Block::new(&quot;{}&quot;), Ok((&quot;&quot;, Block { stmts: Vec::new() })));
    }
}
</code></pre><p>Let’s define <code>Block::new</code> in the simplest way that makes the test pass:</p><pre><code class=language-rust>use crate::utils;

// snip

impl Block {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;{}&quot;, s)?;

        Ok((s, Block { stmts: Vec::new() }))
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
running 30 tests
..............................
test result: ok. 30 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Blocks can contain whitespace:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_empty_block_with_whitespace() {
        assert_eq!(Block::new(&quot;{   }&quot;), Ok((&quot;&quot;, Block { stmts: Vec::new() })));
    }
}
</code></pre><p>Making this work is easy: strip away the whitespace between the two braces:</p><pre><code class=language-rust>impl Block {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;{&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);
        let s = utils::tag(&quot;}&quot;, s)?;

        Ok((s, Block { stmts: Vec::new() }))
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
running 31 tests
...............................
test result: ok. 31 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Let’s now try parsing a block with a single statement:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::*;
    use crate::expr::{Expr, Number};

    // snip

    #[test]
    fn parse_block_with_one_stmt() {
        assert_eq!(
            Block::new(&quot;{ 5 }&quot;),
            Ok((
                &quot;&quot;,
                Block {
                    stmts: vec![Stmt::Expr(Expr::Number(Number(5)))],
                },
            )),
        );
    }
}
</code></pre><p>The easiest way to make the test pass is to try parsing just one statement, and, if it fails, use an empty vector of statements:</p><pre><code class=language-rust>impl Block {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;{&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, stmts) = if let Ok((s, stmt)) = Stmt::new(s) {
            (s, vec![stmt])
        } else {
            (s, Vec::new())
        };

        let (s, _) = utils::extract_whitespace(s);
        let s = utils::tag(&quot;}&quot;, s)?;

        Ok((s, Block { stmts }))
    }
}
</code></pre><p>It works:</p><pre><code class=language-->$ cargo t -q
running 32 tests
................................
test result: ok. 32 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Let’s now write a test for multiple statements:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::*;
    use crate::binding_def::BindingDef;
    use crate::expr::{Expr, Number};

    // snip

    #[test]
    fn parse_block_with_multiple_stmts() {
        assert_eq!(
            Block::new(
                &quot;{
    let a = 10
    let b = a
    b
}&quot;,
            ),
            Ok((
                &quot;&quot;,
                Block {
                    stmts: vec![
                        Stmt::BindingDef(BindingDef {
                            name: &quot;a&quot;.to_string(),
                            val: Expr::Number(Number(10)),
                        }),
                        Stmt::BindingDef(BindingDef {
                            name: &quot;b&quot;.to_string(),
                            val: ?, // what do we put here?
                        }),
                        Stmt::Expr(?), // and here?
                    ],
                },
            )),
        );
    }
}
</code></pre><p>What do we write where those question marks are? We’re meant to put something of the type <code>Expr</code>, but what we have there is a <code>BindingUsage</code>. It looks like we’ve forgotten (I take full responsibility) to make <code>BindingUsage</code>s expressions!</p><p>Let’s quickly fix the error that came up when we tried to use <code>BindingUsage</code>’s private field <code>name</code> in that test:</p><pre><code class=language-rust>// binding_usage.rs

#[derive(Debug, PartialEq)]
pub struct BindingUsage {
    pub name: String,
}
</code></pre><h1 id=making-bindingusage-and-block-expressions>Making <code>BindingUsage</code> and <code>Block</code> expressions</h1><p>Let’s re-organise <code>binding_usage</code> and <code>block</code> to be inside of the <code>expr</code> module &ndash; after all, binding usages and blocks are expressions.</p><pre><code class=language-->$ mkdir src/expr/
$ mv src/binding_usage.rs src/expr/
$ mv src/block.rs src/expr/
</code></pre><p>Then move <code>pub mod binding_usage;</code> and <code>pub mod block;</code> from <code>lib.rs</code> into <code>expr.rs</code>. To keep things nice and tidy, let’s change the imports in <code>crate::expr::block::tests</code> to be like this:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // change this:
    use super::*;
    use crate::binding_def::BindingDef;
    use crate::expr::{Expr, Number};

    // to this:
    use super::super::{Expr, Number};
    use super::*;
    use crate::binding_def::BindingDef;

    // The rest of the tests stay here.
}
</code></pre><p>This way, if we ever decide to move the <code>expr</code> module somewhere else, the imports won’t break.</p><p>Let’s jump back to <code>expr.rs</code> and add tests for parsing expressions and blocks so that we can be sure we’ve integrated the parsers correctly.</p><pre><code class=language-rust>pub mod binding_usage;
pub mod block;

use crate::utils;
use crate::val::Val;
use binding_usage::BindingUsage;
use block::Block;

// snip

#[cfg(test)]
mod tests {
    use super::*;
    use crate::stmt::Stmt;

    // snip

    #[test]
    fn parse_binding_usage() {
        assert_eq!(
            Expr::new(&quot;bar&quot;),
            Ok((
                &quot;&quot;,
                Expr::BindingUsage(BindingUsage {
                    name: &quot;bar&quot;.to_string(),
                }),
            )),
        );
    }

    #[test]
    fn parse_block() {
        assert_eq!(
            Expr::new(&quot;{ 200 }&quot;),
            Ok((
                &quot;&quot;,
                Expr::Block(Block {
                    stmts: vec![Stmt::Expr(Expr::Number(Number(200)))],
                }),
            )),
        );
    }

    // snip
}
</code></pre><p>We now need to update <code>Expr</code>’s definition to match:</p><pre><code class=language-rust>#[derive(Debug, PartialEq)]
pub enum Expr {
    Number(Number),
    Operation { lhs: Number, rhs: Number, op: Op },
    BindingUsage(BindingUsage),
    Block(Block),
}
</code></pre><p>We also need to update <code>Expr::new</code> so that it tries to parse binding usages and blocks:</p><pre><code class=language-rust>impl Expr {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        Self::new_operation(s)
            .or_else(|_| Self::new_number(s))
            .or_else(|_| {
                BindingUsage::new(s)
                    .map(|(s, binding_usage)| (s, Self::BindingUsage(binding_usage)))
            })
            .or_else(|_| Block::new(s).map(|(s, block)| (s, Self::Block(block))))
    }

    // snip
}
</code></pre><h1 id=getting-back-to-work>Getting back to work</h1><p>Let’s go back to that massive test we were writing for parsing blocks &ndash; the one with the question marks. Now, we can fill in those two fields with <code>Expr::BindingUsage</code>s:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::super::{BindingUsage, Expr, Number};
    use super::*;
    use crate::binding_def::BindingDef;

    // snip

    #[test]
    fn parse_block_with_multiple_stmts() {
        assert_eq!(
            Block::new(
                &quot;{
    let a = 10
    let b = a
    b
}&quot;,
            ),
            Ok((
                &quot;&quot;,
                Block {
                    stmts: vec![
                        Stmt::BindingDef(BindingDef {
                            name: &quot;a&quot;.to_string(),
                            val: Expr::Number(Number(10)),
                        }),
                        Stmt::BindingDef(BindingDef {
                            name: &quot;b&quot;.to_string(),
                            val: Expr::BindingUsage(BindingUsage {
                                name: &quot;a&quot;.to_string(),
                            }),
                        }),
                        Stmt::Expr(Expr::BindingUsage(BindingUsage {
                            name: &quot;b&quot;.to_string(),
                        })),
                    ],
                },
            )),
        );
    }
}
</code></pre><p>How are we going to make this test pass? Let’s take a look at how we are currently parsing blocks:</p><pre><code class=language-rust>impl Block {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;{&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, stmts) = if let Ok((s, stmt)) = Stmt::new(s) {
            (s, vec![stmt])
        } else {
            (s, Vec::new())
        };

        let (s, _) = utils::extract_whitespace(s);
        let s = utils::tag(&quot;}&quot;, s)?;

        Ok((s, Block { stmts }))
    }
}
</code></pre><p>The solution is to create a loop that continuously updates <code>s</code> and keeps pushing to a <code>Vec&lt;Stmt></code> until parsing a <code>Stmt</code> fails:</p><pre><code class=language-rust>impl Block {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;{&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let mut s = s;
        let mut stmts = Vec::new();

        while let Ok((new_s, stmt)) = Stmt::new(s) {
            s = new_s;
            stmts.push(stmt);
        }

        let (s, _) = utils::extract_whitespace(s);
        let s = utils::tag(&quot;}&quot;, s)?;

        Ok((s, Block { stmts }))
    }
}
</code></pre><p>We can’t check if we’re right, though, as we have a compilation error elsewhere in the project. The problem is in <code>Expr::eval</code>; more specifically, Rust is complaining that we haven’t handled the cases of evaluating binding usages or blocks. For now, we’ll tell Rust that those are a work-in-progress, and that we’ll come back to it later:</p><pre><code class=language-rust>// expr.rs

impl Expr {
    // snip

    pub(crate) fn eval(&amp;self) -&gt; Val {
        match self {
            Self::Number(Number(n)) =&gt; Val::Number(*n),
            Self::Operation { lhs, rhs, op } =&gt; {
                let Number(lhs) = lhs;
                let Number(rhs) = rhs;

                let result = match op {
                    Op::Add =&gt; lhs + rhs,
                    Op::Sub =&gt; lhs - rhs,
                    Op::Mul =&gt; lhs * rhs,
                    Op::Div =&gt; lhs / rhs,
                };

                Val::Number(result)
            }
            _ =&gt; todo!(),
        }
    }
}
</code></pre><p>Let’s see if it works:</p><pre><code class=language-->$ cargo t -q
running 35 tests
...........F.......................
failures:

---- expr::block::tests::parse_block_with_multiple_stmts stdout ----
thread 'expr::block::tests::parse_block_with_multiple_stmts' panicked at 'assertion failed: `(left == right)`
  left: `Err(&quot;expected }&quot;)`,
 right: `Ok((&quot;&quot;, Block { stmts: [BindingDef(BindingDef { name: &quot;a&quot;, val: Number(Number(10)) }), BindingDef(BindingDef { name: &quot;b&quot;, val: BindingUsage(BindingUsage { name: &quot;a&quot; }) }), Expr(BindingUsage(BindingUsage { name: &quot;b&quot; }))] }))`', src/expr/block.rs:60:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    expr::block::tests::parse_block_with_multiple_stmts

test result: FAILED. 34 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Oof! Let’s add in a debug print to see where we went wrong:</p><pre><code class=language-rust>impl Block {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;{&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let mut s = dbg!(s); // here
        let mut stmts = Vec::new();

        while let Ok((new_s, stmt)) = Stmt::new(s) {
            s = new_s;
            stmts.push(stmt);
        }

        let (s, _) = utils::extract_whitespace(s);
        let s = utils::tag(&quot;}&quot;, s)?;

        Ok((s, Block { stmts }))
    }
}
</code></pre><p>Let’s run the tests again:</p><pre><code>running 35 tests
.......F...........................
failures:

---- expr::block::tests::parse_block_with_multiple_stmts stdout ----
[src/expr/block.rs:14] s = &quot;\n    let a = 10\n    let b = a\n    b\n}&quot;
thread 'expr::block::tests::parse_block_with_multiple_stmts' panicked at 'assertion failed: `(left == right)`
  left: `Err(&quot;expected }&quot;)`,
 right: `Ok((&quot;&quot;, Block { stmts: [BindingDef(BindingDef { name: &quot;a&quot;, val: Number(Number(10)) }), BindingDef(BindingDef { name: &quot;b&quot;, val: BindingUsage(BindingUsage { name: &quot;a&quot; }) }), Expr(BindingUsage(BindingUsage { name: &quot;b&quot; }))] }))`', src/expr/block.rs:60:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    expr::block::tests::parse_block_with_multiple_stmts

test result: FAILED. 34 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Ahah! Take a look at that newline at the start of <code>s</code>. You’d expect that the <code>utils::extract_whitespace</code> call right before the debug print would’ve stripped that off, but it didn’t. This is because <code>utils::extract_whitespace</code> only deals with spaces, not newlines. Let’s fix this (don’t forget to remove the debug print!):</p><pre><code class=language-rust>// utils.rs

// snip

const WHITESPACE: &amp;[char] = &amp;[' ', '\n'];

pub(crate) fn extract_whitespace(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    take_while(|c| WHITESPACE.contains(&amp;c), s)
}

pub(crate) fn extract_whitespace1(s: &amp;str) -&gt; Result&lt;(&amp;str, &amp;str), String&gt; {
    take_while1(
        |c| WHITESPACE.contains(&amp;c),
        s,
        &quot;expected whitespace&quot;.to_string(),
    )
}

// snip

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn extract_newlines_or_spaces() {
        assert_eq!(extract_whitespace(&quot; \n   \n\nabc&quot;), (&quot;abc&quot;, &quot; \n   \n\n&quot;));
    }

    #[test]
    fn do_not_extract_spaces1_when_input_does_not_start_with_them() {
        assert_eq!(
            extract_whitespace1(&quot;blah&quot;),
            Err(&quot;expected whitespace&quot;.to_string()),
        );
    }

    // snip
}
</code></pre><p>Let’s run our tests and see how we went:</p><pre><code class=language-->$ cargo t -q
running 36 tests
......F....F........................
failures:

---- expr::block::tests::parse_block_with_multiple_stmts stdout ----
thread 'expr::block::tests::parse_block_with_multiple_stmts' panicked at 'assertion failed: `(left == right)`
  left: `Err(&quot;expected }&quot;)`,
 right: `Ok((&quot;&quot;, Block { stmts: [BindingDef(BindingDef { name: &quot;a&quot;, val: Number(Number(10)) }), BindingDef(BindingDef { name: &quot;b&quot;, val: BindingUsage(BindingUsage { name: &quot;a&quot; }) }), Expr(BindingUsage(BindingUsage { name: &quot;b&quot; }))] }))`', src/expr/block.rs:60:9

---- binding_def::tests::cannot_parse_binding_def_without_space_after_let stdout ----
thread 'binding_def::tests::cannot_parse_binding_def_without_space_after_let' panicked at 'assertion failed: `(left == right)`
  left: `Err(&quot;expected whitespace&quot;)`,
 right: `Err(&quot;expected a space&quot;)`', src/binding_def.rs:63:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    binding_def::tests::cannot_parse_binding_def_without_space_after_let
    expr::block::tests::parse_block_with_multiple_stmts

test result: FAILED. 34 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Not again; that same bug from before is still there! The second failure is easy to fix, though &ndash; it’s an old error message that we just updated:</p><pre><code class=language-rust>// binding_def.rs

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn cannot_parse_binding_def_without_space_after_let() {
        assert_eq!(
            BindingDef::new(&quot;letaaa=1+2&quot;),
            Err(&quot;expected a space&quot;.to_string()),
        );
    }
}
</code></pre><p>Run the tests!</p><pre><code class=language-->$ cargo t -q
running 36 tests
.........F..........................
failures:

---- expr::block::tests::parse_block_with_multiple_stmts stdout ----
thread 'expr::block::tests::parse_block_with_multiple_stmts' panicked at 'assertion failed: `(left == right)`
  left: `Err(&quot;expected }&quot;)`,
 right: `Ok((&quot;&quot;, Block { stmts: [BindingDef(BindingDef { name: &quot;a&quot;, val: Number(Number(10)) }), BindingDef(BindingDef { name: &quot;b&quot;, val: BindingUsage(BindingUsage { name: &quot;a&quot; }) }), Expr(BindingUsage(BindingUsage { name: &quot;b&quot; }))] }))`', src/expr/block.rs:60:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    expr::block::tests::parse_block_with_multiple_stmts

test result: FAILED. 35 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Great! One down, one to go. To try and squash this last bug, let’s add a couple more debug prints:</p><pre><code class=language-rust>// block.rs

impl Block {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;{&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let mut s = dbg!(s); // here
        let mut stmts = Vec::new();

        while let Ok((new_s, stmt)) = Stmt::new(s) {
            s = dbg!(new_s); // here
            stmts.push(stmt);
            dbg!(&amp;stmts); // and here
        }

        let (s, _) = utils::extract_whitespace(s);
        let s = utils::tag(&quot;}&quot;, s)?;

        Ok((s, Block { stmts }))
    }
}
</code></pre><p>I wonder what we’ll see …</p><pre><code class=language-->$ cargo t -q
running 36 tests
...................F................
failures:

---- expr::block::tests::parse_block_with_multiple_stmts stdout ----
[src/expr/block.rs:14] s = &quot;let a = 10\n    let b = a\n    b\n}&quot;
[src/expr/block.rs:18] new_s = &quot;\n    let b = a\n    b\n}&quot;
[src/expr/block.rs:20] &amp;stmts = [
    BindingDef(
        BindingDef {
            name: &quot;a&quot;,
            val: Number(
                Number(
                    10,
                ),
            ),
        },
    ),
]
thread 'expr::block::tests::parse_block_with_multiple_stmts' panicked at 'assertion failed: `(left == right)`
  left: `Err(&quot;expected }&quot;)`,
 right: `Ok((&quot;&quot;, Block { stmts: [BindingDef(BindingDef { name: &quot;a&quot;, val: Number(Number(10)) }), BindingDef(BindingDef { name: &quot;b&quot;, val: BindingUsage(BindingUsage { name: &quot;a&quot; }) }), Expr(BindingUsage(BindingUsage { name: &quot;b&quot; }))] }))`', src/expr/block.rs:61:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    expr::block::tests::parse_block_with_multiple_stmts

test result: FAILED. 35 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Ah, I think I’ve figured it out: we never strip off the whitespace between statements, causing <code>Stmt::new</code> to error out on the next iteration of the loop, which exits the loop. We then remove the leading whitespace, leaving <code>utils::tag</code> to stumble across <code>let</code>, rather than the expected <code>}</code>.</p><p>Here’s the fix:</p><pre><code class=language-rust>impl Block {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;{&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let mut s = s;
        let mut stmts = Vec::new();

        while let Ok((new_s, stmt)) = Stmt::new(s) {
            s = new_s;
            stmts.push(stmt);

            let (new_s, _) = utils::extract_whitespace(s);
            s = new_s;
        }

        let (s, _) = utils::extract_whitespace(s);
        let s = utils::tag(&quot;}&quot;, s)?;

        Ok((s, Block { stmts }))
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
running 36 tests
....................................
test result: ok. 36 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Fantastic!</p><h1 id=evaluating-blocks>Evaluating blocks</h1><p>Now that we’re done with parsing blocks, we can move on to evaluating them. Open up <code>expr.rs</code> and scroll down to that <code>todo!()</code> we added earlier:</p><pre><code class=language-rust>impl Expr {
    pub(crate) fn eval(&amp;self) -&gt; Val {
        match self {
            Self::Number(Number(n)) =&gt; Val::Number(*n),
            Self::Operation { lhs, rhs, op } =&gt; {
                let Number(lhs) = lhs;
                let Number(rhs) = rhs;

                let result = match op {
                    Op::Add =&gt; lhs + rhs,
                    Op::Sub =&gt; lhs - rhs,
                    Op::Mul =&gt; lhs * rhs,
                    Op::Div =&gt; lhs / rhs,
                };

                Val::Number(result)
            }
            _ =&gt; todo!(),
        }
    }
}
</code></pre><p>That wildcard pattern (<code>_</code>) catches both <code>Expr::BindingUsage</code> and <code>Expr::Block</code>; let’s add a test for evaluating <code>Expr::BindingUsage</code> first:</p><pre><code class=language-rust>pub mod binding_usage;
pub mod block;

use crate::env::Env;
use crate::utils;
use crate::val::Val;
use binding_usage::BindingUsage;
use block::Block;

// snip

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_binding_usage() {
        let mut env = Env::default();
        env.store_binding(&quot;ten&quot;.to_string(), Val::Number(10));

        assert_eq!(
            Expr::BindingUsage(BindingUsage {
                name: &quot;ten&quot;.to_string(),
            })
            .eval(&amp;env),
            Ok(Val::Number(10)),
        );
    }
}
</code></pre><p>Remember that the <code>eval</code> method needs to have access to an <code>Env</code> so that it can obtain the values of bindings, and that it needs to return a <code>Result</code> in case the binding being used doesn’t exist. Both of these things aren’t true for the current implementation of <code>Expr::eval</code>.</p><p>Let’s make <code>Expr::eval</code> take a reference to an <code>Env</code> and return a <code>Result</code>:</p><pre><code class=language-rust>impl Expr {
    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        match self {
            Self::Number(Number(n)) =&gt; Ok(Val::Number(*n)),
            Self::Operation { lhs, rhs, op } =&gt; {
                let Number(lhs) = lhs;
                let Number(rhs) = rhs;

                let result = match op {
                    Op::Add =&gt; lhs + rhs,
                    Op::Sub =&gt; lhs - rhs,
                    Op::Mul =&gt; lhs * rhs,
                    Op::Div =&gt; lhs / rhs,
                };

                Ok(Val::Number(result))
            }
            _ =&gt; todo!(),
        }
    }
}
</code></pre><p>We now need to update all of <code>Expr::eval</code>’s tests:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_add() {
        assert_eq!(
            Expr::Operation {
                lhs: Number(10),
                rhs: Number(10),
                op: Op::Add,
            }
            .eval(&amp;Env::default()),
            Ok(Val::Number(20)),
        );
    }

    #[test]
    fn eval_sub() {
        assert_eq!(
            Expr::Operation {
                lhs: Number(1),
                rhs: Number(5),
                op: Op::Sub,
            }
            .eval(&amp;Env::default()),
            Ok(Val::Number(-4)),
        );
    }

    #[test]
    fn eval_mul() {
        assert_eq!(
            Expr::Operation {
                lhs: Number(5),
                rhs: Number(6),
                op: Op::Mul,
            }
            .eval(&amp;Env::default()),
            Ok(Val::Number(30)),
        );
    }

    #[test]
    fn eval_div() {
        assert_eq!(
            Expr::Operation {
                lhs: Number(200),
                rhs: Number(20),
                op: Op::Div,
            }
            .eval(&amp;Env::default()),
            Ok(Val::Number(10)),
        );
    }

    // snip
}
</code></pre><p>The change to <code>Expr::eval</code>’s signature has caused some other errors, too:</p><pre><code class=language-->$ cargo c
    Checking eldiro v0.1.0 (/home/me/src/eldiro)
error[E0061]: this function takes 1 argument but 0 arguments were supplied
  --&gt; src/binding_def.rs:34:55
   |
34 |         env.store_binding(self.name.clone(), self.val.eval());
   |                                                       ^^^^- supplied 0 arguments
   |                                                       |
   |                                                       expected 1 argument
   |
  ::: src/expr.rs:73:5
   |
73 |     pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
   |     ----------------------------------------------------------- defined here

error[E0308]: mismatched types
  --&gt; src/binding_def.rs:34:46
   |
34 |         env.store_binding(self.name.clone(), self.val.eval());
   |                                              ^^^^^^^^^^^^^^^ expected enum `val::Val`, found enum `std::result::Result`
   |
   = note: expected enum `val::Val`
              found enum `std::result::Result&lt;val::Val, std::string::String&gt;`

error: aborting due to 2 previous errors
</code></pre><p>Looks like we have to update <code>BindingDef::eval</code>:</p><pre><code class=language-rust>impl BindingDef {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;mut Env) -&gt; Result&lt;(), String&gt; {
        env.store_binding(self.name.clone(), self.val.eval(env)?);
        Ok(())
    }
}
</code></pre><p>Eldiro compiles now, so let’s run the tests:</p><pre><code class=language-->$ cargo t -q
running 37 tests
..............F......................
failures:

---- expr::tests::eval_binding_usage stdout ----
thread 'expr::tests::eval_binding_usage' panicked at 'not yet implemented', src/expr.rs:89:18
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    expr::tests::eval_binding_usage

test result: FAILED. 36 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Oops! I totally forgot about that <code>todo!()</code>. Let’s add a specific case to the <code>match</code> in <code>Expr::eval</code> for <code>Expr::BindingUsage</code>:</p><pre><code class=language-rust>impl Expr {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        match self {
            Self::Number(Number(n)) =&gt; Ok(Val::Number(*n)),
            Self::Operation { lhs, rhs, op } =&gt; {
                let Number(lhs) = lhs;
                let Number(rhs) = rhs;

                let result = match op {
                    Op::Add =&gt; lhs + rhs,
                    Op::Sub =&gt; lhs - rhs,
                    Op::Mul =&gt; lhs * rhs,
                    Op::Div =&gt; lhs / rhs,
                };

                Ok(Val::Number(result))
            }
            Self::BindingUsage(binding_usage) =&gt; binding_usage.eval(env),
            _ =&gt; todo!(),
        }
    }
}
</code></pre><p>I wonder if it all works …</p><pre><code class=language-->$ cargo t -q
running 37 tests
.....................................
test result: ok. 37 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Great! The only thing that’s left is to implement evaluation for blocks.</p><h1 id=actually-evaluating-blocks>Actually evaluating blocks</h1><p>Let’s remove that <code>todo!()</code> in <code>Expr::eval</code> for good, and instead call an imaginary method on <code>Block</code>:</p><pre><code class=language-rust>impl Expr {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        match self {
            Self::Number(Number(n)) =&gt; Ok(Val::Number(*n)),
            Self::Operation { lhs, rhs, op } =&gt; {
                let Number(lhs) = lhs;
                let Number(rhs) = rhs;

                let result = match op {
                    Op::Add =&gt; lhs + rhs,
                    Op::Sub =&gt; lhs - rhs,
                    Op::Mul =&gt; lhs * rhs,
                    Op::Div =&gt; lhs / rhs,
                };

                Ok(Val::Number(result))
            }
            Self::BindingUsage(binding_usage) =&gt; binding_usage.eval(env),
            Self::Block(block) =&gt; block.eval(env),
        }
    }
}
</code></pre><p>We should write a simple test in this file to ensure that everything is integrating properly:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_block() {
        assert_eq!(
            Expr::Block(Block {
                stmts: vec![Stmt::Expr(Expr::Number(Number(10)))],
            })
            .eval(&amp;Env::default()),
            Ok(Val::Number(10)),
        );
    }
}
</code></pre><p>Now that that’s done, we can implement the imaginary method from before. But first, we should write a simple test so that we have something to guide us:</p><pre><code class=language-rust>// block.rs

use crate::env::Env;
use crate::stmt::Stmt;
use crate::utils;
use crate::val::Val;

// snip

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_empty_block() {
        assert_eq!(
            Block { stmts: Vec::new() }.eval(&amp;Env::default()),
            Ok(?),
        );
    }
}
</code></pre><p>What do we want that <code>?</code> to be? In Rust, the value of an empty block is <code>()</code>, also known as the <em>unit</em> or the empty tuple. Eldiro doesn’t have tuples yet, so the easiest option for now is to add a <code>Unit</code> variant to <code>Val</code>:</p><pre><code>// val.rs

#[derive(Debug, Clone, PartialEq)]
pub enum Val {
    Number(i32),
    Unit,
}
</code></pre><p>Although this <em>is</em> intentionally adding <a href=https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/>the Billion Dollar Mistake</a> to the language, eventually it’ll be removed and replaced with an empty tuple.</p><p>Now that that’s in place, we can remove the <code>?</code> from our test and replace it with <code>Val::Unit</code>:</p><pre><code class=language-rust>// block

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_empty_block() {
        assert_eq!(
            Block { stmts: Vec::new() }.eval(&amp;Env::default()),
            Ok(Val::Unit),
        );
    }
}
</code></pre><p>What’s the easiest way to make this test pass?</p><pre><code class=language-rust>impl Block {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        Ok(Val::Unit)
    }
}
</code></pre><p>This does make <em>this one specific test</em> pass, but the test we wrote earlier with the block containing the number <code>10</code> is failing:</p><pre><code class=language-->$ cargo t -q
running 39 tests
..................F....................
failures:

---- expr::tests::eval_block stdout ----
thread 'expr::tests::eval_block' panicked at 'assertion failed: `(left == right)`
  left: `Ok(Unit)`,
 right: `Ok(Number(10))`', src/expr.rs:254:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    expr::tests::eval_block

test result: FAILED. 38 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Let’s write a test just like that, but in <code>block.rs</code>, so we can see all the test cases for evaluating blocks in one place:<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_block_with_one_expr() {
        assert_eq!(
            Block {
                stmts: vec![Stmt::Expr(Expr::Number(Number(25)))],
            }
            .eval(&amp;Env::default()),
            Ok(Val::Number(25)),
        );
    }
}
</code></pre><p>This fails in the same way that <code>crate::expr::tests::eval_block</code> does:</p><pre><code class=language-->$ cargo t -q
running 40 tests
......F.....F...........................
failures:

---- expr::block::tests::eval_block_with_one_expr stdout ----
thread 'expr::block::tests::eval_block_with_one_expr' panicked at 'assertion failed: `(left == right)`
  left: `Ok(Unit)`,
 right: `Ok(Number(25))`', src/expr/block.rs:110:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

---- expr::tests::eval_block stdout ----
thread 'expr::tests::eval_block' panicked at 'assertion failed: `(left == right)`
  left: `Ok(Unit)`,
 right: `Ok(Number(10))`', src/expr.rs:254:9


failures:
    expr::block::tests::eval_block_with_one_expr
    expr::tests::eval_block

test result: FAILED. 38 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>A neat way to make both of these tests pass is to use <code>.last()</code> on the vector of statements that <code>Block</code> contains, combined with an <code>Option</code> combinator to handle the case when the <code>Block</code> is empty:</p><pre><code class=language-rust>impl Block {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        self.stmts.last().map_or(Ok(Val::Unit), |stmt| match stmt {
            Stmt::BindingDef(_) =&gt; todo!(),
            Stmt::Expr(expr) =&gt; expr.eval(env),
        })
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
running 40 tests
........................................
test result: ok. 40 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Cool, that works. We now need to add a test to see if the block maintains the evaluation environment as binding definitions are added:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_block_with_binding_def_and_usage() {
        assert_eq!(
            Block {
                stmts: vec![
                    Stmt::BindingDef(BindingDef {
                        name: &quot;one&quot;.to_string(),
                        val: Expr::Number(Number(1)),
                    }),
                    Stmt::Expr(Expr::BindingUsage(BindingUsage {
                        name: &quot;one&quot;.to_string(),
                    })),
                ],
            }
            .eval(&amp;Env::default()),
            Ok(Val::Number(1)),
        );
    }
}
</code></pre><p>The critical part here is that <code>Block::eval</code> takes an <em>immutable</em> reference to the evaluation environment &ndash; in other words, we are preventing a bug where the block can affect the value of bindings outside it by making use of Rust’s borrowing rules. How are we going to evaluate binding definitions (which need a mutable reference to the <code>Env</code>) if we don’t have mutable access to the evaluation environment, though?</p><p>The solution is to create a <em>new,</em> independent <code>Env</code> inside of <code>Block::eval</code>. This way any bindings created inside of the block are isolated, and we have full permission to create mutable references as we please. Here’s a pretty messy implementation:</p><pre><code class=language-rust>impl Block {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        if self.stmts.is_empty() {
            return Ok(Val::Unit);
        }

        let mut env = Env::default();

        let stmts_except_last = &amp;self.stmts[..self.stmts.len() - 1];
        for stmt in stmts_except_last {
            match stmt {
                Stmt::BindingDef(binding_def) =&gt; binding_def.eval(&amp;mut env)?,
                Stmt::Expr(expr) =&gt; {
                    expr.eval(&amp;env)?;
                }
            }
        }

        // We can unwrap safely here because we have already checked whether self.stmts is empty.
        let last = self.stmts.last().unwrap();

        match last {
            Stmt::BindingDef(binding_def) =&gt; {
                binding_def.eval(&amp;mut env)?;
                Ok(Val::Unit)
            }
            Stmt::Expr(expr) =&gt; expr.eval(&amp;env),
        }
    }
}
</code></pre><p>We check first if the block is empty; if it is, we return early with <code>Val::Unit</code>; otherwise, we go on to loop through all the statements in the block but the last, and evaluate them. The last statement is treated specially, because its value is the value of the entire block. This does all indeed work correctly:</p><pre><code class=language-->$ cargo t -q
running 41 tests
.........................................
test result: ok. 41 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>But the code is repetitive and isn’t clean. Take a look, for example, at the <code>match</code> inside the <code>for</code> loop and at the end of the function: they are similar, and could be abstracted into a function. Let’s extract it into <code>Stmt::eval</code>:</p><pre><code class=language-rust>// stmt.rs

use crate::binding_def::BindingDef;
use crate::env::Env;
use crate::expr::Expr;
use crate::val::Val;

// snip

impl Stmt {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;mut Env) -&gt; Result&lt;Val, String&gt; {
        match self {
            Self::BindingDef(binding_def) =&gt; {
                binding_def.eval(env)?;
                Ok(Val::Unit)
            }
            Self::Expr(expr) =&gt; expr.eval(env),
        }
    }
}
</code></pre><p>Let’s write a pair of tests to make sure this works:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_binding_def() {
        assert_eq!(
            Stmt::BindingDef(BindingDef {
                name: &quot;whatever&quot;.to_string(),
                val: Expr::Number(Number(-10)),
            })
            .eval(&amp;mut Env::default()),
            Ok(Val::Unit),
        );
    }

    #[test]
    fn eval_expr() {
        assert_eq!(
            Stmt::Expr(Expr::Number(Number(5))).eval(&amp;mut Env::default()),
            Ok(Val::Number(5)),
        );
    }
}
</code></pre><p>We can now go back to <code>Block::eval</code> and make use of <code>Stmt::eval</code>:</p><pre><code class=language-rust>impl Block {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        if self.stmts.is_empty() {
            return Ok(Val::Unit);
        }

        let mut env = Env::default();

        let stmts_except_last = &amp;self.stmts[..self.stmts.len() - 1];
        for stmt in stmts_except_last {
            stmt.eval(&amp;mut env)?;
        }

        // We can unwrap safely here because we have already checked whether self.stmts is empty.
        self.stmts.last().unwrap().eval(&amp;mut env)
    }
}
</code></pre><p>Let’s run the tests to see if we’ve broken anything:</p><pre><code class=language-->$ cargo t -q
running 43 tests
...........................................
test result: ok. 43 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Nope! It’s all in working order.</p><p>I’m not happy with the test suite, though. I think that we need two more tests; specifically, we need a test to check that a block of only binding definitions has a value of <code>Val::Unit</code>, and we also need a test to check that the last statement of the block becomes the value of the entire block.</p><p>Here are the tests to add:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::super::{BindingUsage, Expr, Number, Op};
    use super::*;
    use crate::binding_def::BindingDef;

    // snip

    #[test]
    fn eval_block_with_multiple_binding_defs() {
        assert_eq!(
            Block {
                stmts: vec![
                    Stmt::BindingDef(BindingDef {
                        name: &quot;foo&quot;.to_string(),
                        val: Expr::Number(Number(5)),
                    }),
                    Stmt::BindingDef(BindingDef {
                        name: &quot;bar&quot;.to_string(),
                        val: Expr::Number(Number(4)),
                    }),
                    Stmt::BindingDef(BindingDef {
                        name: &quot;baz&quot;.to_string(),
                        val: Expr::Number(Number(3)),
                    }),
                ],
            }
            .eval(&amp;Env::default()),
            Ok(Val::Unit),
        );
    }

    #[test]
    fn eval_block_with_multiple_exprs() {
        assert_eq!(
            Block {
                stmts: vec![
                    Stmt::Expr(Expr::Number(Number(100))),
                    Stmt::Expr(Expr::Number(Number(30))),
                    Stmt::Expr(Expr::Operation {
                        lhs: Number(10),
                        rhs: Number(7),
                        op: Op::Sub,
                    }),
                ],
            }
            .eval(&amp;Env::default()),
            Ok(Val::Number(3)),
        );
    }
}
</code></pre><p>It turns out that both of these tests pass with the current implementation, which is convenient:</p><pre><code class=language-->$ cargo t -q
running 45 tests
.............................................
test result: ok. 45 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><h1 id=inheriting-bindings-from-parent-env>Inheriting bindings from parent env</h1><p>Have you noticed that the <code>env</code> parameter of <code>Block::eval</code> is unused?</p><p>When a block is evaluated, it should still be able to access all the bindings from the environment it is being evaluated with. For example:</p><pre><code>let foo = 2
let bar = {
    let baz = foo
    baz
}
</code></pre><p><code>foo</code>, which comes from the ‘parent’ <code>Env</code>, is being accessed from within the block.</p><p>Let’s write a test to ensure that Eldiro has this behaviour:</p><pre><code class=language-rust>// block.rs

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_block_using_bindings_from_parent_env() {
        let mut env = Env::default();
        env.store_binding(&quot;foo&quot;.to_string(), Val::Number(2));

        assert_eq!(
            Block {
                stmts: vec![
                    Stmt::BindingDef(BindingDef {
                        name: &quot;baz&quot;.to_string(),
                        val: Expr::BindingUsage(BindingUsage {
                            name: &quot;foo&quot;.to_string(),
                        }),
                    }),
                    Stmt::Expr(Expr::BindingUsage(BindingUsage {
                        name: &quot;baz&quot;.to_string(),
                    })),
                ],
            }
            .eval(&amp;env),
            Ok(Val::Number(2)),
        );
    }
}
</code></pre><p>We haven’t accounted for accessing bindings from the parent <code>Env</code> in the current <code>Block::eval</code> implementation, so the test fails:</p><pre><code class=language-->$ cargo t -q
running 46 tests
..........F...................................
failures:

---- expr::block::tests::eval_block_using_bindings_from_parent_env stdout ----
thread 'expr::block::tests::eval_block_using_bindings_from_parent_env' panicked at 'assertion failed: `(left == right)`
  left: `Err(&quot;binding with name ‘foo’ does not exist&quot;)`,
 right: `Ok(Number(2))`', src/expr/block.rs:198:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    expr::block::tests::eval_block_using_bindings_from_parent_env

test result: FAILED. 45 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>The fix for this is incredibly simple: rather than creating an empty environment to evaluate the block’s statements in, we clone the environment that was passed into <code>Block::eval</code>:</p><pre><code class=language-rust>impl Block {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        if self.stmts.is_empty() {
            return Ok(Val::Unit);
        }

        // Doesn’t compile because Env doesn’t implement Clone.
        let mut env = env.clone();

        let stmts_except_last = &amp;self.stmts[..self.stmts.len() - 1];
        for stmt in stmts_except_last {
            stmt.eval(&amp;mut env)?;
        }

        // We can unwrap safely here because we have already checked whether self.stmts is empty.
        self.stmts.last().unwrap().eval(&amp;mut env)
    }
}
</code></pre><p>There is a better way, though: instead of duplicating the values of all the bindings in the parent environment, we can store a <em>reference</em> to the parent environment inside of <code>Env</code>:</p><pre><code class=language-rust>// env.rs

#[derive(Debug, PartialEq, Default)]
pub(crate) struct Env&lt;'parent&gt; {
    bindings: HashMap&lt;String, Val&gt;,
    parent: Option&lt;&amp;'parent Self&gt;,
}
</code></pre><p><code>parent</code> is an <code>Option</code> because at the top of the chain of nested blocks there is an <code>Env</code> that does not have a parent. This can be referred to as the ‘root’.</p><p>We need to adjust the implementation of <code>Env::get_binding_value</code> to recursively ask its parent for the value of a binding, so that, when we get the value of a binding, we keep searching up the chain until we either find the binding, or reach the root, at which point we can return an error.</p><pre><code class=language-rust>impl&lt;'parent&gt; Env&lt;'parent&gt; {
    // snip

    pub(crate) fn get_binding_value(&amp;self, name: &amp;str) -&gt; Result&lt;Val, String&gt; {
        self.get_binding_value_without_error_msg(name)
            .ok_or_else(|| format!(&quot;binding with name ‘{}’ does not exist&quot;, name))
    }

    fn get_binding_value_without_error_msg(&amp;self, name: &amp;str) -&gt; Option&lt;Val&gt; {
        self.bindings.get(name).cloned().or_else(|| {
            self.parent
                .and_then(|parent| parent.get_binding_value_without_error_msg(name))
        })
    }
}
</code></pre><p>We also need a way to create a ‘child’ environment from a parent:</p><pre><code class=language-rust>impl&lt;'parent&gt; Env&lt;'parent&gt; {
    pub(crate) fn create_child(&amp;'parent self) -&gt; Self {
        Self {
            bindings: HashMap::new(),
            parent: Some(self),
        }
    }

    // snip
}
</code></pre><p>We can now update <code>Block::eval</code> to create a child environment from the environment that is passed into the method:</p><pre><code class=language-rust>impl Block {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        if self.stmts.is_empty() {
            return Ok(Val::Unit);
        }

        let mut child_env = env.create_child();

        let stmts_except_last = &amp;self.stmts[..self.stmts.len() - 1];
        for stmt in stmts_except_last {
            stmt.eval(&amp;mut child_env)?;
        }

        // We can unwrap safely here because we have already checked whether self.stmts is empty.
        self.stmts.last().unwrap().eval(&amp;mut child_env)
    }
}
</code></pre><p>As usual, we’ll finish off this post by running the tests:</p><pre><code class=language-->$ cargo t -q
running 46 tests
..............................................
test result: ok. 46 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Thanks for reading! In the next post we’ll create a REPL for Eldiro. This will both allow for some immediate feedback during development, as well as fixing all those warnings about unused functions we’ve been seeing for so long.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Ruby, for example, also has the idea of a block, that coincidentally is different from the Rust meaning.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>The tests in <code>crate::expr</code> don’t count, because those are only there to test that we’ve integrated <code>Block::eval</code> with <code>Expr::eval</code>.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></main><nav class=page-navigation><div class=prev><p class=hint>Previously</p><a href=https://arzg.github.io/lang/5/>Part Five: Binding Usages</a></div><div class=next><p class=hint>Next up</p><a href=https://arzg.github.io/lang/7/>Part Seven: A REPL</a></div><div style=clear:both></div></nav></body></html>