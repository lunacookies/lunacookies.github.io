<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Part Five: Binding Usages · arzg’s website</title><link rel=stylesheet href=https://arzg.github.io/scss/main.04c23afe51262a10ee61829da41f4d7318ff311ed0d0bcbf1db0fde96e3830f4.css integrity="sha256-BMI6/lEmKhDuYYKdpB9Ncxj/MR7Q0Ly/HbD96W44MPQ="><script src=https://unpkg.com/quicklink@2.0.0/dist/quicklink.umd.js></script>
<script src=https://unpkg.com/anchor-js@4.3.1/anchor.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/plugins/autoloader/prism-autoloader.min.js></script>
<script>window.onload=()=>{quicklink.listen()},document.addEventListener("DOMContentLoaded",function(a){anchors.add("main h1")})</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body><nav class=site-navigation><ul><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li class=current><a href=/lang/>Make A Language</a></li></ul></nav><header class=header-area><h1 class=title>Part Five: Binding Usages</h1><section class=page-info><ul><li>5 October 2020</li><li>711 words</li><li>four minute read</li></ul></section></header><main><p>After <a href=/lang/4>Part Four</a>, the longest so far, this will be a relatively short post: we’ll be adding support for binding usages. Here’s the syntax we’re after:</p><pre><code>let a = 10
let b = a
</code></pre><p>where <code>a</code> is a binding usage.</p><h1 id=parsing>Parsing</h1><p>Let’s begin with the parser. Add <code>pub mod binding_usage;</code> to <code>lib.rs</code>, and create a new file at <code>src/binding_usage.rs</code>. As usual, we’ll start with a test:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_binding_usage() {
        assert_eq!(
            BindingUsage::new(&quot;abc&quot;),
            Ok((
                &quot;&quot;,
                BindingUsage {
                    name: &quot;abc&quot;.to_string(),
                },
            )),
        );
    }
}
</code></pre><p>Let’s add the definition of <code>BindingUsage</code>:</p><pre><code class=language-rust>#[derive(Debug, PartialEq)]
pub struct BindingUsage {
    name: String,
}
</code></pre><p>Since the syntax we’re using for binding usages is to simply write out the name of the binding being used,<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> all <code>BindingDef::new</code> has to do is call <code>utils::extract_ident</code>:</p><pre><code class=language-rust>use crate::utils;

// snip

impl BindingUsage {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, name) = utils::extract_ident(s)?;

        Ok((
            s,
            Self {
                name: name.to_string(),
            },
        ))
    }
}
</code></pre><p>Let’s check if the parser is working as expected:</p><pre><code class=language-->$ cargo t -q
running 25 tests
.........................
test result: ok. 25 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Now that the parser is working, we can move on to evaluating these binding usages.</p><h1 id=evaluation>Evaluation</h1><p>It’s been a while since we covered evaluation, so here’s how it works: binding names and their values are stored in the <em>evaluation environment,</em> or <code>Env</code>. Binding definitions add values to the <code>Env</code>, while binding usages reference these.</p><p>First, a test:</p><pre><code class=language-rust>use crate::env::Env;
use crate::utils;
use crate::val::Val;

// snip

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_existing_binding_usage() {
        let mut env = Env::default();
        env.store_binding(&quot;foo&quot;.to_string(), Val::Number(10));

        assert_eq!(
            BindingUsage {
                name: &quot;foo&quot;.to_string(),
            }
            .eval(&amp;env),
            Ok(Val::Number(10)),
        );
    }
}
</code></pre><p>We create an empty environment, and then declare a binding with the name <code>foo</code> and a value of <code>10</code>. After this, we try evaluating a binding usage of the binding with the name <code>foo</code>, and assert that it gives us <code>10</code>. Notice that the output of <code>.eval(&env)</code> is a <code>Result</code> &ndash; this is because we want to return an appropriate error if the binding does not exist.</p><p>Let’s write the <code>eval</code> method:</p><pre><code class=language-rust>impl BindingUsage {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        env.get_binding_value(&amp;self.name)
    }
}
</code></pre><p>This calls a hypothetical <code>Env::get_binding_value</code> method, which we can write now:</p><pre><code class=language-rust>// env.rs

impl Env {
    // snip

    pub(crate) fn get_binding_value(&amp;self, name: &amp;str) -&gt; Result&lt;Val, String&gt; {
        self.bindings
            .get(name)
            .cloned()
            .ok_or_else(|| format!(&quot;binding with name ‘{}’ does not exist&quot;, name))
    }
}
</code></pre><p>We need to use <code>.cloned()</code> because <code>HashMap::get</code> returns a reference to the value, while we want ownership. Keep in mind that using strings for error messages, as we have been doing throughout this series, is unideal &ndash; we’re doing it only because it makes our lives easier for now. Eventually we’ll restructure the project to use custom error enums with <code>Display</code> implementations, but that’s for another day.</p><p>This code doesn’t compile because <code>Val</code> doesn’t implement <code>Clone</code>, so let’s fix that:</p><pre><code class=language-rust>// val.rs

#[derive(Debug, Clone, PartialEq)]
pub enum Val {
    Number(i32),
}
</code></pre><p>We should add a test to verify that the error message for trying to evaluate a non-existent binding is correct:</p><pre><code class=language-rust>// binding_usage.rs

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_non_existent_binding_usage() {
        let empty_env = Env::default();

        assert_eq!(
            BindingUsage {
                name: &quot;i_dont_exist&quot;.to_string(),
            }
            .eval(&amp;empty_env),
            Err(&quot;binding with name ‘i_dont_exist’ does not exist&quot;.to_string()),
        );
    }
}
</code></pre><p>And with that, we’re done:</p><pre><code class=language-->$ cargo t -q
running 27 tests
...........................
test result: ok. 27 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>In the next instalment of the series, we’ll add support for blocks.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>This may seem painfully obvious if you haven’t used languages where this isn’t the case. In actuality, though, there are languages where accessing the value of a binding isn’t as simple as writing out the binding’s name: Bash, for example, insists<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> you prefix the binding’s name with <code>$</code>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Yes, I know that the <code>$</code> is needed because Bash has bare words (how else would you tell if something is a usage of a binding or a bare word?), but who doesn’t like making fun of Bash’s syntax? (seriously though, I can never remember the difference (or lack thereof) between <code>if test condition</code>, <code>if [ condition ]</code> and <code>if [[ condition ]]</code>)&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></main><nav class=page-navigation><div class=prev><p class=hint>Previously</p><a href=https://arzg.github.io/lang/4/>Part Four: Backtracking</a></div><div class=next><p class=hint>Next up</p><a href=https://arzg.github.io/lang/6/>Part Six: Blocks</a></div><div style=clear:both></div></nav></body></html>