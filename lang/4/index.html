<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Part Four: Backtracking · arzg’s website</title><link rel=stylesheet href=https://arzg.github.io/scss/main.04c23afe51262a10ee61829da41f4d7318ff311ed0d0bcbf1db0fde96e3830f4.css integrity="sha256-BMI6/lEmKhDuYYKdpB9Ncxj/MR7Q0Ly/HbD96W44MPQ="><script src=https://unpkg.com/quicklink@2.0.0/dist/quicklink.umd.js></script>
<script src=https://unpkg.com/anchor-js@4.3.1/anchor.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/plugins/autoloader/prism-autoloader.min.js></script>
<script>window.onload=()=>{quicklink.listen()},document.addEventListener("DOMContentLoaded",function(a){anchors.add("main h1")})</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body><nav class=site-navigation><ul><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li class=current><a href=/lang/>Make A Language</a></li></ul></nav><header class=header-area><h1 class=title>Part Four: Backtracking</h1><section class=page-info><ul><li>5 October 2020</li><li>3793 words</li><li>19 minute read</li></ul></section></header><main><p>In this part of the series we’ll start with the goal of allowing <code>Expr</code>s to be numbers. In case you’ve forgotten, at the moment <code>Expr</code>s <em>have</em> to be mathematical operations, making simple things like <code>let x = 5</code> impossible.</p><p>Let’s start by hopping over to <code>Expr</code>’s definition in <code>expr.rs</code>, and changing it to be an enum that can hold either a mathematical operation, or a number:</p><pre><code class=language-rust>#[derive(Debug, PartialEq)]
pub enum Expr {
    Number(Number),
    Operation { lhs: Number, rhs: Number, op: Op },
}
</code></pre><p>We’ve got errors appearing all over the place; let’s fix parsing first. Now, when we’re parsing an <code>Expr</code>, we have multiple possibilities &ndash; we need to figure out whether we are parsing a number or an operation.</p><p>Here’s the current (broken) code for parsing an <code>Expr</code>:</p><pre><code class=language-rust>impl Expr {
    pub fn new(s: &amp;str) -&gt; (&amp;str, Self) {
        let (s, lhs) = Number::new(s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, op) = Op::new(s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, rhs) = Number::new(s);

        (s, Self { lhs, rhs, op })
    }

    // snip
}
</code></pre><p>We first parse a number, then whitespace, then an operator, then whitespace, and finally another number. If the input to the parser is just a number, the point at which it’ll fail is when it tries to parse the operator, because <code>s</code> by then will be an empty string. Note that it <em>won’t</em> fail to parse the whitespace after the number no matter what because <code>utils::extract_whitespace</code> allows an absence of whitespace.</p><p>Let’s take a look at <code>Op::new</code> to see <em>how</em> it’ll fail:</p><pre><code class=language-rust>impl Op {
    pub fn new(s: &amp;str) -&gt; (&amp;str, Self) {
        let (s, op) = utils::extract_op(s);

        let op = match op {
            &quot;+&quot; =&gt; Self::Add,
            &quot;-&quot; =&gt; Self::Sub,
            &quot;*&quot; =&gt; Self::Mul,
            &quot;/&quot; =&gt; Self::Div,
            _ =&gt; unreachable!(),
        };

        (s, op)
    }
}
</code></pre><p>I wonder what happens if <code>utils::extract_op</code> is given an empty string (as <code>s</code> will be if we’re trying to parse a number with <code>Expr::new</code>)?</p><pre><code class=language-rust>// utils.rs

pub(crate) fn extract_op(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    match &amp;s[0..1] {
        &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; =&gt; {}
        _ =&gt; panic!(&quot;bad operator&quot;),
    }

    (&amp;s[1..], &amp;s[0..1])
}
</code></pre><p>Ahah! Given an empty string, <code>utils::extract_op</code> will try to index one byte into the (empty) input &ndash; as seen in <code>&s[0..1]</code> &ndash; which is out of bounds, causing a panic. As you might recall from The Book, <a href=https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html>panic is for unrecoverable errors</a>. Out of bounds indexing is indeed unrecoverable, but trying to parse an operation when you actually have a number? That’s recoverable.</p><p>The parser should be able to recover from the error and realise that, if the operator is not present, we should try parsing a number before giving up. What we need is some way to <em>try</em> a parser, and, if it fails, <em>backtrack</em> and try the next possibility. Three features of Rust and its standard library make this trivial to implement:</p><ul><li><code>Result</code> (<a href=https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html>used for recoverable errors</a>)</li><li>The <code>?</code> operator (used when you want the following behaviour: ‘if the <code>Result</code> is <code>Err</code>, return now; otherwise, get the value from inside the <code>Ok</code> variant’)<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li><li>The <code>or_else</code> <a href=https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.or_else>method</a> on <code>Result</code> (used when you have a <code>Result</code>, and want to execute some code if that <code>Result</code> is <code>Err</code>. We’ll use this to try alternatives in our <code>Expr</code> parser.)</li></ul><p>We’ll start by changing all our parser tests to expect values wrapped in <code>Ok</code>. While we’re doing this, we might as well replace all references to <code>Expr</code> in our tests with <code>Expr::Operation</code> to account for the changes we made to <code>Expr</code> earlier. Here’s <code>binding_def.rs</code>’s new test suite:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::*;
    use crate::expr::{Number, Op};

    #[test]
    fn parse_binding_def() {
        assert_eq!(
            BindingDef::new(&quot;let a = 10 / 2&quot;),
            Ok((
                &quot;&quot;,
                BindingDef {
                    name: &quot;a&quot;.to_string(),
                    val: Expr::Operation {
                        lhs: Number(10),
                        rhs: Number(2),
                        op: Op::Div,
                    },
                },
            )),
        );
    }
}
</code></pre><p>Here are <code>expr.rs</code>’s tests:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_number() {
        assert_eq!(Number::new(&quot;123&quot;), Ok((&quot;&quot;, Number(123))));
    }

    #[test]
    fn parse_add_op() {
        assert_eq!(Op::new(&quot;+&quot;), Ok((&quot;&quot;, Op::Add)));
    }

    #[test]
    fn parse_sub_op() {
        assert_eq!(Op::new(&quot;-&quot;), Ok((&quot;&quot;, Op::Sub)));
    }

    #[test]
    fn parse_mul_op() {
        assert_eq!(Op::new(&quot;*&quot;), Ok((&quot;&quot;, Op::Mul)));
    }

    #[test]
    fn parse_div_op() {
        assert_eq!(Op::new(&quot;/&quot;), Ok((&quot;&quot;, Op::Div)));
    }

    #[test]
    fn parse_one_plus_two() {
        assert_eq!(
            Expr::new(&quot;1+2&quot;),
            Ok((
                &quot;&quot;,
                Expr::Operation {
                    lhs: Number(1),
                    rhs: Number(2),
                    op: Op::Add,
                },
            )),
        );
    }

    #[test]
    fn parse_expr_with_whitespace() {
        assert_eq!(
            Expr::new(&quot;2 * 2&quot;),
            Ok((
                &quot;&quot;,
                Expr::Operation {
                    lhs: Number(2),
                    rhs: Number(2),
                    op: Op::Mul,
                },
            )),
        );
    }

    #[test]
    fn eval_add() {
        assert_eq!(
            Expr::Operation {
                lhs: Number(10),
                rhs: Number(10),
                op: Op::Add,
            }
            .eval(),
            Val::Number(20),
        );
    }

    #[test]
    fn eval_sub() {
        assert_eq!(
            Expr::Operation {
                lhs: Number(1),
                rhs: Number(5),
                op: Op::Sub,
            }
            .eval(),
            Val::Number(-4),
        );
    }

    #[test]
    fn eval_mul() {
        assert_eq!(
            Expr::Operation {
                lhs: Number(5),
                rhs: Number(6),
                op: Op::Mul,
            }
            .eval(),
            Val::Number(30),
        );
    }

    #[test]
    fn eval_div() {
        assert_eq!(
            Expr::Operation {
                lhs: Number(200),
                rhs: Number(20),
                op: Op::Div,
            }
            .eval(),
            Val::Number(10),
        );
    }
}
</code></pre><p>All our extractors from <code>utils.rs</code> cannot fail , so we don’t need to update their tests. (This isn’t true, but just play along for the moment. I’m trying to make this follow my actual workflow when writing code, mistakes and all!) <code>tag</code>, though, <em>can</em> fail, so we need to update its test:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn tag_word() {
        assert_eq!(tag(&quot;let&quot;, &quot;let a&quot;), Ok(&quot; a&quot;));
    }
}
</code></pre><p>Each and every single one of those test changes is another compilation error to add onto the pile &ndash; we better start fixing them!</p><p>Arbitrarily, I have chosen to start at <code>tag</code>, since I still have <code>utils.rs</code> open from a moment ago. Here’s <code>tag</code>’s source to remind you:</p><pre><code class=language-rust>pub(crate) fn tag&lt;'a, 'b&gt;(starting_text: &amp;'a str, s: &amp;'b str) -&gt; &amp;'b str {
    if s.starts_with(starting_text) {
        &amp;s[starting_text.len()..]
    } else {
        panic!(&quot;expected {}&quot;, starting_text);
    }
}
</code></pre><p>This fix is easy! Rather than panicking, we’ll return <code>Result</code>’s <code>Err</code> variant:</p><pre><code class=language-rust>pub(crate) fn tag&lt;'a, 'b&gt;(starting_text: &amp;'a str, s: &amp;'b str) -&gt; &amp;'b str {
    if s.starts_with(starting_text) {
        &amp;s[starting_text.len()..]
    } else {
        Err(format!(&quot;expected {}&quot;, starting_text))
    }
}
</code></pre><p>We still need to wrap the happy path in <code>Ok</code> and change the return type:</p><pre><code class=language-rust>pub(crate) fn tag&lt;'a, 'b&gt;(starting_text: &amp;'a str, s: &amp;'b str) -&gt; Result&lt;&amp;'b str, String&gt; {
    if s.starts_with(starting_text) {
        Ok(&amp;s[starting_text.len()..])
    } else {
        Err(format!(&quot;expected {}&quot;, starting_text))
    }
}
</code></pre><p>Nice! Let’s move on to <code>Expr::new</code>. Again, here’s the current definition:</p><pre><code class=language-rust>impl Expr {
    pub fn new(s: &amp;str) -&gt; (&amp;str, Self) {
        let (s, lhs) = Number::new(s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, op) = Op::new(s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, rhs) = Number::new(s);

        (s, Self { lhs, rhs, op })
    }

    // snip
}
</code></pre><p>Update the return type and wrap the final expression in <code>Ok</code>:</p><pre><code class=language-rust>impl Expr {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, lhs) = Number::new(s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, op) = Op::new(s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, rhs) = Number::new(s);

        Ok((s, Self { lhs, rhs, op }))
    }

    // snip
}
</code></pre><p>Notice that (apart from the compile errors introduced by changing <code>Expr</code> from only representing operations to also representing numbers) this compiles, without us having to use <code>?</code> anywhere. This means that this function <em>doesn’t return an <code>Err</code> anywhere.</em> That’s definitely incorrect. After all, isn’t parsing (for example) an <code>Op</code> meant to return an error if the input does not begin with an operator?</p><p>We need to keep moving, though, so let’s go onwards to <code>Op</code>. Here’s the current version:</p><pre><code class=language-rust>impl Op {
    pub fn new(s: &amp;str) -&gt; (&amp;str, Self) {
        let (s, op) = utils::extract_op(s);

        let op = match op {
            &quot;+&quot; =&gt; Self::Add,
            &quot;-&quot; =&gt; Self::Sub,
            &quot;*&quot; =&gt; Self::Mul,
            &quot;/&quot; =&gt; Self::Div,
            _ =&gt; unreachable!(),
        };

        (s, op)
    }
}
</code></pre><p>We could do the same thing to <code>Op::new</code> as what we just did to <code>Expr::new</code>, but that seemed wrong. Let’s think about how we want <code>Op::new</code> to behave: if it is given an input that doesn’t start with an operator, it should return <code>Err</code>; otherwise, it should return an <code>Op</code> wrapped in <code>Ok</code>.</p><p>Where in this function is the case where it has encountered a non-operator? It’s not on the line with <code>unreachable!</code>, as that case is impossible (<code>utils::extract_op</code> only returns <code>"+"</code>. <code>"-"</code>, <code>"*"</code> or <code>"/"</code>). Hang on a second. What did I say?</p><blockquote><p><code>utils::extract_op</code> only returns <code>"+"</code>. <code>"-"</code>, <code>"*"</code> or <code>"/"</code></p></blockquote><p>That means that <code>utils::extract_op</code> must handle the error case! And indeed, if we look at <code>utils::extract_op</code>, we see the offending <code>panic!</code>:</p><pre><code class=language-rust>pub(crate) fn extract_op(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    match &amp;s[0..1] {
        &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; =&gt; {}
        _ =&gt; panic!(&quot;bad operator&quot;),
    }

    (&amp;s[1..], &amp;s[0..1])
}
</code></pre><p>Now, we <em>could</em> modify this in the same way we did <code>utils::tag</code>, but that’s unnecessary: <code>utils::tag</code> can perform the same task that <code>extract_op</code> does. We can use that <code>or_else</code> method from earlier to try <code>tag</code>ging <code>"+"</code>, and if that fails, try the next alternative, and so on. Let’s get rid of <code>utils::extract_op</code> and all its tests, in favour of rewriting <code>Op::new</code> to use <code>utils::tag</code> instead:</p><pre><code class=language-rust>impl Op {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        utils::tag(&quot;+&quot;, s)
            .map(|s| (s, Self::Add))
            .or_else(|_| utils::tag(&quot;-&quot;, s).map(|s| (s, Self::Sub)))
            .or_else(|_| utils::tag(&quot;*&quot;, s).map(|s| (s, Self::Mul)))
            .or_else(|_| utils::tag(&quot;/&quot;, s).map(|s| (s, Self::Div)))
    }
}
</code></pre><p>Cool! Next up is <code>Number::new</code>:</p><pre><code class=language-rust>impl Number {
    pub fn new(s: &amp;str) -&gt; (&amp;str, Self) {
        let (s, number) = utils::extract_digits(s);
        (s, Self(number.parse().unwrap()))
    }
}
</code></pre><p>This is different to <code>Op::new</code>, in that <em>there is no error case.</em><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> If we look at <code>utils::extract_digits</code>, we see that it uses our <code>take_while</code> convenience function:</p><pre><code class=language-rust>pub(crate) fn extract_digits(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    take_while(|c| c.is_ascii_digit(), s)
}
</code></pre><p>The problem with the usage of <code>take_while</code> in this case is that it is completely happy with an input that is of zero length. For example, if we call <code>extract_digits("hello")</code>, we get back <code>("hello", "")</code>. Although this may be what we want in some cases (e.g. whitespace is often optional, so <code>extract_whitespace</code> not returning an error when it fails to extract any whitespace makes sense), it isn’t what we want in this case. Let’s write a wrapper around <code>take_while</code> that returns an error if the extracted portion is empty:<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><pre><code class=language-rust>pub(crate) fn take_while1(
    accept: impl Fn(char) -&gt; bool,
    s: &amp;str,
    error_msg: String,
) -&gt; Result&lt;(&amp;str, &amp;str), String&gt; {
    let (remainder, extracted) = take_while(accept, s);

    if extracted.is_empty() {
        Err(error_msg)
    } else {
        Ok((remainder, extracted))
    }
}
</code></pre><p>Let’s use this in <code>extract_digits</code>:</p><pre><code class=language-rust>pub(crate) fn extract_digits(s: &amp;str) -&gt; Result&lt;(&amp;str, &amp;str), String&gt; {
    take_while1(|c| c.is_ascii_digit(), s, &quot;expected digits&quot;.to_string())
}
</code></pre><p>To whittle down those compiler errors, let’s <code>Ok</code>-wrap the expected values of all the <code>extract_digits</code> tests we have:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn extract_one_digit() {
        assert_eq!(extract_digits(&quot;1+2&quot;), Ok((&quot;+2&quot;, &quot;1&quot;)));
    }

    #[test]
    fn extract_multiple_digits() {
        assert_eq!(extract_digits(&quot;10-20&quot;), Ok((&quot;-20&quot;, &quot;10&quot;)));
    }

    #[test]
    fn do_not_extract_anything_from_empty_input() {
        assert_eq!(extract_digits(&quot;&quot;), Ok((&quot;&quot;, &quot;&quot;)));
    }

    #[test]
    fn extract_digits_with_no_remainder() {
        assert_eq!(extract_digits(&quot;100&quot;), Ok((&quot;&quot;, &quot;100&quot;)));
    }

    // snip
}
</code></pre><p>We don’t want that <code>do_not_extract_anything_from_empty_input</code> test any more, so let’s replace it with a test that verifies that <code>extract_digits</code> errors out on input that doesn’t start with a digit:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn do_not_extract_digits_when_input_is_invalid() {
        assert_eq!(extract_digits(&quot;abcd&quot;), Err(&quot;expected digits&quot;.to_string()));
    }

    // snip
}
</code></pre><p>After all that we’re finally ready to fix the implementation of <code>Number::new</code>:</p><pre><code class=language-rust>impl Number {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, number) = utils::extract_digits(s)?;
        Ok((s, Self(number.parse().unwrap())))
    }
}
</code></pre><p>Now that all (well, not all &ndash; you’ll see) the basic extractors and parsers that can fail have been explicitly marked as such (by returning <code>Result</code>), we can fix the two main sources of compiler errors left: <code>Expr::new</code>, and <code>BindingDef::new</code>.</p><p>Starting with <code>BindingDef::new</code>, let’s remind ourselves of the present implementation:</p><pre><code class=language-rust>impl BindingDef {
    pub fn new(s: &amp;str) -&gt; (&amp;str, Self) {
        let s = utils::tag(&quot;let&quot;, s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, name) = utils::extract_ident(s);
        let (s, _) = utils::extract_whitespace(s);

        let s = utils::tag(&quot;=&quot;, s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, val) = Expr::new(s);

        (
            s,
            Self {
                name: name.to_string(),
                val,
            },
        )
    }

    // snip
}
</code></pre><p>Fixing this is trivial: all we need to do is sprinkle in some <code>?</code>s, and add an <code>Ok</code> and a <code>Result</code>.</p><pre><code class=language-rust>impl BindingDef {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;let&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, name) = utils::extract_ident(s);
        let (s, _) = utils::extract_whitespace(s);

        let s = utils::tag(&quot;=&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, val) = Expr::new(s)?;

        Ok((
            s,
            Self {
                name: name.to_string(),
                val,
            },
        ))
    }

    // snip
}
</code></pre><p>Now for the big one: <code>Expr::new</code>. We’ll need to put all our newfound knowledge to use, and implement backtracking. Once again, here’s what we’re starting from:</p><pre><code class=language-rust>impl Expr {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, lhs) = Number::new(s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, op) = Op::new(s);
        let (s, _) = utils::extract_whitespace(s);

        let (s, rhs) = Number::new(s);

        Ok((s, Self { lhs, rhs, op }))
    }

    // snip
}
</code></pre><p>The first and most obvious mistake is the lack of <code>?</code>s in all the places where parsers or extractors can fail. Let’s add those:</p><pre><code class=language-rust>impl Expr {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, lhs) = Number::new(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, op) = Op::new(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, rhs) = Number::new(s)?;

        Ok((s, Self { lhs, rhs, op }))
    }

    // snip
}
</code></pre><p>The next issue is how we’re treating <code>Self</code> like it was before we made it into an enum:</p><pre><code class=language-rust>impl Expr {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, lhs) = Number::new(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, op) = Op::new(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, rhs) = Number::new(s)?;

        //      Here ↓
        Ok((s, Self::Operation { lhs, rhs, op }))
    }

    // snip
}
</code></pre><p>Although it compiles now, <code>Expr::new</code> doesn’t handle the case where the input is just a number, not an operation. Thanks to our use of <code>Result</code> everywhere, this will be easy to implement. First, though, we should add a test:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_number_as_expr() {
        assert_eq!(Expr::new(&quot;456&quot;), Ok((&quot;&quot;, Expr::Number(Number(456)))));
    }

    // snip
}
</code></pre><p>Sadly, Eldiro is still not compiling. We’ll violate the laws of TDD (as I have been doing so flagrantly throughout this part) and write the implementation needed to make this test pass, rather than fixing what’s been broken all this time. Let’s start by separating out all the code needed to parse an <code>Expr::Operation</code> into its own method:</p><pre><code class=language-rust>impl Expr {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        Self::new_operation(s)
    }

    fn new_operation(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, lhs) = Number::new(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, op) = Op::new(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, rhs) = Number::new(s)?;

        Ok((s, Self::Operation { lhs, rhs, op }))
    }

    // snip
}
</code></pre><p>Next, we need to add a method for parsing a number:</p><pre><code class=language-rust>impl Expr {
    // snip

    fn new_number(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        Number::new(s).map(|(s, number)| (s, Self::Number(number)))
    }

    // snip
}
</code></pre><p>And, finally, to bring it all together, let’s add the magic line to <code>Expr::new</code> so that it’ll first try parsing an operation, and if that fails try parsing a number:</p><pre><code class=language-rust>impl Expr {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        Self::new_operation(s).or_else(|_| Self::new_number(s))
    }

    // snip
}
</code></pre><p>Phew! It’s finally done. To see if we’ve done it correctly, we need to run our tests. To run our tests, we need Eldiro to compile. The only remaining source of compilation errors left is <code>Expr::eval</code>, which is a holdover from before <code>Expr</code> was an enum. This is easy to fix:</p><pre><code class=language-rust>impl Expr {
    // snip

    pub(crate) fn eval(&amp;self) -&gt; Val {
        match self {
            Self::Number(Number(n)) =&gt; Val::Number(*n),
            Self::Operation { lhs, rhs, op } =&gt; {
                let Number(lhs) = lhs;
                let Number(rhs) = rhs;

                let result = match op {
                    Op::Add =&gt; lhs + rhs,
                    Op::Sub =&gt; lhs - rhs,
                    Op::Mul =&gt; lhs * rhs,
                    Op::Div =&gt; lhs / rhs,
                };

                Val::Number(result)
            }
        }
    }
}
</code></pre><p>The moment of truth has arrived!</p><pre><code class=language-->$ cargo t
   Compiling eldiro v0.1.0 (/home/me/src/eldiro)
warning: associated function is never used: `eval`
  --&gt; src/binding_def.rs:33:19
   |
33 |     pub(crate) fn eval(&amp;self, env: &amp;mut Env) {
   |                   ^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: associated function is never used: `eval`
  --&gt; src/expr.rs:59:19
   |
59 |     pub(crate) fn eval(&amp;self) -&gt; Val {
   |                   ^^^^

warning: associated function is never used: `store_binding`
  --&gt; src/env.rs:10:19
   |
10 |     pub(crate) fn store_binding(&amp;mut self, name: String, val: Val) {
   |                   ^^^^^^^^^^^^^

warning: 3 warnings emitted

warning: associated function is never used: `eval`
  --&gt; src/binding_def.rs:33:19
   |
33 |     pub(crate) fn eval(&amp;self, env: &amp;mut Env) {
   |                   ^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: associated function is never used: `store_binding`
  --&gt; src/env.rs:10:19
   |
10 |     pub(crate) fn store_binding(&amp;mut self, name: String, val: Val) {
   |                   ^^^^^^^^^^^^^

warning: 2 warnings emitted

    Finished test [unoptimized + debuginfo] target(s) in 1.10s
     Running /home/me/.cache/cargo-target/debug/deps/eldiro-4b82c3c57a78933f

running 22 tests
test expr::tests::eval_add ... ok
test binding_def::tests::parse_binding_def ... ok
test expr::tests::eval_div ... ok
test expr::tests::eval_mul ... ok
test expr::tests::eval_sub ... ok
test expr::tests::parse_add_op ... ok
test expr::tests::parse_div_op ... ok
test expr::tests::parse_expr_with_whitespace ... ok
test expr::tests::parse_mul_op ... ok
test expr::tests::parse_number ... ok
test expr::tests::parse_number_as_expr ... ok
test expr::tests::parse_sub_op ... ok
test expr::tests::parse_one_plus_two ... ok
test utils::tests::cannot_extract_ident_beginning_with_number ... ok
test utils::tests::extract_alphabetic_ident ... ok
test utils::tests::do_not_extract_digits_when_input_is_invalid ... ok
test utils::tests::extract_alphanumeric_ident ... ok
test utils::tests::extract_digits_with_no_remainder ... ok
test utils::tests::extract_multiple_digits ... ok
test utils::tests::extract_one_digit ... ok
test utils::tests::extract_spaces ... ok
test utils::tests::tag_word ... ok

test result: ok. 22 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Woohoo!</p><h1 id=i-lied>I lied</h1><p>It’s true. All along in this series, I have not mentioned several serious bugs in our parser, hoping no-one would notice. However, <a href=https://github.com/amosonn>amosonn</a> noticed and <a href=https://github.com/arzg/arzg.github.io/issues/1>reported the bug to me</a>. If only they hadn’t seen! Now that someone’s mentioned it, though, I am obliged to fix it. In keeping with this theme of redemption, hopefully this section will be more test-driven and less messy than what we just went through.</p><p>Here’s the bug: the input <code>letaaa=1+2</code> is parsed by <code>BindingDef::new</code>, without any errors whatsoever. The problem is that the usage of <code>utils::extract_whitespace</code> in <code>BindingDef::new</code> should <em>require</em> whitespace after the <code>let</code> keyword, when currently <code>utils::extract_whitespace</code> accepts inputs that don’t begin with whitespace. What’s more, <code>let = 1+2</code> is also parsed without issue. This stems from a similar problem, this time with <code>utils::extract_ident</code>.</p><p>Let’s fix these issues, starting with the second. Take a look at the test titled <code>cannot_extract_ident_beginning_with_number</code> in <code>utils.rs</code>, as it is the scenario we want to test:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn cannot_extract_ident_beginning_with_number() {
        assert_eq!(extract_ident(&quot;123abc&quot;), (&quot;123abc&quot;, &quot;&quot;));
    }

    // snip
}
</code></pre><p>Instead of just not consuming any input, we want to return an error:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn cannot_extract_ident_beginning_with_number() {
        assert_eq!(
            extract_ident(&quot;123abc&quot;),
            Err(&quot;expected identifier&quot;.to_string()),
        );
    }

    // snip
}
</code></pre><p>Let’s examine the definition of <code>extract_ident</code> so we can get an idea of how to solve this issue:</p><pre><code class=language-rust>pub(crate) fn extract_ident(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    let input_starts_with_alphabetic = s
        .chars()
        .next()
        .map(|c| c.is_ascii_alphabetic())
        .unwrap_or(false);

    if input_starts_with_alphabetic {
        take_while(|c| c.is_ascii_alphanumeric(), s)
    } else {
        (s, &quot;&quot;)
    }
}
</code></pre><p>Ah, so what we want to do is, instead of returning the entire input as leftover if the input doesn’t start with an alphabetic character, we should return an error message:</p><pre><code class=language-rust>pub(crate) fn extract_ident(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    let input_starts_with_alphabetic = s
        .chars()
        .next()
        .map(|c| c.is_ascii_alphabetic())
        .unwrap_or(false);

    if input_starts_with_alphabetic {
        take_while(|c| c.is_ascii_alphanumeric(), s)
    } else {
        Err(&quot;expected identifier&quot;.to_string())
    }
}
</code></pre><p>We still need to change the other case of the <code>if</code> expression and the return type, though:</p><pre><code class=language-rust>pub(crate) fn extract_ident(s: &amp;str) -&gt; Result&lt;(&amp;str, &amp;str), String&gt; {
    let input_starts_with_alphabetic = s
        .chars()
        .next()
        .map(|c| c.is_ascii_alphabetic())
        .unwrap_or(false);

    if input_starts_with_alphabetic {
        Ok(take_while(|c| c.is_ascii_alphanumeric(), s))
    } else {
        Err(&quot;expected identifier&quot;.to_string())
    }
}
</code></pre><p>Now <code>extract_ident</code> compiles, but its tests don’t! We need to <code>Ok</code>-wrap them:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn extract_alphabetic_ident() {
        assert_eq!(extract_ident(&quot;abcdEFG stop&quot;), Ok((&quot; stop&quot;, &quot;abcdEFG&quot;)));
    }

    #[test]
    fn extract_alphanumeric_ident() {
        assert_eq!(extract_ident(&quot;foobar1()&quot;), Ok((&quot;()&quot;, &quot;foobar1&quot;)));
    }

    // snip
}
</code></pre><p>The last compilation error left is in <code>BindingDef::new</code>, where we need to add a <code>?</code>:</p><pre><code class=language-rust>impl BindingDef {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;let&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, name) = utils::extract_ident(s)?; // here
        let (s, _) = utils::extract_whitespace(s);

        let s = utils::tag(&quot;=&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, val) = Expr::new(s)?;

        Ok((
            s,
            Self {
                name: name.to_string(),
                val,
            },
        ))
    }

    // snip
}
</code></pre><p>Let’s see if it works:</p><pre><code class=language-->$ cargo t -q
running 22 tests
......................
test result: ok. 22 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>We’re almost done, now &ndash; all that’s left is fixing the handling of whitespace.</p><p>Here’s the definition of <code>utils::extract_whitespace</code>:</p><pre><code class=language-rust>pub(crate) fn extract_whitespace(s: &amp;str) -&gt; (&amp;str, &amp;str) {
    take_while(|c| c == ' ', s)
}
</code></pre><p>At first you might think that the fix for this is as simple as swapping <code>take_while</code> for <code>take_while1</code>. This will lead to other issues, though, as the <code>=</code> in <code>let a = 10</code> doesn’t <em>need</em> spaces around it, nor does the <code>+</code> in <code>3 + 4</code>. We need a separate extractor for when whitespace is <em>required,</em> rather than optional. Let’s write a test that represents the behaviour we’d like:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn do_not_extract_spaces1_when_input_does_not_start_with_them() {
        assert_eq!(
            extract_whitespace1(&quot;blah&quot;),
            Err(&quot;expected a space&quot;.to_string()),
        );
    }

    // snip
}
</code></pre><p>The implementation that makes this pass is as simple as this:</p><pre><code class=language-rust>pub(crate) fn extract_whitespace1(s: &amp;str) -&gt; Result&lt;(&amp;str, &amp;str), String&gt; {
    take_while1(|c| c == ' ', s, &quot;expected a space&quot;.to_string())
}
</code></pre><p>All that’s left is to use it in <code>BindingDef::new</code> (the only parser so far where spaces are definitely required):</p><pre><code class=language-rust>impl BindingDef {
    pub fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;let&quot;, s)?;
        let (s, _) = utils::extract_whitespace1(s)?; // New!

        let (s, name) = utils::extract_ident(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let s = utils::tag(&quot;=&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, val) = Expr::new(s)?;

        Ok((
            s,
            Self {
                name: name.to_string(),
                val,
            },
        ))
    }

    // snip
}
</code></pre><p>Notice how <code>utils::extract_whitespace1</code> can fail, while <code>utils::extract_whitespace</code> cannot.</p><p>To be sure we’ve fixed the issue, let’s add a test:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn cannot_parse_binding_def_without_space_after_let() {
        assert_eq!(
            BindingDef::new(&quot;letaaa=1+2&quot;),
            Err(&quot;expected a space&quot;.to_string()),
        );
    }
}
</code></pre><p>And …</p><pre><code class=language-->$ cargo t -q
running 24 tests
........................
test result: ok. 24 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>We’re done! See you all next time, when we’ll add support for <em>using</em> the bindings we can create with <code>let</code>.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><code>?</code> <a href=https://doc.rust-lang.org/stable/std/ops/trait.Try.html>can have its behaviour customised</a> for any type on nightly as of the time of writing. In fact, <code>?</code> works with <code>Option</code> on stable Rust today!&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>That <code>.unwrap()</code> might look suspicious, but it’s actually never going to trigger because the string that <code>utils::extract_digits</code> returns always consists entirely of digits, meaning that parsing of that string as an integer will never fail.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>The name for <code>take_while1</code> is meant as ‘<code>take_while</code>, with the extracted text being at least one byte long’. As with <code>tag</code> and <code>take_while</code>, the <a href=https://docs.rs/nom/5/nom/bytes/complete/fn.take_while1.html>name comes from Nom</a>.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></main><nav class=page-navigation><div class=prev><p class=hint>Previously</p><a href=https://arzg.github.io/lang/3/>Part Three: Defining Variables</a></div><div class=next><p class=hint>Next up</p><a href=https://arzg.github.io/lang/5/>Part Five: Binding Usages</a></div><div style=clear:both></div></nav></body></html>