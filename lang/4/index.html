<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Part Four: Backtracking · arzg’s website</title><link rel=stylesheet href=https://arzg.github.io/scss/main.eb0a431b5b4e4bf2b6b68d7aca778d39c8e06896bae0adc551825a2276c27e8a.css integrity="sha256-6wpDG1tOS/K2to16yneNOcjgaJa64K3FUYJaInbCfoo="><script src=https://unpkg.com/quicklink@2.0.0/dist/quicklink.umd.js></script><script>window.onload=()=>{quicklink.listen()}</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body><nav class=site-navigation><ul><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li class=current><a href=/lang/>Make A Language</a></li></ul></nav><header class=header-area><h1 class=title>Part Four: Backtracking</h1><section class=page-info><ul><li>5 October 2020</li><li>2477 words</li><li>twelve minute read</li></ul></section></header><main><p>In this part of the series we’ll start with the goal of allowing <code>Expr</code>s to be numbers. In case you’ve forgotten, at the moment <code>Expr</code>s <em>have</em> to be mathematical operations, making simple things like <code>let x = 5</code> impossible.</p><p>Let’s start by hopping over to <code>Expr</code>’s definition in <code>expr.rs</code>, and changing it to be an enum that can hold either a mathematical operation, or a number:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(Debug, PartialEq)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>Expr</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>Number</span><span class=p>(</span><span class=n>Number</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=n>Operation</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>lhs</span>: <span class=nc>Number</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span>: <span class=nc>Number</span><span class=p>,</span><span class=w> </span><span class=n>op</span>: <span class=nc>Op</span><span class=w> </span><span class=p>},</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>We’ve got errors appearing all over the place; let’s fix parsing first. Now, when we’re parsing an <code>Expr</code>, we have multiple possibilities &ndash; we need to figure out whether we are parsing a number or an operation.</p><p>Here’s the current (broken) code for parsing an <code>Expr</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Expr</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>lhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Op</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>lhs</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>})</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>We first parse a number, then whitespace, then an operator, then whitespace, and finally another number. If the input to the parser is just a number, the point at which it’ll fail is when it tries to parse the operator, because <code>s</code> by then will be an empty string. Note that it <em>won’t</em> fail to parse the whitespace after the number no matter what because <code>utils::extract_whitespace</code> allows an absence of whitespace.</p><p>Let’s take a look at <code>Op::new</code> to see <em>how</em> it’ll fail:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Op</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_op</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;+&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Self</span>::<span class=n>Add</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;-&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Self</span>::<span class=n>Sub</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;*&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Self</span>::<span class=n>Mul</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;/&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Self</span>::<span class=n>Div</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>unreachable</span><span class=o>!</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>I wonder what happens if <code>utils::extract_op</code> is given an empty string (as <code>s</code> will be if we’re trying to parse a number with <code>Expr::new</code>)?</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// utils.rs
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>extract_op</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=o>&amp;</span><span class=n>s</span><span class=p>[</span><span class=mi>0</span><span class=p>..</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=s>&#34;+&#34;</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=s>&#34;-&#34;</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=s>&#34;*&#34;</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=s>&#34;/&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>panic</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;bad operator&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>[</span><span class=mi>1</span><span class=p>..],</span><span class=w> </span><span class=o>&amp;</span><span class=n>s</span><span class=p>[</span><span class=mi>0</span><span class=p>..</span><span class=mi>1</span><span class=p>])</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Ahah! Given an empty string, <code>utils::extract_op</code> will try to index one byte into the (empty) input &ndash; as seen in <code>&s[0..1]</code> &ndash; which is out of bounds, causing a panic. As you might recall from The Book, <a href=https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html>panic is for unrecoverable errors</a>. Out of bounds indexing is indeed unrecoverable, but trying to parse an operation when you actually have a number? That’s recoverable.</p><p>The parser should be able to recover from the error and realise that, if the operator is not present, we should try parsing a number before giving up. What we need is some way to <em>try</em> a parser, and, if it fails, <em>backtrack</em> and try the next possibility. Three features of Rust and its standard library make this trivial to implement:</p><ul><li><code>Result</code> (<a href=https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html>used for recoverable errors</a>)</li><li>The <code>?</code> operator (used when you want the following behaviour: ‘if the <code>Result</code> is <code>Err</code>, return now; otherwise, get the value from inside the <code>Ok</code> variant’)<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li><li>The <code>or_else</code> <a href=https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.or_else>method</a> on <code>Result</code> (used when you have a <code>Result</code>, and want to execute some code if that <code>Result</code> is <code>Err</code>. We’ll use this to try alternatives in our <code>Expr</code> parser.)</li></ul><p>We’ll start by changing all our parser tests to expect values wrapped in <code>Ok</code>. While we’re doing this, we might as well replace all references to <code>Expr</code> in our tests with <code>Expr::Operation</code> to account for the changes we made to <code>Expr</code> earlier. Here’s <code>binding_def.rs</code>’s new test suite:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>crate</span>::<span class=n>expr</span>::<span class=p>{</span><span class=n>Number</span><span class=p>,</span><span class=w> </span><span class=n>Op</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_binding_def</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=n>BindingDef</span>::<span class=n>new</span><span class=p>(</span><span class=s>&#34;let a = 10 / 2&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=nb>Ok</span><span class=p>((</span><span class=w>
</span><span class=w>                </span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>                </span><span class=n>BindingDef</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                    </span><span class=n>name</span>: <span class=s>&#34;a&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span><span class=w>                    </span><span class=n>val</span>: <span class=nc>Expr</span>::<span class=n>Operation</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                        </span><span class=n>lhs</span>: <span class=nc>Number</span><span class=p>(</span><span class=mi>10</span><span class=p>),</span><span class=w>
</span><span class=w>                        </span><span class=n>rhs</span>: <span class=nc>Number</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span><span class=w>
</span><span class=w>                        </span><span class=n>op</span>: <span class=nc>Op</span>::<span class=n>Div</span><span class=p>,</span><span class=w>
</span><span class=w>                    </span><span class=p>},</span><span class=w>
</span><span class=w>                </span><span class=p>},</span><span class=w>
</span><span class=w>            </span><span class=p>)),</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Here are <code>expr.rs</code>’s tests:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_number</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=s>&#34;123&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>Ok</span><span class=p>((</span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Number</span><span class=p>(</span><span class=mi>123</span><span class=p>))));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_add_op</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>Op</span>::<span class=n>new</span><span class=p>(</span><span class=s>&#34;+&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>Ok</span><span class=p>((</span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Op</span>::<span class=n>Add</span><span class=p>)));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_sub_op</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>Op</span>::<span class=n>new</span><span class=p>(</span><span class=s>&#34;-&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>Ok</span><span class=p>((</span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Op</span>::<span class=n>Sub</span><span class=p>)));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_mul_op</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>Op</span>::<span class=n>new</span><span class=p>(</span><span class=s>&#34;*&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>Ok</span><span class=p>((</span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Op</span>::<span class=n>Mul</span><span class=p>)));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_div_op</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>Op</span>::<span class=n>new</span><span class=p>(</span><span class=s>&#34;/&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>Ok</span><span class=p>((</span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Op</span>::<span class=n>Div</span><span class=p>)));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_one_plus_two</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=n>Expr</span>::<span class=n>new</span><span class=p>(</span><span class=s>&#34;1+2&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=nb>Ok</span><span class=p>((</span><span class=w>
</span><span class=w>                </span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>                </span><span class=n>Expr</span>::<span class=n>Operation</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                    </span><span class=n>lhs</span>: <span class=nc>Number</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span><span class=w>
</span><span class=w>                    </span><span class=n>rhs</span>: <span class=nc>Number</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span><span class=w>
</span><span class=w>                    </span><span class=n>op</span>: <span class=nc>Op</span>::<span class=n>Add</span><span class=p>,</span><span class=w>
</span><span class=w>                </span><span class=p>},</span><span class=w>
</span><span class=w>            </span><span class=p>)),</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_expr_with_whitespace</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=n>Expr</span>::<span class=n>new</span><span class=p>(</span><span class=s>&#34;2 * 2&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=nb>Ok</span><span class=p>((</span><span class=w>
</span><span class=w>                </span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=w>
</span><span class=w>                </span><span class=n>Expr</span>::<span class=n>Operation</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                    </span><span class=n>lhs</span>: <span class=nc>Number</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span><span class=w>
</span><span class=w>                    </span><span class=n>rhs</span>: <span class=nc>Number</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span><span class=w>
</span><span class=w>                    </span><span class=n>op</span>: <span class=nc>Op</span>::<span class=n>Mul</span><span class=p>,</span><span class=w>
</span><span class=w>                </span><span class=p>},</span><span class=w>
</span><span class=w>            </span><span class=p>)),</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>eval_add</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=n>Expr</span>::<span class=n>Operation</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>lhs</span>: <span class=nc>Number</span><span class=p>(</span><span class=mi>10</span><span class=p>),</span><span class=w>
</span><span class=w>                </span><span class=n>rhs</span>: <span class=nc>Number</span><span class=p>(</span><span class=mi>10</span><span class=p>),</span><span class=w>
</span><span class=w>                </span><span class=n>op</span>: <span class=nc>Op</span>::<span class=n>Add</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>eval</span><span class=p>(),</span><span class=w>
</span><span class=w>            </span><span class=n>Val</span>::<span class=n>Number</span><span class=p>(</span><span class=mi>20</span><span class=p>),</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>eval_sub</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=n>Expr</span>::<span class=n>Operation</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>lhs</span>: <span class=nc>Number</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span><span class=w>
</span><span class=w>                </span><span class=n>rhs</span>: <span class=nc>Number</span><span class=p>(</span><span class=mi>5</span><span class=p>),</span><span class=w>
</span><span class=w>                </span><span class=n>op</span>: <span class=nc>Op</span>::<span class=n>Sub</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>eval</span><span class=p>(),</span><span class=w>
</span><span class=w>            </span><span class=n>Val</span>::<span class=n>Number</span><span class=p>(</span><span class=o>-</span><span class=mi>4</span><span class=p>),</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>eval_mul</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=n>Expr</span>::<span class=n>Operation</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>lhs</span>: <span class=nc>Number</span><span class=p>(</span><span class=mi>5</span><span class=p>),</span><span class=w>
</span><span class=w>                </span><span class=n>rhs</span>: <span class=nc>Number</span><span class=p>(</span><span class=mi>6</span><span class=p>),</span><span class=w>
</span><span class=w>                </span><span class=n>op</span>: <span class=nc>Op</span>::<span class=n>Mul</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>eval</span><span class=p>(),</span><span class=w>
</span><span class=w>            </span><span class=n>Val</span>::<span class=n>Number</span><span class=p>(</span><span class=mi>30</span><span class=p>),</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>eval_div</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=n>Expr</span>::<span class=n>Operation</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>lhs</span>: <span class=nc>Number</span><span class=p>(</span><span class=mi>200</span><span class=p>),</span><span class=w>
</span><span class=w>                </span><span class=n>rhs</span>: <span class=nc>Number</span><span class=p>(</span><span class=mi>20</span><span class=p>),</span><span class=w>
</span><span class=w>                </span><span class=n>op</span>: <span class=nc>Op</span>::<span class=n>Div</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>eval</span><span class=p>(),</span><span class=w>
</span><span class=w>            </span><span class=n>Val</span>::<span class=n>Number</span><span class=p>(</span><span class=mi>10</span><span class=p>),</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>All our extractors from <code>utils.rs</code> cannot fail , so we don’t need to update their tests. (This isn’t true, but just play along for the moment. I’m trying to make this follow my actual workflow when writing code, mistakes and all!) <code>tag</code>, though, <em>can</em> fail, so we need to update its test:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>tag_word</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>tag</span><span class=p>(</span><span class=s>&#34;let&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;let a&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=s>&#34; a&#34;</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Each and every single one of those test changes is another compilation error to add onto the pile &ndash; we better start fixing them!</p><p>Arbitrarily, I have chosen to start at <code>tag</code>, since I still have <code>utils.rs</code> open from a moment ago. Here’s <code>tag</code>’s source to remind you:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>tag</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=na>&#39;b</span><span class=o>&gt;</span><span class=p>(</span><span class=n>starting_text</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>s</span>: <span class=kp>&amp;</span><span class=na>&#39;b</span><span class=w> </span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;b</span><span class=w> </span><span class=kt>str</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>starts_with</span><span class=p>(</span><span class=n>starting_text</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=o>&amp;</span><span class=n>s</span><span class=p>[</span><span class=n>starting_text</span><span class=p>.</span><span class=n>len</span><span class=p>()..]</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>panic</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;expected {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>starting_text</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>This fix is easy! Rather than panicking, we’ll return <code>Result</code>’s <code>Err</code> variant:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>tag</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=na>&#39;b</span><span class=o>&gt;</span><span class=p>(</span><span class=n>starting_text</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>s</span>: <span class=kp>&amp;</span><span class=na>&#39;b</span><span class=w> </span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;b</span><span class=w> </span><span class=kt>str</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>starts_with</span><span class=p>(</span><span class=n>starting_text</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=o>&amp;</span><span class=n>s</span><span class=p>[</span><span class=n>starting_text</span><span class=p>.</span><span class=n>len</span><span class=p>()..]</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Err</span><span class=p>(</span><span class=n>format</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;expected {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>starting_text</span><span class=p>))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>We still need to wrap the happy path in <code>Ok</code> and change the return type:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>tag</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=na>&#39;b</span><span class=o>&gt;</span><span class=p>(</span><span class=n>starting_text</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>s</span>: <span class=kp>&amp;</span><span class=na>&#39;b</span><span class=w> </span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;&amp;</span><span class=na>&#39;b</span><span class=w> </span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>starts_with</span><span class=p>(</span><span class=n>starting_text</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>[</span><span class=n>starting_text</span><span class=p>.</span><span class=n>len</span><span class=p>()..])</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Err</span><span class=p>(</span><span class=n>format</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;expected {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>starting_text</span><span class=p>))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Nice! Let’s move on to <code>Expr::new</code>. Again, here’s the current definition:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Expr</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>lhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Op</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>lhs</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>})</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Update the return type and wrap the final expression in <code>Ok</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Expr</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>lhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Op</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>((</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>lhs</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>}))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Notice that (apart from the compile errors introduced by changing <code>Expr</code> from only representing operations to also representing numbers) this compiles, without us having to use <code>?</code> anywhere. This means that this function <em>doesn’t return an <code>Err</code> anywhere.</em> That’s definitely incorrect. After all, isn’t parsing (for example) an <code>Op</code> meant to return an error if the input does not begin with an operator?</p><p>We need to keep moving, though, so let’s go onwards to <code>Op</code>. Here’s the current version:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Op</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_op</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;+&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Self</span>::<span class=n>Add</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;-&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Self</span>::<span class=n>Sub</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;*&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Self</span>::<span class=n>Mul</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=s>&#34;/&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Self</span>::<span class=n>Div</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>unreachable</span><span class=o>!</span><span class=p>(),</span><span class=w>
</span><span class=w>        </span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>We could do the same thing to <code>Op::new</code> as what we just did to <code>Expr::new</code>, but that seemed wrong. Let’s think about how we want <code>Op::new</code> to behave: if it is given an input that doesn’t start with an operator, it should return <code>Err</code>; otherwise, it should return an <code>Op</code> wrapped in <code>Ok</code>.</p><p>Where in this function is the case where it has encountered a non-operator? It’s not on the line with <code>unreachable!</code>, as that case is impossible (<code>utils::extract_op</code> only returns <code>"+"</code>. <code>"-"</code>, <code>"*"</code> or <code>"/"</code>). Hang on a second. What did I say?</p><blockquote><p><code>utils::extract_op</code> only returns <code>"+"</code>. <code>"-"</code>, <code>"*"</code> or <code>"/"</code></p></blockquote><p>That means that <code>utils::extract_op</code> must handle the error case! And indeed, if we look at <code>utils::extract_op</code>, we see the offending <code>panic!</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>extract_op</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=o>&amp;</span><span class=n>s</span><span class=p>[</span><span class=mi>0</span><span class=p>..</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=s>&#34;+&#34;</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=s>&#34;-&#34;</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=s>&#34;*&#34;</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=s>&#34;/&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>panic</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;bad operator&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=p>(</span><span class=o>&amp;</span><span class=n>s</span><span class=p>[</span><span class=mi>1</span><span class=p>..],</span><span class=w> </span><span class=o>&amp;</span><span class=n>s</span><span class=p>[</span><span class=mi>0</span><span class=p>..</span><span class=mi>1</span><span class=p>])</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Now, we <em>could</em> modify this in the same way we did <code>utils::tag</code>, but that’s unnecessary: <code>utils::tag</code> can perform the same task that <code>extract_op</code> does. We can use that <code>or_else</code> method from earlier to try <code>tag</code>ging <code>"+"</code>, and if that fails, try the next alternative, and so on. Let’s get rid of <code>utils::extract_op</code> and all its tests, in favour of rewriting <code>Op::new</code> to use <code>utils::tag</code> instead:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Op</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>utils</span>::<span class=n>tag</span><span class=p>(</span><span class=s>&#34;+&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>s</span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>Self</span>::<span class=n>Add</span><span class=p>))</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>or_else</span><span class=p>(</span><span class=o>|</span><span class=n>_</span><span class=o>|</span><span class=w> </span><span class=n>utils</span>::<span class=n>tag</span><span class=p>(</span><span class=s>&#34;-&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>).</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>s</span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>Self</span>::<span class=n>Sub</span><span class=p>)))</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>or_else</span><span class=p>(</span><span class=o>|</span><span class=n>_</span><span class=o>|</span><span class=w> </span><span class=n>utils</span>::<span class=n>tag</span><span class=p>(</span><span class=s>&#34;*&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>).</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>s</span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>Self</span>::<span class=n>Mul</span><span class=p>)))</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>or_else</span><span class=p>(</span><span class=o>|</span><span class=n>_</span><span class=o>|</span><span class=w> </span><span class=n>utils</span>::<span class=n>tag</span><span class=p>(</span><span class=s>&#34;/&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>).</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>s</span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>Self</span>::<span class=n>Div</span><span class=p>)))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Cool! Next up is <code>Number::new</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Number</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>number</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_digits</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>(</span><span class=n>number</span><span class=p>.</span><span class=n>parse</span><span class=p>().</span><span class=n>unwrap</span><span class=p>()))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>This is different to <code>Op::new</code>, in that <em>there is no error case.</em><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> If we look at <code>utils::extract_digits</code>, we see that it uses our <code>take_while</code> convenience function:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>extract_digits</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>take_while</span><span class=p>(</span><span class=o>|</span><span class=n>c</span><span class=o>|</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_digit</span><span class=p>(),</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>The problem with the usage of <code>take_while</code> in this case is that it is completely happy with an input that is of zero length. For example, if we call <code>extract_digits("hello")</code>, we get back <code>("hello", "")</code>. Although this may be what we want in some cases (e.g. whitespace is often optional, so <code>extract_whitespace</code> not returning an error when it fails to extract any whitespace makes sense), it isn’t what we want in this case. Let’s write a wrapper around <code>take_while</code> that returns an error if the extracted portion is empty:<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>take_while1</span><span class=p>(</span><span class=w>
</span><span class=w>    </span><span class=n>accept</span>: <span class=nc>impl</span><span class=w> </span><span class=nb>Fn</span><span class=p>(</span><span class=n>char</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>error_msg</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>remainder</span><span class=p>,</span><span class=w> </span><span class=n>extracted</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>take_while</span><span class=p>(</span><span class=n>accept</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>extracted</span><span class=p>.</span><span class=n>is_empty</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Err</span><span class=p>(</span><span class=n>error_msg</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>((</span><span class=n>remainder</span><span class=p>,</span><span class=w> </span><span class=n>extracted</span><span class=p>))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Let’s use this in <code>extract_digits</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>extract_digits</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>take_while1</span><span class=p>(</span><span class=o>|</span><span class=n>c</span><span class=o>|</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_digit</span><span class=p>(),</span><span class=w> </span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=s>&#34;expected digits&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>())</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>To whittle down those compiler errors, let’s <code>Ok</code>-wrap the expected values of all the <code>extract_digits</code> tests we have:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>extract_one_digit</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>extract_digits</span><span class=p>(</span><span class=s>&#34;1+2&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>Ok</span><span class=p>((</span><span class=s>&#34;+2&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;1&#34;</span><span class=p>)));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>extract_multiple_digits</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>extract_digits</span><span class=p>(</span><span class=s>&#34;10-20&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>Ok</span><span class=p>((</span><span class=s>&#34;-20&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;10&#34;</span><span class=p>)));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>do_not_extract_anything_from_empty_input</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>extract_digits</span><span class=p>(</span><span class=s>&#34;&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>Ok</span><span class=p>((</span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>extract_digits_with_no_remainder</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>extract_digits</span><span class=p>(</span><span class=s>&#34;100&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>Ok</span><span class=p>((</span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;100&#34;</span><span class=p>)));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>We don’t want that <code>do_not_extract_anything_from_empty_input</code> test any more, so let’s replace it with a test that verifies that <code>extract_digits</code> errors out on input that doesn’t start with a digit:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>do_not_extract_digits_when_input_is_invalid</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>extract_digits</span><span class=p>(</span><span class=s>&#34;abcd&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;expected digits&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>After all that we’re finally ready to fix the implementation of <code>Number::new</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Number</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>number</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_digits</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>((</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>(</span><span class=n>number</span><span class=p>.</span><span class=n>parse</span><span class=p>().</span><span class=n>unwrap</span><span class=p>())))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Now that all (well, not all &ndash; you’ll see) the basic extractors and parsers that can fail have been explicitly marked as such (by returning <code>Result</code>), we can fix the two main sources of compiler errors left: <code>Expr::new</code>, and <code>BindingDef::new</code>.</p><p>Starting with <code>BindingDef::new</code>, let’s remind ourselves of the present implementation:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>BindingDef</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>tag</span><span class=p>(</span><span class=s>&#34;let&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_ident</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>tag</span><span class=p>(</span><span class=s>&#34;=&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>val</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Expr</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=n>s</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>name</span>: <span class=nc>name</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span><span class=w>                </span><span class=n>val</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=p>},</span><span class=w>
</span><span class=w>        </span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Fixing this is trivial: all we need to do is sprinkle in some <code>?</code>s, and add an <code>Ok</code> and a <code>Result</code>.</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>BindingDef</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>tag</span><span class=p>(</span><span class=s>&#34;let&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_ident</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>tag</span><span class=p>(</span><span class=s>&#34;=&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>val</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Expr</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>((</span><span class=w>
</span><span class=w>            </span><span class=n>s</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>name</span>: <span class=nc>name</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span><span class=w>                </span><span class=n>val</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=p>},</span><span class=w>
</span><span class=w>        </span><span class=p>))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Now for the big one: <code>Expr::new</code>. We’ll need to put all our newfound knowledge to use, and implement backtracking. Once again, here’s what we’re starting from:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Expr</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>lhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Op</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>((</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>lhs</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>}))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>The first and most obvious mistake is the lack of <code>?</code>s in all the places where parsers or extractors can fail. Let’s add those:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Expr</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>lhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Op</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>((</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>lhs</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>}))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>The next issue is how we’re treating <code>Self</code> like it was before we made it into an enum:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Expr</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>lhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Op</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=c1>//      Here ↓
</span><span class=c1></span><span class=w>        </span><span class=nb>Ok</span><span class=p>((</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>Self</span>::<span class=n>Operation</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>lhs</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>}))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Although it compiles now, <code>Expr::new</code> doesn’t handle the case where the input is just a number, not an operation. Thanks to our use of <code>Result</code> everywhere, this will be easy to implement. First, though, we should add a test:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_number_as_expr</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>Expr</span>::<span class=n>new</span><span class=p>(</span><span class=s>&#34;456&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>Ok</span><span class=p>((</span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Expr</span>::<span class=n>Number</span><span class=p>(</span><span class=n>Number</span><span class=p>(</span><span class=mi>456</span><span class=p>)))));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Sadly, Eldiro is still not compiling. We’ll violate the laws of TDD (as I have been doing so flagrantly throughout this part) and write the implementation needed to make this test pass, rather than fixing what’s been broken all this time. Let’s start by separating out all the code needed to parse an <code>Expr::Operation</code> into its own method:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Expr</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span>::<span class=n>new_operation</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>new_operation</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>lhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Op</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>((</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>Self</span>::<span class=n>Operation</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>lhs</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>}))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Next, we need to add a method for parsing a number:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Exp</span><span class=err></span><span class=n>r</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>new_number</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Number</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>).</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>number</span><span class=p>)</span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>Self</span>::<span class=n>Number</span><span class=p>(</span><span class=n>number</span><span class=p>)))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>And, finally, to bring it all together, let’s add the magic line to <code>Expr::new</code> so that it’ll first try parsing an operation, and if that fails try parsing a number:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Expr</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>Self</span>::<span class=n>new_operation</span><span class=p>(</span><span class=n>s</span><span class=p>).</span><span class=n>or_else</span><span class=p>(</span><span class=o>|</span><span class=n>_</span><span class=o>|</span><span class=w> </span><span class=n>Self</span>::<span class=n>new_number</span><span class=p>(</span><span class=n>s</span><span class=p>))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Phew! It’s finally done. To see if we’ve done it correctly, we need to run our tests. To run our tests, we need Eldiro to compile. The only remaining source of compilation errors left is <code>Expr::eval</code>, which is a holdover from before <code>Expr</code> was an enum. This is easy to fix:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Expr</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>eval</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Val</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=bp>self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>Self</span>::<span class=n>Number</span><span class=p>(</span><span class=n>Number</span><span class=p>(</span><span class=n>n</span><span class=p>))</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Val</span>::<span class=n>Number</span><span class=p>(</span><span class=o>*</span><span class=n>n</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=n>Self</span>::<span class=n>Operation</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>lhs</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>Number</span><span class=p>(</span><span class=n>lhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lhs</span><span class=p>;</span><span class=w>
</span><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>Number</span><span class=p>(</span><span class=n>rhs</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rhs</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                    </span><span class=n>Op</span>::<span class=n>Add</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>lhs</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w>
</span><span class=w>                    </span><span class=n>Op</span>::<span class=n>Sub</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>lhs</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w>
</span><span class=w>                    </span><span class=n>Op</span>::<span class=n>Mul</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>lhs</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w>
</span><span class=w>                    </span><span class=n>Op</span>::<span class=n>Div</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>lhs</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>rhs</span><span class=p>,</span><span class=w>
</span><span class=w>                </span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w>                </span><span class=n>Val</span>::<span class=n>Number</span><span class=p>(</span><span class=n>result</span><span class=p>)</span><span class=w>
</span><span class=w>            </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>The moment of truth has arrived!</p><pre><code class=language-- data-lang=->$ cargo t
   Compiling eldiro v0.1.0 (/home/me/src/eldiro)
warning: associated function is never used: `eval`
  --&gt; src/binding_def.rs:33:19
   |
33 |     pub(crate) fn eval(&amp;self, env: &amp;mut Env) {
   |                   ^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: associated function is never used: `eval`
  --&gt; src/expr.rs:59:19
   |
59 |     pub(crate) fn eval(&amp;self) -&gt; Val {
   |                   ^^^^

warning: associated function is never used: `store_binding`
  --&gt; src/env.rs:10:19
   |
10 |     pub(crate) fn store_binding(&amp;mut self, name: String, val: Val) {
   |                   ^^^^^^^^^^^^^

warning: 3 warnings emitted

warning: associated function is never used: `eval`
  --&gt; src/binding_def.rs:33:19
   |
33 |     pub(crate) fn eval(&amp;self, env: &amp;mut Env) {
   |                   ^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: associated function is never used: `store_binding`
  --&gt; src/env.rs:10:19
   |
10 |     pub(crate) fn store_binding(&amp;mut self, name: String, val: Val) {
   |                   ^^^^^^^^^^^^^

warning: 2 warnings emitted

    Finished test [unoptimized + debuginfo] target(s) in 1.10s
     Running /home/me/.cache/cargo-target/debug/deps/eldiro-4b82c3c57a78933f

running 22 tests
test expr::tests::eval_add ... ok
test binding_def::tests::parse_binding_def ... ok
test expr::tests::eval_div ... ok
test expr::tests::eval_mul ... ok
test expr::tests::eval_sub ... ok
test expr::tests::parse_add_op ... ok
test expr::tests::parse_div_op ... ok
test expr::tests::parse_expr_with_whitespace ... ok
test expr::tests::parse_mul_op ... ok
test expr::tests::parse_number ... ok
test expr::tests::parse_number_as_expr ... ok
test expr::tests::parse_sub_op ... ok
test expr::tests::parse_one_plus_two ... ok
test utils::tests::cannot_extract_ident_beginning_with_number ... ok
test utils::tests::extract_alphabetic_ident ... ok
test utils::tests::do_not_extract_digits_when_input_is_invalid ... ok
test utils::tests::extract_alphanumeric_ident ... ok
test utils::tests::extract_digits_with_no_remainder ... ok
test utils::tests::extract_multiple_digits ... ok
test utils::tests::extract_one_digit ... ok
test utils::tests::extract_spaces ... ok
test utils::tests::tag_word ... ok

test result: ok. 22 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Woohoo!</p><h1 id=i-lied>I lied</h1><p>It’s true. All along in this series, I have not mentioned several serious bugs in our parser, hoping no-one would notice. However, <a href=https://github.com/amosonn>amosonn</a> noticed and <a href=https://github.com/arzg/arzg.github.io/issues/1>reported the bug to me</a>. If only they hadn’t seen! Now that someone’s mentioned it, though, I am obliged to fix it. In keeping with this theme of redemption, hopefully this section will be more test-driven and less messy than what we just went through.</p><p>Here’s the bug: the input <code>letaaa=1+2</code> is parsed by <code>BindingDef::new</code>, without any errors whatsoever. The problem is that the usage of <code>utils::extract_whitespace</code> in <code>BindingDef::new</code> should <em>require</em> whitespace after the <code>let</code> keyword, when currently <code>utils::extract_whitespace</code> accepts inputs that don’t begin with whitespace. What’s more, <code>let = 1+2</code> is also parsed without issue. This stems from a similar problem, this time with <code>utils::extract_ident</code>.</p><p>Let’s fix these issues, starting with the second. Take a look at the test titled <code>cannot_extract_ident_beginning_with_number</code> in <code>utils.rs</code>, as it is the scenario we want to test:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>cannot_extract_ident_beginning_with_number</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>extract_ident</span><span class=p>(</span><span class=s>&#34;123abc&#34;</span><span class=p>),</span><span class=w> </span><span class=p>(</span><span class=s>&#34;123abc&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Instead of just not consuming any input, we want to return an error:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>cannot_extract_ident_beginning_with_number</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=n>extract_ident</span><span class=p>(</span><span class=s>&#34;123abc&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;expected identifier&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()),</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Let’s examine the definition of <code>extract_ident</code> so we can get an idea of how to solve this issue:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>extract_ident</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>input_starts_with_alphabetic</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>chars</span><span class=p>()</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>next</span><span class=p>()</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>c</span><span class=o>|</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_alphabetic</span><span class=p>())</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>unwrap_or</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>input_starts_with_alphabetic</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>take_while</span><span class=p>(</span><span class=o>|</span><span class=n>c</span><span class=o>|</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_alphanumeric</span><span class=p>(),</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Ah, so what we want to do is, instead of returning the entire input as leftover if the input doesn’t start with an alphabetic character, we should return an error message:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>extract_ident</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>input_starts_with_alphabetic</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>chars</span><span class=p>()</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>next</span><span class=p>()</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>c</span><span class=o>|</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_alphabetic</span><span class=p>())</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>unwrap_or</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>input_starts_with_alphabetic</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>take_while</span><span class=p>(</span><span class=o>|</span><span class=n>c</span><span class=o>|</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_alphanumeric</span><span class=p>(),</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;expected identifier&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>())</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>We still need to change the other case of the <code>if</code> expression and the return type, though:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>extract_ident</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>input_starts_with_alphabetic</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>chars</span><span class=p>()</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>next</span><span class=p>()</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>c</span><span class=o>|</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_alphabetic</span><span class=p>())</span><span class=w>
</span><span class=w>        </span><span class=p>.</span><span class=n>unwrap_or</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>input_starts_with_alphabetic</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=n>take_while</span><span class=p>(</span><span class=o>|</span><span class=n>c</span><span class=o>|</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_alphanumeric</span><span class=p>(),</span><span class=w> </span><span class=n>s</span><span class=p>))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;expected identifier&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>())</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Now <code>extract_ident</code> compiles, but its tests don’t! We need to <code>Ok</code>-wrap them:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>extract_alphabetic_ident</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>extract_ident</span><span class=p>(</span><span class=s>&#34;abcdEFG stop&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>Ok</span><span class=p>((</span><span class=s>&#34; stop&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;abcdEFG&#34;</span><span class=p>)));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>extract_alphanumeric_ident</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=n>extract_ident</span><span class=p>(</span><span class=s>&#34;foobar1()&#34;</span><span class=p>),</span><span class=w> </span><span class=nb>Ok</span><span class=p>((</span><span class=s>&#34;()&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;foobar1&#34;</span><span class=p>)));</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>The last compilation error left is in <code>BindingDef::new</code>, where we need to add a <code>?</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>BindingDef</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>tag</span><span class=p>(</span><span class=s>&#34;let&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_ident</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w> </span><span class=c1>// here
</span><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>tag</span><span class=p>(</span><span class=s>&#34;=&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>val</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Expr</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>((</span><span class=w>
</span><span class=w>            </span><span class=n>s</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>name</span>: <span class=nc>name</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span><span class=w>                </span><span class=n>val</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=p>},</span><span class=w>
</span><span class=w>        </span><span class=p>))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Let’s see if it works:</p><pre><code class=language-- data-lang=->$ cargo t -q
running 22 tests
......................
test result: ok. 22 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>We’re almost done, now &ndash; all that’s left is fixing the handling of whitespace.</p><p>Here’s the definition of <code>utils::extract_whitespace</code>:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>extract_whitespace</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>take_while</span><span class=p>(</span><span class=o>|</span><span class=n>c</span><span class=o>|</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39; &#39;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>At first you might think that the fix for this is as simple as swapping <code>take_while</code> for <code>take_while1</code>. This will lead to other issues, though, as the <code>=</code> in <code>let a = 10</code> doesn’t <em>need</em> spaces around it, nor does the <code>+</code> in <code>3 + 4</code>. We need a separate extractor for when whitespace is <em>required,</em> rather than optional. Let’s write a test that represents the behaviour we’d like:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>do_not_extract_spaces1_when_input_does_not_start_with_them</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=n>extract_whitespace1</span><span class=p>(</span><span class=s>&#34;blah&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;expected a space&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()),</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>The implementation that makes this pass is as simple as this:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=k>fn</span> <span class=nf>extract_whitespace1</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=kt>str</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>take_while1</span><span class=p>(</span><span class=o>|</span><span class=n>c</span><span class=o>|</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39; &#39;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=s>&#34;expected a space&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>())</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>All that’s left is to use it in <code>BindingDef::new</code> (the only parser so far where spaces are definitely required):</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>BindingDef</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>Self</span><span class=p>),</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>tag</span><span class=p>(</span><span class=s>&#34;let&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace1</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w> </span><span class=c1>// New!
</span><span class=c1></span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_ident</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>tag</span><span class=p>(</span><span class=s>&#34;=&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>utils</span>::<span class=n>extract_whitespace</span><span class=p>(</span><span class=n>s</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>val</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Expr</span>::<span class=n>new</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>((</span><span class=w>
</span><span class=w>            </span><span class=n>s</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>                </span><span class=n>name</span>: <span class=nc>name</span><span class=p>.</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span><span class=w>                </span><span class=n>val</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=p>},</span><span class=w>
</span><span class=w>        </span><span class=p>))</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Notice how <code>utils::extract_whitespace1</code> can fail, while <code>utils::extract_whitespace</code> cannot.</p><p>To be sure we’ve fixed the issue, let’s add a test:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[cfg(test)]</span><span class=w>
</span><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>// snip
</span><span class=c1></span><span class=w>
</span><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>cannot_parse_binding_def_without_space_after_let</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=n>assert_eq</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>            </span><span class=n>BindingDef</span>::<span class=n>new</span><span class=p>(</span><span class=s>&#34;letaaa=1+2&#34;</span><span class=p>),</span><span class=w>
</span><span class=w>            </span><span class=nb>Err</span><span class=p>(</span><span class=s>&#34;expected a space&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>()),</span><span class=w>
</span><span class=w>        </span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>And …</p><pre><code class=language-- data-lang=->$ cargo t -q
running 24 tests
........................
test result: ok. 24 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>We’re done! See you all next time, when we’ll add support for <em>using</em> the bindings we can create with <code>let</code>.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><code>?</code> <a href=https://doc.rust-lang.org/stable/std/ops/trait.Try.html>can have its behaviour customised</a> for any type on nightly as of the time of writing. In fact, <code>?</code> works with <code>Option</code> on stable Rust today!&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>That <code>.unwrap()</code> might look suspicious, but it’s actually never going to trigger because the string that <code>utils::extract_digits</code> returns always consists entirely of digits, meaning that parsing of that string as an integer will never fail.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>The name for <code>take_while1</code> is meant as ‘<code>take_while</code>, with the extracted text being at least one byte long’. As with <code>tag</code> and <code>take_while</code>, the <a href=https://docs.rs/nom/5/nom/bytes/complete/fn.take_while1.html>name comes from Nom</a>.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></main><nav class=page-navigation><div class=prev><p class=hint>Previously</p><a href=https://arzg.github.io/lang/3/>Part Three: Defining Variables</a></div><div class=next><p class=hint>Next up</p><a href=https://arzg.github.io/lang/5/>Part Five: Binding Usages</a></div><div style=clear:both></div></nav></body></html>