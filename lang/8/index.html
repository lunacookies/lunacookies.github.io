<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Part Eight: Function Definitions · arzg’s website</title><link rel=stylesheet href=https://arzg.github.io/scss/main.5b8c013dd5e51a40b743f06124716408dad09d87641389dd50c9b9d63c648588.css integrity="sha256-W4wBPdXlGkC3Q/BhJHFkCNrQnYdkE4ndUMm51jxkhYg="><script src=https://unpkg.com/quicklink@2.0.0/dist/quicklink.umd.js></script>
<script src=https://unpkg.com/anchor-js@4.3.1/anchor.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.25.0/plugins/autoloader/prism-autoloader.min.js></script>
<script>window.onload=()=>{quicklink.listen()},document.addEventListener("DOMContentLoaded",function(a){anchors.add("main h1")})</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body><nav class=site-navigation><ul><li><a href=/>Home</a></li><li><a href=/blog/>Blog</a></li><li class=current><a href=/lang/>Make A Language</a></li></ul></nav><header class=header-area><h1 class=title>Part Eight: Function Definitions</h1><section class=page-info><ul><li>8 October 2020</li><li>5160 words</li><li>26 minute read</li></ul></section></header><main><p>First, we need to decide on a syntax. Let’s start with Rust’s syntax:</p><pre><code class=language-rust>fn frobnicate(foo: String, bar: String) -&gt; Vec&lt;Bar&gt; {
    ...
}
</code></pre><p>Eldiro doesn’t have types (yet), so we need to remove those:<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><pre><code>fn frobnicate(foo, bar) {
    ...
}
</code></pre><p>Parentheses and commas are annoying, so let’s get rid of those:</p><pre><code>fn frobnicate foo bar {
    ...
}
</code></pre><p>Often we have functions whose body is just a single statement. Here’s a contrived example:</p><pre><code>fn add x y {
    x + y
}
</code></pre><p>It can be convenient to not force function bodies to be blocks in these cases. Using <a href=https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members#methods>the syntax from C#</a>:</p><pre><code>fn add x y =&gt; x + y
</code></pre><p>Since blocks are expressions (which are statements), we can also do this:</p><pre><code>fn add x y =&gt; {
    x + y
}
</code></pre><p>To reduce the number of ways to do one thing, we’ll remove the ‘block-only’ syntax, instead forcing the use of the <code>=></code> everywhere.</p><h1 id=why-not-use-closures-for-everything>Why not use closures for everything?</h1><p>In the past I would have preferred for all function definitions to be binding definitions whose value is a closure. Here’s an example in Rust:</p><pre><code class=language-rust>// Function-specific syntax
fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}

// More general closure syntax
let add = |x: i32, y: i32| -&gt; i32 { x + y };
</code></pre><p><a href="https://www.reddit.com/r/rust/comments/inoipw/something_that_blew_my_mind_about_scoped_variables/g4dd0ul?utm_source=share&utm_medium=web2x&context=3">A comment from u/witty___name</a> clarified that this approach is problematic, though. (I’ll be paraphrasing their explanation here.)</p><p>Eldiro doesn’t have any way to catch undefined functions until runtime at the moment, which means that this approach works fine, even with recursion. However, if Eldiro gains a way to check for undefined functions <em>without running the program,</em> then using closures for function definitions exclusively would lead to problems. Consider this closure definition in Rust:</p><pre><code class=language-rust>let overflow_stack = || overflow_stack();
</code></pre><p>This doesn’t compile, since bindings aren’t in scope on their left-hand side. If they were, it would allow things like</p><pre><code class=language-rust>let x = x;
</code></pre><p>which is clearly nonsensical.</p><p>Because of this, I’ve chosen for function definitions to have a dedicated syntax in Eldiro.</p><h1 id=parsing>Parsing</h1><p>Let’s get started on the parser. Function definitions aren’t an expression &ndash; they’re a statement, so let’s go to <code>stmt.rs</code> and add a variant to that enum:</p><pre><code class=language-rust>use crate::binding_def::BindingDef;
use crate::env::Env;
use crate::expr::Expr;
use crate::func_def::FuncDef;
use crate::val::Val;

// snip

#[derive(Debug, PartialEq)]
pub(crate) enum Stmt {
    BindingDef(BindingDef),
    FuncDef(FuncDef),
    Expr(Expr),
}
</code></pre><p>To get our project compiling as quickly as possible, let’s add a case for <code>Stmt::FuncDef</code> to <code>Stmt::eval</code>:</p><pre><code class=language-rust>impl Stmt {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;mut Env) -&gt; Result&lt;Val, String&gt; {
        match self {
            Self::BindingDef(binding_def) =&gt; {
                binding_def.eval(env)?;
                Ok(Val::Unit)
            }
            Self::FuncDef(_) =&gt; todo!(),
            Self::Expr(expr) =&gt; expr.eval(env),
        }
    }
}
</code></pre><p>Let’s add a test, too:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::*;
    use crate::expr::{BindingUsage, Number, Op};

    // snip

    #[test]
    fn parse_func_def() {
        assert_eq!(
            Stmt::new(&quot;fn identity x =&gt; x&quot;),
            Ok((
                &quot;&quot;,
                Stmt::FuncDef(FuncDef {
                    name: &quot;identity&quot;.to_string(),
                    params: vec![&quot;x&quot;.to_string()],
                    body: Stmt::Expr(Expr::BindingUsage(BindingUsage {
                        name: &quot;x&quot;.to_string(),
                    })),
                }),
            )),
        );
    }

    // snip
}
</code></pre><p><code>BindingUsage</code> isn’t re-exported from <code>crate::expr</code>; let’s fix that. We’ll also re-export <code>Block</code> for consistency:</p><pre><code class=language-rust>// expr.rs

mod binding_usage;
mod block;

pub(crate) use binding_usage::BindingUsage;
pub(crate) use block::Block;

use crate::env::Env;
use crate::utils;
use crate::val::Val;
</code></pre><p>The field <code>name</code> on <code>BindingUsage</code> is <code>pub(super)</code>, when it should be <code>pub(crate)</code> so we can use it for our tests:</p><pre><code class=language-rust>// binding_usage.rs

#[derive(Debug, PartialEq)]
pub(crate) struct BindingUsage {
    pub(crate) name: String,
}
</code></pre><p>We now need to create <code>crate::func_def::FuncDef</code>. Let’s start by declaring and creating the module:</p><pre><code class=language-rust>// lib.rs

mod binding_def;
mod env;
mod expr;
mod func_def; // new!
mod stmt;
mod utils;
mod val;
</code></pre><p>Open <code>src/func_def.rs</code> and declare <code>FuncDef</code>:</p><pre><code class=language-rust>use crate::stmt::Stmt;

#[derive(Debug, PartialEq)]
pub(crate) struct FuncDef {
    pub(crate) name: String,
    pub(crate) params: Vec&lt;String&gt;,
    pub(crate) body: Stmt,
}
</code></pre><p>Let’s try compiling Eldiro:</p><pre><code class=language-->$ cargo c
error[E0072]: recursive type `func_def::FuncDef` has infinite size
 --&gt; crates/eldiro/src/func_def.rs:4:1
  |
4 | pub(crate) struct FuncDef {
  | ^^^^^^^^^^^^^^^^^^^^^^^^^ recursive type has infinite size
...
7 |     pub(crate) body: Stmt,
  |                      ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `func_def::FuncDef` representable
  |
7 |     pub(crate) body: Box&lt;Stmt&gt;,
  |                      ^^^^    ^

error[E0072]: recursive type `stmt::Stmt` has infinite size
  --&gt; crates/eldiro/src/stmt.rs:8:1
   |
8  | pub(crate) enum Stmt {
   | ^^^^^^^^^^^^^^^^^^^^ recursive type has infinite size
9  |     BindingDef(BindingDef),
10 |     FuncDef(FuncDef),
   |             ------- recursive without indirection
   |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `stmt::Stmt` representable
   |
10 |     FuncDef(Box&lt;FuncDef&gt;),
   |             ^^^^       ^

error[E0391]: cycle detected when computing drop-check constraints for `stmt::Stmt`
  --&gt; crates/eldiro/src/stmt.rs:8:1
   |
8  | pub(crate) enum Stmt {
   | ^^^^^^^^^^^^^^^^^^^^
   |
note: ...which requires computing drop-check constraints for `func_def::FuncDef`...
  --&gt; crates/eldiro/src/func_def.rs:4:1
   |
4  | pub(crate) struct FuncDef {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: ...which again requires computing drop-check constraints for `stmt::Stmt`, completing the cycle
note: cycle used when computing drop-check constraints for `Parse`
  --&gt; crates/eldiro/src/lib.rs:13:1
   |
13 | pub struct Parse(stmt::Stmt);
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: aborting due to 3 previous errors
</code></pre><p>Whoa! We have a bunch of errors because we’ve accidentally created a <em>recursive type</em> &ndash; a type that contains itself. Rust doesn’t like this because, when it’s calculating the size of <code>Stmt</code>, it falls into the following loop:</p><ol><li>To calculate <code>Stmt</code>’s size, I need to find the size of <code>Stmt</code>’s largest variant.</li><li>To calculate <code>Stmt::BindingDef</code>’s size, I need to find the size of all its fields.</li><li><em>Calculates the size of all of <code>BindingDef</code>’s fields.</em></li><li>To calculate <code>Stmt::FuncDef</code>’s size, I need to find the size of all its fields.</li><li>To calculate the size of the <code>body</code> field of <code>FuncDef</code>, I need to find the size of <code>Stmt</code>.</li><li>Go to 1.</li></ol><p>In other words &ndash; we have a recursive type because <code>Stmt</code> could contain a <code>FuncDef</code> depending on which variant it is, and <code>FuncDef</code> in turn contains a <code>Stmt</code> through the <code>body</code> field. The Rust compiler very kindly suggests how to remove the recursion; namely, add indirection somewhere. I’ll opt for <code>Box</code>ing the <code>body</code> of <code>FuncDef</code>:</p><pre><code class=language-rust>use crate::stmt::Stmt;

#[derive(Debug, PartialEq)]
pub(crate) struct FuncDef {
    pub(crate) name: String,
    pub(crate) params: Vec&lt;String&gt;,
    pub(crate) body: Box&lt;Stmt&gt;,
}
</code></pre><p>A <code>Box&lt;Stmt></code> is a pointer to some memory on the heap that contains a <code>Stmt</code>. Rust’s process for calculating the size of <code>Stmt</code> now goes like this:</p><ol><li>To calculate <code>Stmt</code>’s size, I need to find the size of <code>Stmt</code>’s largest variant.</li><li>To calculate <code>Stmt::BindingDef</code>’s size, I need to find the size of all its fields.</li><li><em>Calculates the size of all of <code>BindingDef</code>’s fields.</em></li><li>To calculate <code>Stmt::FuncDef</code>’s size, I need to find the size of all its fields.</li><li>To calculate the size of the <code>name</code> field of <code>FuncDef</code>, I need to find the size of <code>String</code> (it’s 24 bytes).</li><li>To calculate the size of the <code>params</code> field of <code>FuncDef</code>, I need to find the size of <code>Vec</code> (it’s 24 bytes).</li><li>To calculate the size of the <code>body</code> field of <code>FuncDef</code>, I need to find the size of <code>Box</code> (depends on your architecture, e.g. on a 64-bit system it’s 8 bytes).</li><li>To calculate <code>Stmt::Expr</code>’s size, I need to find the size of <code>Expr</code>.</li><li>&mldr;</li></ol><p>No more recursion, so Rust doesn’t get stuck when trying to calculate <code>Stmt</code>’s size.</p><p>We now need to update that test we wrote earlier:</p><pre><code class=language-rust>// stmt.rs

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_func_def() {
        assert_eq!(
            Stmt::new(&quot;fn identity x =&gt; x&quot;),
            Ok((
                &quot;&quot;,
                Stmt::FuncDef(FuncDef {
                    name: &quot;identity&quot;.to_string(),
                    params: vec![&quot;x&quot;.to_string()],
                    body: Box::new(Stmt::Expr(Expr::BindingUsage(BindingUsage {
                        name: &quot;x&quot;.to_string(),
                    }))),
                }),
            )),
        );
    }

    // snip
}
</code></pre><p>Let’s write another test for parsing a function definition, but this time in <code>func_def.rs</code>:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::*;
    use crate::expr::{Block, Expr};

    #[test]
    fn parse_func_def_with_no_params_and_empty_body() {
        assert_eq!(
            FuncDef::new(&quot;fn nothing =&gt; {}&quot;),
            Ok((
                &quot;&quot;,
                FuncDef {
                    name: &quot;nothing&quot;.to_string(),
                    params: Vec::new(),
                    body: Box::new(Stmt::Expr(Expr::Block(Block { stmts: Vec::new() }))),
                },
            )),
        );
    }
}
</code></pre><p>We need to make the <code>stmts</code> field of <code>Block</code> <code>pub(crate)</code>:</p><pre><code class=language-rust>// block.rs

#[derive(Debug, PartialEq)]
pub(crate) struct Block {
    pub(crate) stmts: Vec&lt;Stmt&gt;,
}
</code></pre><p>Let’s implement <code>FuncDef::new</code>:</p><pre><code class=language-rust>// func_def.rs

impl FuncDef {
    pub(crate) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;fn&quot;, s)?;
        let (s, _) = utils::extract_whitespace1(s)?;

        let (s, name) = utils::extract_ident(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let s = utils::tag(&quot;=&gt;&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, body) = Stmt::new(s)?;

        Ok((
            s,
            Self {
                name: name.to_string(),
                params: Vec::new(),
                body: Box::new(body),
            },
        ))
    }
}
</code></pre><p>We should run the tests to see how we went:</p><pre><code class=language-->$ cargo t -q
running 48 tests
..........................................F.....
failures:

---- stmt::tests::parse_func_def stdout ----
thread 'stmt::tests::parse_func_def' panicked at 'assertion failed: `(left == right)`
  left: `Ok((&quot; identity x =&gt; x&quot;, Expr(BindingUsage(BindingUsage { name: &quot;fn&quot; }))))`,
 right: `Ok((&quot;&quot;, FuncDef(FuncDef { name: &quot;identity&quot;, params: [&quot;x&quot;], body: Expr(BindingUsage(BindingUsage { name: &quot;x&quot; })) })))`', crates/eldiro/src/stmt.rs:54:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    stmt::tests::parse_func_def

test result: FAILED. 47 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Looks like the <code>parse_func_def_with_no_params_and_empty_body</code> test passed, but the test we wrote in <code>stmt.rs</code> is failing. To make the test pass, we need to handle parameters:</p><pre><code class=language-rust>impl FuncDef {
    pub(crate) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;fn&quot;, s)?;
        let (s, _) = utils::extract_whitespace1(s)?;

        let (s, name) = utils::extract_ident(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let mut s = s;
        let mut params = Vec::new();

        while let Ok((new_s, param)) = utils::extract_ident(s) {
            s = new_s;
            params.push(param.to_string());

            let (new_s, _) = utils::extract_whitespace(s);
            s = new_s;
        }

        let s = utils::tag(&quot;=&gt;&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, body) = Stmt::new(s)?;

        Ok((
            s,
            Self {
                name: name.to_string(),
                params,
                body: Box::new(body),
            },
        ))
    }
}
</code></pre><p>We also use this approach of ‘keep extracting something (in this case identifiers) and stuff them into a <code>Vec</code> until you can’t continue’ in <code>Block::new</code>. Let’s see if it works:</p><pre><code class=language-->$ cargo t -q
running 48 tests
..........................................F.....
failures:

---- stmt::tests::parse_func_def stdout ----
thread 'stmt::tests::parse_func_def' panicked at 'assertion failed: `(left == right)`
  left: `Ok((&quot; identity x =&gt; x&quot;, Expr(BindingUsage(BindingUsage { name: &quot;fn&quot; }))))`,
 right: `Ok((&quot;&quot;, FuncDef(FuncDef { name: &quot;identity&quot;, params: [&quot;x&quot;], body: Expr(BindingUsage(BindingUsage { name: &quot;x&quot; })) })))`', crates/eldiro/src/stmt.rs:55:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    stmt::tests::parse_func_def

test result: FAILED. 47 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Hmm, I thought we’d fixed it. <em>thinking emoji …</em></p><p>Ah, I figured it out! The test that’s failing is using <code>Stmt::new</code>, which we haven’t updated to try parsing a function definition. Here’s the current implementation:</p><pre><code class=language-rust>// stmt.rs

impl Stmt {
    pub(crate) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        BindingDef::new(s)
            .map(|(s, binding_def)| (s, Self::BindingDef(binding_def)))
            .or_else(|_| Expr::new(s).map(|(s, expr)| (s, Self::Expr(expr))))
    }

    // snip
}
</code></pre><p>We need to add just one line to make the test pass:</p><pre><code class=language-rust>impl Stmt {
    pub(crate) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        BindingDef::new(s)
            .map(|(s, binding_def)| (s, Self::BindingDef(binding_def)))
            .or_else(|_| FuncDef::new(s).map(|(s, func_def)| (s, Self::FuncDef(func_def))))
            .or_else(|_| Expr::new(s).map(|(s, expr)| (s, Self::Expr(expr))))
    }

    // snip
}
</code></pre><p>Remember that technique we used in both <code>FuncDef::new</code> and <code>Block::new</code> to parse multiple things? Let’s extract that logic into a helper function in <code>crate::utils</code> to remove the duplication and make the code easier to read:</p><pre><code class=language-rust>pub(crate) fn sequence&lt;T&gt;(
    parser: impl Fn(&amp;str) -&gt; Result&lt;(&amp;str, T), String&gt;,
    mut s: &amp;str,
) -&gt; Result&lt;(&amp;str, Vec&lt;T&gt;), String&gt; {
    let mut items = Vec::new();

    while let Ok((new_s, item)) = parser(s) {
        s = new_s;
        items.push(item);

        let (new_s, _) = extract_whitespace(s);
        s = new_s;
    }

    Ok((s, items))
}
</code></pre><p>The function is generic over the type of the thing being parsed. It <em>isn’t</em> generic over the type of error the parser returns, though, because our project only has one type of parser error: <code>String</code>. Take a look at <a href=https://matklad.github.io/2020/08/15/concrete-abstraction.html>this article</a> to see more of the rationale behind this decision.</p><p>We can make use of our shiny new <code>sequence</code> function in <code>Block::new</code>:</p><pre><code class=language-rust>// block.rs

impl Block {
    pub(super) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;{&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, stmts) = utils::sequence(Stmt::new, s)?;

        let (s, _) = utils::extract_whitespace(s);
        let s = utils::tag(&quot;}&quot;, s)?;

        Ok((s, Block { stmts }))
    }

    // snip
}
</code></pre><p>and <code>FuncDef::new</code>:</p><pre><code class=language-rust>// func_def.rs

impl FuncDef {
    pub(crate) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;fn&quot;, s)?;
        let (s, _) = utils::extract_whitespace1(s)?;

        let (s, name) = utils::extract_ident(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, params) = utils::sequence(utils::extract_ident, s)?;

        let s = utils::tag(&quot;=&gt;&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, body) = Stmt::new(s)?;

        Ok((
            s,
            Self {
                name: name.to_string(),
                params,
                body: Box::new(body),
            },
        ))
    }
}
</code></pre><p>Wait! That doesn’t compile, because <code>params</code> is now of type <code>Vec&lt;&str></code> instead of <code>Vec&lt;String></code>. <code>params</code> is a <code>Vec&lt;&str></code> because the type that <code>utils::extract_ident</code> returns (ignoring the usual leftover input <code>&str</code>) is a <code>&str</code>, which is picked up and propagated by the <code>&lt;T></code> in <code>utils::sequence</code>. We can fix this by passing <code>utils::sequence</code> a wrapper closure around <code>utils::extract_ident</code> that turns the identifier it extracts into a <code>String</code>:</p><pre><code class=language-rust>impl FuncDef {
    pub(crate) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let s = utils::tag(&quot;fn&quot;, s)?;
        let (s, _) = utils::extract_whitespace1(s)?;

        let (s, name) = utils::extract_ident(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, params) = utils::sequence(
            |s| utils::extract_ident(s).map(|(s, ident)| (s, ident.to_string())),
            s,
        )?;

        let s = utils::tag(&quot;=&gt;&quot;, s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, body) = Stmt::new(s)?;

        Ok((
            s,
            Self {
                name: name.to_string(),
                params,
                body: Box::new(body),
            },
        ))
    }
}
</code></pre><p>And now this works perfectly:</p><pre><code class=language-->$ cargo t -q
running 48 tests
................................................
test result: ok. 48 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Let’s write another test:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_func_def_with_one_param_and_empty_body() {
        assert_eq!(
            FuncDef::new(&quot;fn greet name =&gt; {}&quot;),
            Ok((
                &quot;&quot;,
                FuncDef {
                    name: &quot;greet&quot;.to_string(),
                    params: vec![&quot;name&quot;.to_string()],
                    body: Box::new(Stmt::Expr(Expr::Block(Block { stmts: Vec::new() }))),
                },
            )),
        );
    }
}
</code></pre><p>It passes:</p><pre><code class=language-->$ cargo t -q
running 49 tests
.................................................
test result: ok. 49 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Let’s write a test with multiple parameters and a non-empty body:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    use super::*;
    use crate::expr::{BindingUsage, Block, Expr, Op};

    // snip

    #[test]
    fn parse_func_def_with_multiple_params() {
        assert_eq!(
            FuncDef::new(&quot;fn add x y =&gt; x + y&quot;),
            Ok((
                &quot;&quot;,
                FuncDef {
                    name: &quot;add&quot;.to_string(),
                    params: vec![&quot;x&quot;.to_string(), &quot;y&quot;.to_string()],
                    body: Box::new(Stmt::Expr(Expr::Operation {
                        lhs: Expr::BindingUsage(BindingUsage {
                            name: &quot;x&quot;.to_string()
                        }),
                        rhs: Expr::BindingUsage(BindingUsage {
                            name: &quot;y&quot;.to_string()
                        }),
                        op: Op::Add
                    }))
                }
            ))
        );
    }
}
</code></pre><p>Aaaand it doesn’t compile. It seems that the fields <code>lhs</code> and <code>rhs</code> of <code>Expr::Operation</code> can only be <code>crate::expr::Number</code>s. Although this <em>does</em> adhere to our initial design decision to disallow nested expressions, it prevents us from doing things as basic as defining an <code>add</code> function! We need to fix this.</p><h1 id=allowing-operations-on-expressions>Allowing operations on expressions</h1><p>It might be helpful to run <code>git stash</code> &ndash; if you’re using Git &ndash; to temporarily hide the modifications we’ve made to existing files in our quest to add support for function definitions. Note that this will leave <code>func_def.rs</code> intact.</p><p>Let’s remind ourselves of <code>Expr</code>’s definition:</p><pre><code class=language-rust>#[derive(Debug, PartialEq)]
pub(crate) enum Expr {
    Number(Number),
    Operation { lhs: Number, rhs: Number, op: Op },
    BindingUsage(BindingUsage),
    Block(Block),
}
</code></pre><p>Your first instinct might be to change that to</p><pre><code class=language-rust>#[derive(Debug, PartialEq)]
pub(crate) enum Expr {
    Number(Number),
    Operation { lhs: Self, rhs: Self, op: Op },
    BindingUsage(BindingUsage),
    Block(Block),
}
</code></pre><p>Remember, though, that that would lead to the recursive type error we got earlier. We need to add <code>Box</code>es:</p><pre><code class=language-rust>#[derive(Debug, PartialEq)]
pub(crate) enum Expr {
    Number(Number),
    Operation {
        lhs: Box&lt;Self&gt;,
        rhs: Box&lt;Self&gt;,
        op: Op,
    },
    BindingUsage(BindingUsage),
    Block(Block),
}
</code></pre><p>Let’s start by fixing all the tests:</p><pre><code class=language-rust>// binding_def.rs

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_binding_def() {
        assert_eq!(
            BindingDef::new(&quot;let a = 10 / 2&quot;),
            Ok((
                &quot;&quot;,
                BindingDef {
                    name: &quot;a&quot;.to_string(),
                    val: Expr::Operation {
                        lhs: Box::new(Expr::Number(Number(10))),
                        rhs: Box::new(Expr::Number(Number(2))),
                        op: Op::Div,
                    },
                },
            )),
        );
    }

    // snip
}
</code></pre><pre><code class=language-rust>// block.rs

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_block_with_multiple_exprs() {
        assert_eq!(
            Block {
                stmts: vec![
                    Stmt::Expr(Expr::Number(Number(100))),
                    Stmt::Expr(Expr::Number(Number(30))),
                    Stmt::Expr(Expr::Operation {
                        lhs: Box::new(Expr::Number(Number(10))),
                        rhs: Box::new(Expr::Number(Number(7))),
                        op: Op::Sub,
                    }),
                ],
            }
            .eval(&amp;Env::default()),
            Ok(Val::Number(3)),
        );
    }

    // snip
}
</code></pre><pre><code class=language-rust>// expr.rs

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_one_plus_two() {
        assert_eq!(
            Expr::new(&quot;1+2&quot;),
            Ok((
                &quot;&quot;,
                Expr::Operation {
                    lhs: Box::new(Expr::Number(Number(1))),
                    rhs: Box::new(Expr::Number(Number(2))),
                    op: Op::Add,
                },
            )),
        );
    }

    #[test]
    fn parse_expr_with_whitespace() {
        assert_eq!(
            Expr::new(&quot;2 * 2&quot;),
            Ok((
                &quot;&quot;,
                Expr::Operation {
                    lhs: Box::new(Expr::Number(Number(2))),
                    rhs: Box::new(Expr::Number(Number(2))),
                    op: Op::Mul,
                },
            )),
        );
    }

    // snip

    #[test]
    fn eval_add() {
        assert_eq!(
            Expr::Operation {
                lhs: Box::new(Expr::Number(Number(10))),
                rhs: Box::new(Expr::Number(Number(10))),
                op: Op::Add,
            }
            .eval(&amp;Env::default()),
            Ok(Val::Number(20)),
        );
    }

    #[test]
    fn eval_sub() {
        assert_eq!(
            Expr::Operation {
                lhs: Box::new(Expr::Number(Number(1))),
                rhs: Box::new(Expr::Number(Number(5))),
                op: Op::Sub,
            }
            .eval(&amp;Env::default()),
            Ok(Val::Number(-4)),
        );
    }

    #[test]
    fn eval_mul() {
        assert_eq!(
            Expr::Operation {
                lhs: Box::new(Expr::Number(Number(5))),
                rhs: Box::new(Expr::Number(Number(6))),
                op: Op::Mul,
            }
            .eval(&amp;Env::default()),
            Ok(Val::Number(30)),
        );
    }

    #[test]
    fn eval_div() {
        assert_eq!(
            Expr::Operation {
                lhs: Box::new(Expr::Number(Number(200))),
                rhs: Box::new(Expr::Number(Number(20))),
                op: Op::Div,
            }
            .eval(&amp;Env::default()),
            Ok(Val::Number(10)),
        );
    }

    // snip
}
</code></pre><pre><code class=language-rust>// func_def.rs

#[cfg(test)]
mod tests {
    // snip

    #[test]
    #[test]
    fn parse_func_def_with_multiple_params() {
        assert_eq!(
            FuncDef::new(&quot;fn add x y =&gt; x + y&quot;),
            Ok((
                &quot;&quot;,
                FuncDef {
                    name: &quot;add&quot;.to_string(),
                    params: vec![&quot;x&quot;.to_string(), &quot;y&quot;.to_string()],
                    body: Box::new(Stmt::Expr(Expr::Operation {
                        lhs: Box::new(Expr::BindingUsage(BindingUsage {
                            name: &quot;x&quot;.to_string(),
                        })),
                        rhs: Box::new(Expr::BindingUsage(BindingUsage {
                            name: &quot;y&quot;.to_string(),
                        })),
                        op: Op::Add,
                    })),
                },
            )),
        );
    }
}
</code></pre><pre><code class=language-rust>// stmt.rs

#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn parse_expr() {
        assert_eq!(
            Stmt::new(&quot;1+1&quot;),
            Ok((
                &quot;&quot;,
                Stmt::Expr(Expr::Operation {
                    lhs: Box::new(Expr::Number(Number(1))),
                    rhs: Box::new(Expr::Number(Number(1))),
                    op: Op::Add,
                }),
            )),
        );
    }

    // snip
}
</code></pre><p>Now that we’ve updated all those tests, it’s time to tackle the four outstanding compilation errors. Two of these are from parsing an <code>Expr::Operation</code>, and the other two are from evaluating it.</p><p>Let’s fix the parsing first. Here’s how an <code>Expr::Operation</code> is currently parsed:</p><pre><code class=language-rust>// expr.rs

impl Expr {
    // snip

    fn new_operation(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, lhs) = Number::new(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, op) = Op::new(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, rhs) = Number::new(s)?;

        Ok((s, Self::Operation { lhs, rhs, op }))
    }

    // snip
}
</code></pre><p>As you can see, <code>lhs</code> and <code>rhs</code> are of type <code>Number</code>, not of type <code>Box&lt;Expr></code>. We can add the <code>Box</code> part:</p><pre><code class=language-rust>impl Expr {
    // snip

    fn new_operation(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, lhs) = Number::new(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, op) = Op::new(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, rhs) = Number::new(s)?;

        Ok((
            s,
            Self::Operation {
                lhs: Box::new(lhs),
                rhs: Box::new(rhs),
                op,
            },
        ))
    }

    // snip
}
</code></pre><p>Let’s try making <code>lhs</code> and <code>rhs</code> <code>Expr</code>s by calling <code>Expr::new</code>:</p><pre><code class=language-rust>impl Expr {
    // snip

    fn new_operation(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, lhs) = Self::new(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, op) = Op::new(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, rhs) = Self::new(s)?;

        Ok((
            s,
            Self::Operation {
                lhs: Box::new(lhs),
                rhs: Box::new(rhs),
                op,
            },
        ))
    }

    // snip
}
</code></pre><p>This looks reasonable enough. Let’s run the tests:</p><pre><code class=language-->$ cargo t -q
error[E0308]: mismatched types
  --&gt; crates/eldiro/src/expr.rs:89:21
   |
89 |                 let Number(lhs) = lhs;
   |                     ^^^^^^^^^^^   --- this expression has type `&amp;std::boxed::Box&lt;expr::Expr&gt;`
   |                     |
   |                     expected struct `std::boxed::Box`, found struct `expr::Number`
   |
   = note: expected struct `std::boxed::Box&lt;expr::Expr&gt;`
              found struct `expr::Number`

error[E0308]: mismatched types
  --&gt; crates/eldiro/src/expr.rs:90:21
   |
90 |                 let Number(rhs) = rhs;
   |                     ^^^^^^^^^^^   --- this expression has type `&amp;std::boxed::Box&lt;expr::Expr&gt;`
   |                     |
   |                     expected struct `std::boxed::Box`, found struct `expr::Number`
   |
   = note: expected struct `std::boxed::Box&lt;expr::Expr&gt;`
              found struct `expr::Number`

error: aborting due to 2 previous errors
</code></pre><p>Oh, yeah, we still have that compilation error. Let’s add a <code>todo!()</code> and comment out the rest so we can get on with running our tests:</p><pre><code class=language-rust>impl Expr {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        match self {
            Self::Number(Number(n)) =&gt; Ok(Val::Number(*n)),
            Self::Operation { lhs, rhs, op } =&gt; {
                todo!();

                // let Number(lhs) = lhs;
                // let Number(rhs) = rhs;

                // let result = match op {
                //     Op::Add =&gt; lhs + rhs,
                //     Op::Sub =&gt; lhs - rhs,
                //     Op::Mul =&gt; lhs * rhs,
                //     Op::Div =&gt; lhs / rhs,
                // };

                // Ok(Val::Number(result))
            }
            Self::BindingUsage(binding_usage) =&gt; binding_usage.eval(env),
            Self::Block(block) =&gt; block.eval(env),
        }
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
running 46 tests
.........F.F.FF.F.
thread 'binding_def::tests::parse_binding_def' has overflowed its stack
fatal runtime error: stack overflow
</code></pre><p>Oh, no. Oh, no no no. What’s happened here is that <code>Expr::new_operation</code> has called <code>Expr::new</code>, which calls <code>Expr::new_operation</code>, and so forth. The solution to this is to create an intermediary function that tries parsing all the possibilities <em>apart from</em> <code>Expr::Operation</code>. We use this function to parse <code>lhs</code> and <code>rhs</code>, and use it and <code>Expr::new_operation</code> in <code>Expr::new</code>. It’s difficult to explain with words; take look at the code:</p><pre><code class=language-rust>impl Expr {
    pub(crate) fn new(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        Self::new_operation(s).or_else(|_| Self::new_non_operation(s))
    }

    fn new_non_operation(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        Self::new_number(s)
            .or_else(|_| {
                BindingUsage::new(s)
                    .map(|(s, binding_usage)| (s, Self::BindingUsage(binding_usage)))
            })
            .or_else(|_| Block::new(s).map(|(s, block)| (s, Self::Block(block))))
    }

    // snip

    fn new_operation(s: &amp;str) -&gt; Result&lt;(&amp;str, Self), String&gt; {
        let (s, lhs) = Self::new_non_operation(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, op) = Op::new(s)?;
        let (s, _) = utils::extract_whitespace(s);

        let (s, rhs) = Self::new_non_operation(s)?;

        Ok((
            s,
            Self::Operation {
                lhs: Box::new(lhs),
                rhs: Box::new(rhs),
                op,
            },
        ))
    }

    // snip
}
</code></pre><pre><code class=language-->$ cargo t -q
running 46 tests
.............F.F.F.F..F.......................
failures:

---- expr::block::tests::eval_block_with_multiple_exprs stdout ----
thread 'expr::block::tests::eval_block_with_multiple_exprs' panicked at 'not yet implemented', crates/eldiro/src/expr.rs:92:17
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

---- expr::tests::eval_add stdout ----
thread 'expr::tests::eval_add' panicked at 'not yet implemented', crates/eldiro/src/expr.rs:92:17

---- expr::tests::eval_div stdout ----
thread 'expr::tests::eval_div' panicked at 'not yet implemented', crates/eldiro/src/expr.rs:92:17

---- expr::tests::eval_mul stdout ----
thread 'expr::tests::eval_mul' panicked at 'not yet implemented', crates/eldiro/src/expr.rs:92:17

---- expr::tests::eval_sub stdout ----
thread 'expr::tests::eval_sub' panicked at 'not yet implemented', crates/eldiro/src/expr.rs:92:17


failures:
    expr::block::tests::eval_block_with_multiple_exprs
    expr::tests::eval_add
    expr::tests::eval_div
    expr::tests::eval_mul
    expr::tests::eval_sub

test result: FAILED. 41 passed; 5 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Ah, those failures are from the <code>todo!()</code> in <code>Expr::eval</code>. Regardless, all the parsers are passing, which means that we’ve managed to fix both of our issues at once: we no longer have a stack overflow, and we have also prevented nested operations (since <code>lhs</code> and <code>rhs</code> call <code>Expr::new_non_operation</code>, there’s no chance that they could be <code>Expr::Operation</code>s themselves).</p><p>Here’s the current state of <code>Expr::eval</code>:</p><pre><code class=language-rust>impl Expr {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        match self {
            Self::Number(Number(n)) =&gt; Ok(Val::Number(*n)),
            Self::Operation { lhs, rhs, op } =&gt; {
                todo!();

                // let Number(lhs) = lhs;
                // let Number(rhs) = rhs;

                // let result = match op {
                //     Op::Add =&gt; lhs + rhs,
                //     Op::Sub =&gt; lhs - rhs,
                //     Op::Mul =&gt; lhs * rhs,
                //     Op::Div =&gt; lhs / rhs,
                // };

                // Ok(Val::Number(result))
            }
            Self::BindingUsage(binding_usage) =&gt; binding_usage.eval(env),
            Self::Block(block) =&gt; block.eval(env),
        }
    }
}
</code></pre><p>To evaluate an <code>Expr::Operation</code>, we must first evaluate the <code>lhs</code> and the <code>rhs</code>:</p><pre><code class=language-rust>impl Expr {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        match self {
            Self::Number(Number(n)) =&gt; Ok(Val::Number(*n)),
            Self::Operation { lhs, rhs, op } =&gt; {
                let lhs = lhs.eval(env)?;
                let rhs = rhs.eval(env)?;

                let result = match op {
                    Op::Add =&gt; lhs + rhs,
                    Op::Sub =&gt; lhs - rhs,
                    Op::Mul =&gt; lhs * rhs,
                    Op::Div =&gt; lhs / rhs,
                };

                Ok(Val::Number(result))
            }
            Self::BindingUsage(binding_usage) =&gt; binding_usage.eval(env),
            Self::Block(block) =&gt; block.eval(env),
        }
    }
}
</code></pre><p>We’ve got errors now because you can’t add, subtract, multiply or divide <code>Val</code>s. What we want is for <code>lhs</code> and <code>rhs</code> to be integers. Before, when we knew that <code>lhs</code> and <code>rhs</code> were <code>Numbers</code>, we could simply use pattern matching to extract the contained integer. Now, though, they could be any type that <code>Val</code> can contain. Although at the moment this means that <code>lhs</code> and <code>rhs</code> could both either be <code>Number</code>s or <code>Unit</code>s, we’ll add strings and other data types in the future. To solve this issue, we need to check that <code>lhs</code> and <code>rhs</code> are indeed <code>Val::Number</code>s, and if they aren’t return an error.</p><pre><code class=language-rust>impl Expr {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        match self {
            Self::Number(Number(n)) =&gt; Ok(Val::Number(*n)),
            Self::Operation { lhs, rhs, op } =&gt; {
                let lhs = lhs.eval(env)?;
                let rhs = rhs.eval(env)?;

                let (lhs, rhs) = match (lhs,rhs) {
                    (Val::Number(lhs), Val::Number(rhs)) =&gt; (lhs, rhs),
                    _ =&gt; return Err(&quot;cannot evaluate operation whose left-hand side and right-hand side are not both numbers&quot;.to_string()),
                };

                let result = match op {
                    Op::Add =&gt; lhs + rhs,
                    Op::Sub =&gt; lhs - rhs,
                    Op::Mul =&gt; lhs * rhs,
                    Op::Div =&gt; lhs / rhs,
                };

                Ok(Val::Number(result))
            }
            Self::BindingUsage(binding_usage) =&gt; binding_usage.eval(env),
            Self::Block(block) =&gt; block.eval(env),
        }
    }
}
</code></pre><p>Let’s write a test to verify that the error message kicks in at the right time:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_non_number_operation() {
        assert_eq!(
            Expr::Operation {
                lhs: Box::new(Expr::Number(Number(10))),
                rhs: Box::new(Expr::Block(Block { stmts: Vec::new() })),
                op: Op::Add,
            }
            .eval(&amp;Env::default()),
            Err(&quot;cannot evaluate operation whose left-hand side and right-hand side are not both numbers&quot;.to_string()),
        );
    }

    // snip
}
</code></pre><pre><code class=language-->$ cargo t -q
running 47 tests
...............................................
test result: ok. 47 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Run <code>git stash pop</code> to get back the changes we made for function definitions. Let’s run the tests again to see if the new feature of <code>Expr::Operation</code> is being used successfully:</p><pre><code class=language-->$ cargo t -q
running 51 tests
...................................................
test result: ok. 51 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Beautiful! With that diversion complete, we can get back to testing the parsing of function definitions.</p><h1 id=back-to-parsing>Back to parsing</h1><p>So, what tests do we still need for the parsing? Well, we have one with no parameters and an empty body. We also have one with one parameter and an empty body, as well as one with multiple parameters and a non-empty body. Although we haven’t tested every possible combination, we’ve tested enough scenarios for me to be confident that the parser is working correctly.</p><h1 id=evaluation>Evaluation</h1><p>Here’s the definition of <code>Env</code>:</p><pre><code class=language-rust>#[derive(Debug, PartialEq, Default)]
pub struct Env&lt;'parent&gt; {
    bindings: HashMap&lt;String, Val&gt;,
    parent: Option&lt;&amp;'parent Self&gt;,
}
</code></pre><p>One way to store function definitions in <code>Env</code> is to add another field, <code>funcs</code>, and have its type be</p><pre><code class=language-rust>HashMap&lt;
    String,
    /* everything inside of FuncDef apart from name */,
&gt;
</code></pre><p>Alternatively, you could have only one field for both bindings and functions. The type of this field is <code>HashMap&lt;String, V></code>, where V is an enum that holds either a binding’s value, or information about a function. This way, you can’t ever have both a function and a binding with the same name &ndash; whichever one is declared last takes priority. This method also prevents duplication of the ‘recursively search parents’ logic we wrote originally for bindings.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><p>A nice place to start is removing the <code>bindings</code> field and replacing it with a field called … well, it can contain bindings and functions … what do they both have in common? … names?</p><pre><code class=language-rust>#[derive(Debug, PartialEq, Default)]
pub struct Env&lt;'parent&gt; {
    named: HashMap&lt;String, NamedInfo&gt;,
    parent: Option&lt;&amp;'parent Self&gt;,
}
</code></pre><p>Let’s declare <code>NamedInfo</code>:</p><pre><code class=language-rust>// still in env.rs

#[derive(Debug, PartialEq)]
enum NamedInfo {
    Binding(Val),
    Func { params: Vec&lt;String&gt;, body: Stmt },
}
</code></pre><p>We need to update all of <code>Env</code>’s methods &ndash; at the same time, we can also add methods for functions:</p><pre><code class=language-rust>impl&lt;'parent&gt; Env&lt;'parent&gt; {
    pub(crate) fn create_child(&amp;'parent self) -&gt; Self {
        Self {
            named: HashMap::new(),
            parent: Some(self),
        }
    }

    pub(crate) fn store_binding(&amp;mut self, name: String, val: Val) {
        self.named.insert(name, NamedInfo::Binding(val));
    }

    pub(crate) fn store_func(&amp;mut self, name: String, params: Vec&lt;String&gt;, body: Stmt) {
        self.named.insert(name, NamedInfo::Func { params, body });
    }

    pub(crate) fn get_binding(&amp;self, name: &amp;str) -&gt; Result&lt;Val, String&gt; {
        self.get_named_info(name)
            .and_then(|named_info| match named_info {
                NamedInfo::Binding(val) =&gt; Some(val),
                _ =&gt; None,
            })
            .ok_or_else(|| format!(&quot;binding with name ‘{}’ does not exist&quot;, name))
    }

    pub(crate) fn get_func(&amp;self, name: &amp;str) -&gt; Result&lt;(Vec&lt;String&gt;, Stmt), String&gt; {
        self.get_named_info(name)
            .and_then(|named_info| match named_info {
                NamedInfo::Func { params, body } =&gt; Some((params, body)),
                _ =&gt; None,
            })
            .ok_or_else(|| format!(&quot;function with name ‘{}’ does not exist&quot;, name))
    }

    fn get_named_info(&amp;self, name: &amp;str) -&gt; Option&lt;NamedInfo&gt; {
        self.named
            .get(name)
            .cloned()
            .or_else(|| self.parent.and_then(|parent| parent.get_named_info(name)))
    }
}
</code></pre><p>That code is a touch repetitive. Let‘s add some methods to <code>NamedInfo</code> to make converting it into its variants easier:</p><pre><code class=language-rust>impl NamedInfo {
    fn into_binding(self) -&gt; Option&lt;Val&gt; {
        if let Self::Binding(val) = self {
            Some(val)
        } else {
            None
        }
    }

    fn into_func(self) -&gt; Option&lt;(Vec&lt;String&gt;, Stmt)&gt; {
        if let Self::Func { params, body } = self {
            Some((params, body))
        } else {
            None
        }
    }
}
</code></pre><p>Let’s make use of that in <code>Env::get_binding</code> and <code>Env::get_func</code>:</p><pre><code class=language-rust>impl&lt;'parent&gt; Env&lt;'parent&gt; {
    // snip

    pub(crate) fn get_binding(&amp;self, name: &amp;str) -&gt; Result&lt;Val, String&gt; {
        self.get_named_info(name)
            .and_then(NamedInfo::into_binding)
            .ok_or_else(|| format!(&quot;binding with name ‘{}’ does not exist&quot;, name))
    }

    pub(crate) fn get_func(&amp;self, name: &amp;str) -&gt; Result&lt;(Vec&lt;String&gt;, Stmt), String&gt; {
        self.get_named_info(name)
            .and_then(NamedInfo::into_func)
            .ok_or_else(|| format!(&quot;function with name ‘{}’ does not exist&quot;, name))
    }

    // snip
}
</code></pre><p>The first of the two compilation errors we have left is from us not being allowed to call <code>.cloned()</code> in <code>Env::get_named_info</code>, since <code>NamedInfo</code> doesn’t implement <code>Clone</code>. Let’s fix that:</p><pre><code class=language-rust>#[derive(Debug, Clone, PartialEq)]
enum NamedInfo {
    Binding(Val),
    Func { params: Vec&lt;String&gt;, body: Stmt },
}
</code></pre><p>This doesn’t compile, since <code>Stmt</code> doesn’t implement <code>Clone</code>. I’ll leave you to go through all the ‘blah doesn’t implement <code>Clone</code>’ errors, since adding <code>#[derive(Clone)]</code> to almost all the types we’ve written so far is too laborious to write out here. As I did in the last article, <a href=https://github.com/arzg/eldiro/commit/a2a406db5bfe0e369c4da7dc62b1ed463731fb36>here’s a link to the diff of the commit that adds this</a> on GitHub in case you get lost.</p><p>We only have one error left; ‘no method named <code>get_binding_value</code>’. Let’s fix it:</p><pre><code class=language-rust>// binding_usage.rs

impl BindingUsage {
    // snip

    pub(super) fn eval(&amp;self, env: &amp;Env) -&gt; Result&lt;Val, String&gt; {
        env.get_binding(&amp;self.name)
    }
}
</code></pre><p>Now that all those shenanigans with <code>Env</code> are done, we can finally implement evaluation of function definitions. Let‘s start with a test in <code>stmt.rs</code>:</p><pre><code class=language-rust>#[cfg(test)]
mod tests {
    // snip

    #[test]
    fn eval_func_def() {
        assert_eq!(
            Stmt::FuncDef(FuncDef {
                name: &quot;always_return_one&quot;.to_string(),
                params: Vec::new(),
                body: Box::new(Stmt::Expr(Expr::Number(Number(1)))),
            })
            .eval(&amp;mut Env::default()),
            Ok(Val::Unit),
        );
    }

    // snip
}
</code></pre><p>To stay consistent with <code>crate::stmt::tests::eval_binding_def</code>, the test doesn’t examine the effect it’s had on the <code>Env</code> &ndash; instead, it just checks that evaluating a function definition gives you a <code>Unit</code>.</p><pre><code class=language-->$ cargo t -q
running 52 tests
.............................................F......
failures:

---- stmt::tests::eval_func_def stdout ----
thread 'stmt::tests::eval_func_def' panicked at 'not yet implemented', crates/eldiro/src/stmt.rs:28:33
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    stmt::tests::eval_func_def

test result: FAILED. 51 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>Let’s remove the <code>todo!()</code> from <code>Stmt::eval</code>, and fix this:</p><pre><code class=language-rust>impl Stmt {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;mut Env) -&gt; Result&lt;Val, String&gt; {
        match self {
            Self::BindingDef(binding_def) =&gt; {
                binding_def.eval(env)?;
                Ok(Val::Unit)
            }
            Self::FuncDef(func_def) =&gt; {
                func_def.eval(env)?;
                Ok(Val::Unit)
            }
            Self::Expr(expr) =&gt; expr.eval(env),
        }
    }
}
</code></pre><p>Let’s create an empty <code>FuncDef::eval</code> so that we can run our tests:</p><pre><code class=language-rust>// func_def.rs

use crate::env::Env;
use crate::stmt::Stmt;
use crate::utils;

// snip

impl FuncDef {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;mut Env) -&gt; Result&lt;(), String&gt; {
        Ok(())
    }
}
</code></pre><pre><code class=language-->$ cargo t -q
running 52 tests
....................................................
test result: ok. 52 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre><p>We don’t need to write a test for evaluating function definitions, since the code to do so is trivial:<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><pre><code class=language-rust>impl FuncDef {
    // snip

    pub(crate) fn eval(&amp;self, env: &amp;mut Env) -&gt; Result&lt;(), String&gt; {
        env.store_func(self.name.clone(), self.params.clone(), *self.body.clone());
        Ok(())
    }
}
</code></pre><p>See you all next time, when we’ll add function calls to Eldiro.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>The syntax highlighting has gone away because this isn’t Rust anymore, and my website doesn’t have Eldiro syntax highlighting.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>I spent almost an hour trying to refactor this logic out so that it can be reused in an attempt to use the first approach without copy-pasting. My first try at this used a macro, but the macro took up more code than copy-pasting the code. The same thing happened when I tried using a generic function instead.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Famous last words.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></main><nav class=page-navigation><div class=prev><p class=hint>Previously</p><a href=https://arzg.github.io/lang/7/>Part Seven: A REPL</a></div><div class=next><p class=hint>Next up</p><a href=https://arzg.github.io/lang/9/>Part Nine: Function Calls</a></div><div style=clear:both></div></nav></body></html>