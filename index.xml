<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Luna Razzaghipour ðŸŒ™ on Lunaâ€™s Website</title><link>https://arzg.github.io/</link><description>Recent content in Luna Razzaghipour ðŸŒ™ on Lunaâ€™s Website</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><atom:link href="https://arzg.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Meta Memory</title><link>https://arzg.github.io/meta-memory/</link><pubDate>Mon, 08 Aug 2022 00:00:00 +0000</pubDate><guid>https://arzg.github.io/meta-memory/</guid><description>Letâ€™s take a tree structure
struct Expr { Int(u32), Add { lhs: Box&amp;lt;Expr&amp;gt;, rhs: Box&amp;lt;Expr&amp;gt; }, } and flatten it into a Vec&amp;lt;T&amp;gt;, or contiguous region of memory.
struct Arena(Vec&amp;lt;Expr&amp;gt;); struct Expr { Int(u32), Add { lhs: usize, rhs: usize }, } We can compare this representation to a traditional memory model:
memory meta-memory address space arena pointer usize malloc() Vec::push free() Vec::clear dereference indexing segfault out-of-bounds panic This simple abstraction over memory has some desirable performance and safety characteristics while also being more flexible than pointers, malloc() and free().</description></item></channel></rss>