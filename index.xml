<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Luna’s Website</title><link>https://arzg.github.io/</link><description>Recent content on Luna’s Website</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><atom:link href="https://arzg.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Don’t Zero Out Memory By Default</title><link>https://arzg.github.io/dont-zero-memory/</link><pubDate>Sun, 19 Feb 2023 00:00:00 +0000</pubDate><guid>https://arzg.github.io/dont-zero-memory/</guid><description>A common practice in low-level languages such as C and C++ is to default to filling memory with zeroes. For example, this proposal suggests zeroing out stack variables by default. Anonymous memory mappings created using mmap(2) are filled with zeroes, and so are allocations created with calloc(3). Missing fields in C’s designated initializers are &amp;ndash; you guessed it &amp;ndash; null-initialized. Uninitialized variables and missing struct literal fields default to zero in Odin.</description></item><item><title>A Simple Yet Useful Version of Generics</title><link>https://arzg.github.io/simple-generics/</link><pubDate>Fri, 17 Feb 2023 00:00:00 +0000</pubDate><guid>https://arzg.github.io/simple-generics/</guid><description>Traditionally, containers are seen as an area where generics with monomorphization are essential; who wants every key and every value in their hash table to be boxed? However, I think pretty much every use-case for generics in the context of containers can be replaced with something far simpler.
To start, let’s take a look at a simple implementation of a dynamic array in C. Everything in this post applies to any sort of container; I just chose a dynamic array because it’s the easiest to implement.</description></item><item><title>My Webfont Contradiction</title><link>https://arzg.github.io/webfonts/</link><pubDate>Fri, 17 Feb 2023 00:00:00 +0000</pubDate><guid>https://arzg.github.io/webfonts/</guid><description>I’ve seen lots of tech people complain online about how websites are becoming increasingly bloated. I understand this sentiment, completely.
One of the culprits which is often mentioned (alongside invasive advertising and mountains of JavaScript) is (are?) webfonts. I’ve seen them be derided for being a pointless waste of hundreds of kilobytes or perhaps even megabytes of bandwidth per page load, solely to cultivate a “brand image” or because some designer thought they looked nice.</description></item><item><title>Dynamic Arrays with Data-Oriented Design</title><link>https://arzg.github.io/dynamic-arrays-with-dod/</link><pubDate>Thu, 16 Feb 2023 00:00:00 +0000</pubDate><guid>https://arzg.github.io/dynamic-arrays-with-dod/</guid><description>I would say that dynamic arrays are the most common container type. When programming in a data-oriented style where all allocations are done ahead of time, dynamic arrays manifested as an explicit type like C++’s std::vector or Rust’s Vec&amp;lt;T&amp;gt; often aren’t even necessary.
In many cases, data-oriented design advocates the use of numerous large flat arrays of scalar values. A lot of code ends up consisting of logic to process items one by one, shoving them into those arrays along the way.</description></item><item><title>Escaping the Identifier Casing Orthodoxy</title><link>https://arzg.github.io/casing/</link><pubDate>Thu, 16 Feb 2023 00:00:00 +0000</pubDate><guid>https://arzg.github.io/casing/</guid><description>My initial programming experience was with Ruby and Python, for both of which there exists a strong convention regarding identifier casing:
Python &amp;amp; Ruby variable snake_case constant UPPER_SNAKE_CASE function snake_case type PascalCase Later when I began to use Rust, things stayed pretty much the same:
Python &amp;amp; Ruby Rust variable snake_case snake_case global variable UPPER_SNAKE_CASE constant UPPER_SNAKE_CASE UPPER_SNAKE_CASE function snake_case snake_case type PascalCase PascalCase enum variant PascalCase Once I started to explore C, casing wasn’t as clear cut.</description></item><item><title>How to Choose Colors for Your CLI Applications</title><link>https://arzg.github.io/terminal-colors/</link><pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate><guid>https://arzg.github.io/terminal-colors/</guid><description>Let’s say you’re creating a CLI tool which has to display syntax highlighted source code. You begin by choosing some colors which look nice with your chosen terminal theme:
~ — zsh — Sorcerer — 51×11 % highlight foo # just some docs func HelloWorld() [12]u8 { &amp;#9;return "hello world\n" } Finished highlighting in 0.02 seconds. % █ Nice! However, who knows if it’ll still look good for people who use a theme different to yours?</description></item><item><title>I Love Email</title><link>https://arzg.github.io/email/</link><pubDate>Mon, 23 Jan 2023 00:00:00 +0000</pubDate><guid>https://arzg.github.io/email/</guid><description>I constantly hear about how much everybody hates email. Look, I receive just as many spam messages and useless email-based notifications and stuffy vapid “regarding my previous email” work messages as the next gal. I get it. But I’ve found there’s something magical about email as a medium of communication, and as a technology.
As of late I’ve taken to emailing random people about things they’ve made when I find it on the internet.</description></item><item><title>Classes and Globals</title><link>https://arzg.github.io/classes-and-globals/</link><pubDate>Fri, 09 Dec 2022 00:00:00 +0000</pubDate><guid>https://arzg.github.io/classes-and-globals/</guid><description>As of late I’ve been going through the commit history of Rui Ueyama’s excellent chibicc, a self-hosting as-simple-as-possible C compiler.
One thing that stood out to me was the pervasive use of global variables. codegen.c is a good example. At the top of the file several statics are defined:
static FILE *output_file; static int depth; static char *argreg8[] = {&amp;quot;%dil&amp;quot;, &amp;quot;%sil&amp;quot;, &amp;quot;%dl&amp;quot;, &amp;quot;%cl&amp;quot;, &amp;quot;%r8b&amp;quot;, &amp;quot;%r9b&amp;quot;}; static char *argreg16[] = {&amp;quot;%di&amp;quot;, &amp;quot;%si&amp;quot;, &amp;quot;%dx&amp;quot;, &amp;quot;%cx&amp;quot;, &amp;quot;%r8w&amp;quot;, &amp;quot;%r9w&amp;quot;}; static char *argreg32[] = {&amp;quot;%edi&amp;quot;, &amp;quot;%esi&amp;quot;, &amp;quot;%edx&amp;quot;, &amp;quot;%ecx&amp;quot;, &amp;quot;%r8d&amp;quot;, &amp;quot;%r9d&amp;quot;}; static char *argreg64[] = {&amp;quot;%rdi&amp;quot;, &amp;quot;%rsi&amp;quot;, &amp;quot;%rdx&amp;quot;, &amp;quot;%rcx&amp;quot;, &amp;quot;%r8&amp;quot;, &amp;quot;%r9&amp;quot;}; static Obj *current_fn; output_file is used in println …</description></item><item><title>A Little Hack for Nicer Underlines in CSS</title><link>https://arzg.github.io/underlines/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://arzg.github.io/underlines/</guid><description>text-decoration: underline looks like this. To my eyes, the underline is too thick and too close to the text. How could we create our own custom underline using CSS?
The basic idea We can try creating a colored background behind the text we wish to underline, then resize and position it so it:
is one pixel tall spans the width of the text is positioned just above the very bottom edge of the text .</description></item><item><title>Meta Memory</title><link>https://arzg.github.io/meta-memory/</link><pubDate>Mon, 08 Aug 2022 00:00:00 +0000</pubDate><guid>https://arzg.github.io/meta-memory/</guid><description>Let’s take a tree structure
struct Expr { Int(u32), Add { lhs: Box&amp;lt;Expr&amp;gt;, rhs: Box&amp;lt;Expr&amp;gt; }, } and flatten it into a Vec&amp;lt;T&amp;gt;, or contiguous region of memory.
struct Arena(Vec&amp;lt;Expr&amp;gt;); struct Expr { Int(u32), Add { lhs: usize, rhs: usize }, } We can compare this representation to a traditional memory model:
memory meta-memory address space arena pointer usize malloc() Vec::push free() Vec::clear dereference indexing segfault out-of-bounds panic This simple abstraction over memory has some desirable performance and safety characteristics while also being more flexible than pointers, malloc() and free().</description></item></channel></rss>