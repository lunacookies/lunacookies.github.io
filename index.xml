<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Luna’s Website</title><link>https://arzg.github.io/</link><description>Recent content on Luna’s Website</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><atom:link href="https://arzg.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Dynamic Arrays with Data-Oriented Design</title><link>https://arzg.github.io/dynamic-arrays-with-dod/</link><pubDate>Thu, 16 Feb 2023 00:00:00 +0000</pubDate><guid>https://arzg.github.io/dynamic-arrays-with-dod/</guid><description>I would say that dynamic arrays are the most common container type. When programming in a data-oriented style where all allocations are done ahead of time, dynamic arrays manifested as an explicit type like C++’s std::vector or Rust’s Vec&amp;lt;T&amp;gt; often aren’t even necessary.
In many cases, data-oriented design advocates the use of numerous large flat arrays of scalar values. A lot of code ends up consisting of logic to process items one by one, shoving them into those arrays along the way.</description></item><item><title>Escaping the Identifier Casing Orthodoxy</title><link>https://arzg.github.io/casing/</link><pubDate>Thu, 16 Feb 2023 00:00:00 +0000</pubDate><guid>https://arzg.github.io/casing/</guid><description>My initial programming experience was with Ruby and Python, for both of which there exists a strong convention regarding identifier casing:
Python &amp;amp; Ruby variable snake_case constant UPPER_SNAKE_CASE function snake_case type PascalCase Later when I began to use Rust, things stayed pretty much the same:
Python &amp;amp; Ruby Rust variable snake_case snake_case global variable UPPER_SNAKE_CASE constant UPPER_SNAKE_CASE UPPER_SNAKE_CASE function snake_case snake_case type PascalCase PascalCase enum variant PascalCase Once I started to explore C, casing wasn’t as clear cut.</description></item><item><title>How to Choose Colors for Your CLI Applications</title><link>https://arzg.github.io/terminal-colors/</link><pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate><guid>https://arzg.github.io/terminal-colors/</guid><description>Let’s say you’re creating a CLI tool which has to display syntax highlighted source code. You begin by choosing some colors which look nice with your chosen terminal theme:
~ — zsh — Sorcerer — 51×11 % highlight foo # just some docs func HelloWorld() [12]u8 { &amp;#9;return "hello world\n" } Finished highlighting in 0.02 seconds. % █ Nice! However, who knows if it’ll still look good for people who use a theme different to yours?</description></item><item><title>I Love Email</title><link>https://arzg.github.io/email/</link><pubDate>Mon, 23 Jan 2023 00:00:00 +0000</pubDate><guid>https://arzg.github.io/email/</guid><description>I constantly hear about how much everybody hates email. Look, I receive just as many spam messages and useless email-based notifications and stuffy vapid “regarding my previous email” work messages as the next gal. I get it. But I’ve found there’s something magical about email as a medium of communication, and as a technology.
As of late I’ve taken to emailing random people about things they’ve made when I find it on the internet.</description></item><item><title>Classes and Globals</title><link>https://arzg.github.io/classes-and-globals/</link><pubDate>Fri, 09 Dec 2022 00:00:00 +0000</pubDate><guid>https://arzg.github.io/classes-and-globals/</guid><description>As of late I’ve been going through the commit history of Rui Ueyama’s excellent chibicc, a self-hosting as-simple-as-possible C compiler.
One thing that stood out to me was the pervasive use of global variables. codegen.c is a good example. At the top of the file several statics are defined:
static FILE *output_file; static int depth; static char *argreg8[] = {&amp;quot;%dil&amp;quot;, &amp;quot;%sil&amp;quot;, &amp;quot;%dl&amp;quot;, &amp;quot;%cl&amp;quot;, &amp;quot;%r8b&amp;quot;, &amp;quot;%r9b&amp;quot;}; static char *argreg16[] = {&amp;quot;%di&amp;quot;, &amp;quot;%si&amp;quot;, &amp;quot;%dx&amp;quot;, &amp;quot;%cx&amp;quot;, &amp;quot;%r8w&amp;quot;, &amp;quot;%r9w&amp;quot;}; static char *argreg32[] = {&amp;quot;%edi&amp;quot;, &amp;quot;%esi&amp;quot;, &amp;quot;%edx&amp;quot;, &amp;quot;%ecx&amp;quot;, &amp;quot;%r8d&amp;quot;, &amp;quot;%r9d&amp;quot;}; static char *argreg64[] = {&amp;quot;%rdi&amp;quot;, &amp;quot;%rsi&amp;quot;, &amp;quot;%rdx&amp;quot;, &amp;quot;%rcx&amp;quot;, &amp;quot;%r8&amp;quot;, &amp;quot;%r9&amp;quot;}; static Obj *current_fn; output_file is used in println …</description></item><item><title>A Little Hack for Nicer Underlines in CSS</title><link>https://arzg.github.io/underlines/</link><pubDate>Fri, 07 Oct 2022 00:00:00 +0000</pubDate><guid>https://arzg.github.io/underlines/</guid><description>text-decoration: underline looks like this. To my eyes, the underline is too thick and too close to the text. How could we create our own custom underline using CSS?
The basic idea We can try creating a colored background behind the text we wish to underline, then resize and position it so it:
is one pixel tall spans the width of the text is positioned just above the very bottom edge of the text .</description></item><item><title>Meta Memory</title><link>https://arzg.github.io/meta-memory/</link><pubDate>Mon, 08 Aug 2022 00:00:00 +0000</pubDate><guid>https://arzg.github.io/meta-memory/</guid><description>Let’s take a tree structure
struct Expr { Int(u32), Add { lhs: Box&amp;lt;Expr&amp;gt;, rhs: Box&amp;lt;Expr&amp;gt; }, } and flatten it into a Vec&amp;lt;T&amp;gt;, or contiguous region of memory.
struct Arena(Vec&amp;lt;Expr&amp;gt;); struct Expr { Int(u32), Add { lhs: usize, rhs: usize }, } We can compare this representation to a traditional memory model:
memory meta-memory address space arena pointer usize malloc() Vec::push free() Vec::clear dereference indexing segfault out-of-bounds panic This simple abstraction over memory has some desirable performance and safety characteristics while also being more flexible than pointers, malloc() and free().</description></item></channel></rss>